/*--------------------------------------------------------------------
 *    The MB-system:	mbsys_simrad.c	3.00	8/5/94
 *
 *    Copyright (c) 1994-2023 by
 *    David W. Caress (caress@mbari.org)
 *      Monterey Bay Aquarium Research Institute
 *      Moss Landing, California, USA
 *    Dale N. Chayes 
 *      Center for Coastal and Ocean Mapping
 *      University of New Hampshire
 *      Durham, New Hampshire, USA
 *    Christian dos Santos Ferreira
 *      MARUM
 *      University of Bremen
 *      Bremen Germany
 *     
 *    MB-System was created by Caress and Chayes in 1992 at the
 *      Lamont-Doherty Earth Observatory
 *      Columbia University
 *      Palisades, NY 10964
 *
 *    See README.md file for copying and redistribution conditions.
 *--------------------------------------------------------------------*/
/*
 * mbsys_simrad.c contains the MBIO functions for handling data from
 * old (pre-1997) Simrad multibeam sonars (e.g. EM950, EM1000, EM12S,
 * EM12D). The data formats associated with Simrad multibeams
 * (both old and new) include:
 *    MBSYS_SIMRAD formats (code in mbsys_simrad.c and mbsys_simrad.h):
 *      MBF_EMOLDRAW : MBIO ID 51 - Vendor EM1000, EM12S, EM12D, EM121
 *                   : MBIO ID 52 - aliased to 51
 *      MBF_EM12IFRM : MBIO ID 53 - IFREMER EM12S and EM12D
 *      MBF_EM12DARW : MBIO ID 54 - NERC EM12S
 *                   : MBIO ID 55 - aliased to 51
 *    MBSYS_SIMRAD2 formats (code in mbsys_simrad2.c and mbsys_simrad2.h):
 *      MBF_EM300RAW : MBIO ID 56 - Vendor EM3000, EM300, EM120
 *      MBF_EM300MBA : MBIO ID 57 - MBARI EM3000, EM300, EM120
 *
 * Author:	D. W. Caress
 * Date:	August 5, 1994
 *
 *
 *
 */

#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mb_define.h"
#include "mb_format.h"
#include "mb_io.h"
#include "mb_status.h"
#include "mbsys_simrad.h"

/* The following angle tables were provided by
    Dr. John Hughes Clarke of the University of
    New Brunswick. Dr. Clarke obtained these tables
    from IFREMER, which had obtained them from Simrad */

static double angles_EM1000_104_07_MS_48_FAIS[96] = {
    52.0000,  51.4375,  50.8125,  50.1875,  49.5625,  48.8750,  48.1875,  47.5000,  46.8125,  46.0625,  45.3125,  44.5000,
    43.7500,  42.9375,  42.0625,  41.1875,  40.3125,  39.4375,  38.5000,  37.5000,  36.5625,  35.5000,  34.5000,  33.4375,
    32.3125,  31.2500,  30.0625,  28.9375,  27.7500,  26.5000,  25.2500,  24.0000,  22.6875,  21.3125,  20.0000,  18.6250,
    17.1875,  15.8125,  14.3750,  12.8750,  11.4375,  09.9375,  08.4375,  06.9375,  05.3750,  03.8750,  02.3125,  00.7500,
    -0.7500,  -2.3125,  -3.8750,  -5.3750,  -6.9375,  -8.4375,  -9.9375,  -11.4375, -12.8750, -14.3750, -15.8125, -17.1875,
    -18.6250, -20.0000, -21.3125, -22.6875, -24.0000, -25.2500, -26.5000, -27.7500, -28.9375, -30.0625, -31.2500, -32.3125,
    -33.4375, -34.5000, -35.5000, -36.5625, -37.5000, -38.5000, -39.4375, -40.3125, -41.1875, -42.0625, -42.9375, -43.7500,
    -44.5000, -45.3125, -46.0625, -46.8125, -47.5000, -48.1875, -48.8750, -49.5625, -50.1875, -50.8125, -51.4375, -52.0000};
static double angles_EM1000_120_07_MS_48_FAIS[96] = {
    60.0000,  59.5000,  58.9375,  58.3750,  57.7500,  57.1875,  56.5625,  55.8750,  55.2500,  54.5625,  53.8125,  53.0625,
    52.3125,  51.5000,  50.6875,  49.8125,  48.9375,  48.0625,  47.0625,  46.1250,  45.0625,  44.0000,  42.9375,  41.7500,
    40.5625,  39.3750,  38.1250,  36.7500,  35.4375,  34.0000,  32.5625,  31.0625,  29.5000,  27.8750,  26.1875,  24.5000,
    22.7500,  20.9375,  19.1250,  17.2500,  15.3125,  13.3125,  11.3125,  09.3125,  07.2500,  05.1875,  03.1250,  01.0625,
    -01.0625, -03.1250, -05.1875, -07.2500, -09.3125, -11.3125, -13.3125, -15.3125, -17.2500, -19.1250, -20.9375, -22.7500,
    -24.5000, -26.1875, -27.8750, -29.5000, -31.0625, -32.5625, -34.0000, -35.4375, -36.7500, -38.1250, -39.3750, -40.5625,
    -41.7500, -42.9375, -44.0000, -45.0625, -46.1250, -47.0625, -48.0625, -48.9375, -49.8125, -50.6875, -51.5000, -52.3125,
    -53.0625, -53.8125, -54.5625, -55.2500, -55.8750, -56.5625, -57.1875, -57.7500, -58.3750, -58.9375, -59.5000, -60.0000};
static double angles_EM1000_128_02_MS_60_FAIS[120] = {
    64.0000,  63.6250,  63.2500,  62.8125,  62.3750,  61.9375,  61.5000,  61.0625,  60.6250,  60.1250,  59.6250,  59.1250,
    58.5625,  58.0625,  57.5000,  56.8750,  56.3125,  55.6875,  55.0625,  54.3750,  53.6875,  53.000,   52.2500,  51.5000,
    50.7500,  49.9375,  49.1250,  48.2500,  47.3750,  46.4375,  45.5000,  44.5000,  43.4375,  42.3750,  41.3125,  40.1875,
    39.0000,  37.8125,  36.5625,  35.2500,  33.8750,  32.5000,  31.0625,  29.6250,  28.1250,  26.5625,  24.9375,  23.3125,
    21.6250,  19.8750,  18.1250,  16.3125,  14.5000,  12.6250,  10.7500,  08.8125,  06.8750,  04.9375,  02.9375,  01.0000,
    -1.0000,  -2.9375,  -4.9375,  -6.8750,  -8.8125,  -10.7500, -12.6250, -14.5000, -16.3125, -18.1250, -19.8750, -21.6250,
    -23.3125, -24.9375, -26.5625, -28.1250, -29.6250, -31.0625, -32.5000, -33.8750, -35.2500, -36.5625, -37.8125, -39.0000,
    -40.1875, -41.3125, -42.3750, -43.4375, -44.5000, -45.5000, -46.4375, -47.3750, -48.2500, -49.1250, -49.9375, -50.7500,
    -51.5000, -52.2500, -53.0000, -53.6875, -54.3750, -55.0625, -55.6875, -56.3125, -56.8750, -57.5000, -58.0625, -58.5625,
    -59.1250, -59.6250, -60.1250, -60.6250, -61.0625, -61.5000, -61.9375, -62.3750, -62.8125, -63.2500, -63.6250, -64.0000};
static double angles_EM1000_140_02_MS_60_FAIS[120] = {
    70.0000,  69.6875,  69.3750,  69.0000,  68.6875,  68.3125,  67.9375,  67.5625,  67.1875,  66.8125,  66.3750,  65.9375,
    65.5000,  65.0000,  64.5625,  64.0625,  63.5625,  63.0000,  62.4375,  61.8750,  61.2500,  60.6250,  60.0000,  59.3125,
    58.6250,  57.8750,  57.1250,  56.3125,  55.5000,  54.6250,  53.6875,  52.7500,  51.7500,  50.7500,  49.6875,  48.5000,
    47.3125,  46.1250,  44.8125,  43.4375,  42.0000,  40.5000,  38.9375,  37.3125,  35.5625,  33.8125,  31.9345,  30.0000,
    28.0000,  25.8750,  23.6875,  21.4375,  19.1250,  16.6875,  14.2500,  11.7500,  09.1875,  06.5625,  03.9375,  01.3125,
    -1.3125,  -3.9375,  -6.5625,  -9.1875,  -11.7500, -14.2500, -16.6875, -19.1250, -21.4375, -23.6875, -25.8750, -28.0000,
    -30.0000, -31.9345, -33.8125, -35.5625, -37.3125, -38.9375, -40.5000, -42.0000, -43.4375, -44.8125, -46.1250, -47.3125,
    -48.5000, -49.6875, -50.7500, -51.7500, -52.7500, -53.6875, -54.6250, -55.5000, -56.3125, -57.1250, -57.8750, -58.6250,
    -59.3125, -60.0000, -60.6250, -61.2500, -61.8750, -62.4375, -63.0000, -63.5625, -64.0625, -64.5625, -65.0000, -65.5000,
    -65.9375, -66.3750, -66.8125, -67.1875, -67.5625, -67.9375, -68.3125, -68.6875, -69.0000, -69.3750, -69.6875, -70.0000};
static double angles_EM1000_150_02_MS_60_FAIS[120] = {
    75.0000,  74.7500,  74.5000,  74.2500,  74.0000,  73.6875,  73.3750,  73.1250,  72.8125,  72.5000,  72.1250,  71.8125,
    71.4375,  71.0625,  70.6875,  70.3125,  69.8750,  69.4375,  69.0000,  68.5000,  68.0000,  67.5000,  66.9375,  66.3750,
    65.8125,  65.1875,  64.5625,  63.8750,  63.1250,  62.3750,  61.6250,  60.7500,  59.8750,  58.9375,  58.0000,  56.9375,
    55.8750,  54.6875,  53.4375,  52.1250,  50.7500,  49.2500,  47.6875,  46.0000,  44.1875,  42.3125,  40.2500,  38.1250,
    35.8125,  33.3750,  30.8125,  28.0625,  25.1875,  22.1875,  19.0625,  15.7500,  12.3750,  08.9375,  05.3750,  01.8125,
    -1.8125,  -5.3750,  -8.9375,  -12.3750, -15.7500, -19.0625, -22.1875, -25.1875, -28.0625, -30.8125, -33.3750, -35.8125,
    -38.1250, -40.2500, -42.3125, -44.1875, -46.0000, -47.6875, -49.2500, -50.7500, -52.1250, -53.4375, -54.6875, -55.8750,
    -56.9375, -58.0000, -58.9375, -59.8750, -60.7500, -61.6250, -62.3750, -63.1250, -63.8750, -64.5625, -65.1875, -65.8125,
    -66.3750, -66.9375, -67.5000, -68.0000, -68.5000, -69.0000, -69.4375, -69.8750, -70.3125, -70.6875, -71.0625, -71.4375,
    -71.8125, -72.1250, -72.5000, -72.8125, -73.1250, -73.3750, -73.6875, -74.0000, -74.2500, -74.5000, -74.7500, -75.000};
static double angles_EM1000_70_2_MS_48_FAIS[48] = {
    35.000,   33.8125,  32.6250,  31.4375,  30.1875,  28.8750,  27.5625,  26.1875,  24.8125,  23.3750,  21.9375,  20.4375,
    18.9375,  17.3750,  15.8125,  14.1875,  12.6250,  10.9375,  09.3125,  07.6250,  05.9375,  04.2500,  02.5625,  00.8750,
    -0.8750,  -2.5625,  -3.4375,  -5.1250,  -6.8125,  -8.5000,  -10.1250, -11.8125, -13.4375, -15.0000, -16.5625, -18.1250,
    -19.6875, -21.1875, -22.6250, -24.0625, -25.5000, -26.8750, -28.1875, -29.5000, -30.8125, -32.0625, -33.2500, -34.4375};
static double angles_EM1000_88_07_MS_48_FAIS[96] = {
    44.0000,  43.3750,  42.7500,  42.1250,  41.5000,  40.8125,  40.1250,  39.4375,  38.7500,  38.0625,  37.3125,  36.5625,
    35.8125,  35.0625,  34.2500,  33.4375,  32.6250,  31.8125,  30.9375,  30.0625,  29.1875,  28.3125,  27.3750,  26.5000,
    25.5625,  24.5625,  23.6250,  22.6250,  21.6250,  20.6250,  19.5625,  18.5625,  17.5000,  16.4375,  15.3750,  14.2500,
    13.1875,  12.0625,  10.9375,  09.8125,  08.6875,  07.5000,  06.3750,  05.2500,  04.0625,  02.9375,  01.7500,  00.5625,
    -0.5625,  -1.7500,  -2.9375,  -4.0625,  -5.2500,  -6.3750,  -7.5000,  -8.6875,  -9.8125,  -10.9375, -12.0625, -13.1875,
    -14.2500, -15.3750, -16.4375, -17.5000, -18.5625, -19.5625, -20.6250, -21.6250, -22.6250, -23.6250, -24.5625, -25.5625,
    -26.5000, -27.3750, -28.3125, -29.1875, -30.0625, -30.9375, -31.8125, -32.6250, -33.4375, -34.2500, -35.0625, -35.8125,
    -36.5625, -37.3125, -38.0625, -38.7500, -39.4375, -40.1250, -40.8125, -41.5000, -42.1250, -42.7500, -43.3750, -44.0000};
/* static double angles_EM1000_PORT_02_MS_60_FAIS[120] = {
    95.0000,  93.5000,  92.0000,  90.5000,  89.0000,  87.5000,  86.0000,  84.5000,  83.0000,  81.5000,  80.0000,  78.5000,
    77.0000,  75.5000,  74.0000,  72.5000,  71.0000,  69.5000,  68.0000,  66.5000,  65.0000,  63.5000,  62.0000,  61.2500,
    60.4375,  59.6250,  58.7500,  57.8750,  56.8750,  55.8750,  54.8125,  53.6875,  52.5000,  51.1875,  49.8750,  48.4375,
    46.9375,  45.3750,  43.6875,  41.8750,  40.0000,  38.0000,  35.8750,  33.6250,  31.3125,  28.8125,  26.1875,  23.4375,
    20.6250,  17.6875,  14.6250,  11.4375,  08.2500,  05.0000,  01.6875,  -01.6250, -04.9375, -08.2500, -11.4375, -14.5625,
    -17.6250, -20.6250, -23.4375, -26.1875, -28.8125, -31.2500, -33.6250, -35.8750, -38.0000, -40.0000, -41.8750, -43.6875,
    -45.3750, -46.9375, -48.4375, -49.8750, -51.1875, -52.5000, -53.6875, -54.8125, -55.8750, -56.8750, -57.8750, -58.7500,
    -59.6250, -60.4325, -61.2500, -62.0000, -62.6875, -63.3750, -64.0625, -64.6875, -65.2500, -65.8125, -66.3750, -66.8750,
    -67.3750, -67.8750, -68.3125, -68.7500, -69.1875, -69.6250, -70.0000, -70.3750, -70.7500, -71.1250, -71.4375, -71.7500,
    -72.1250, -72.3750, -72.6875, -73.0000, -73.2500, -73.5625, -73.8125, -74.0625, -74.3125, -74.5625, -74.7500, -75.0000}; */
static double angles_EM1000_BERGE_02_MS_60_FAIS[120] = {
    95.0000,  93.5000,  92.0000,  90.5000,  89.0000,  87.5000,  86.0000,  84.5000,  83.0000,  81.5000,  80.0000,  78.5000,
    77.0000,  75.5000,  74.0000,  72.5000,  71.0000,  69.5000,  68.0000,  66.5000,  65.0000,  63.5000,  62.0000,  61.2500,
    60.4375,  59.6250,  58.7500,  57.8750,  56.8750,  55.8750,  54.8125,  53.6875,  52.5000,  51.1875,  49.8750,  48.4375,
    46.9375,  45.3750,  43.6875,  41.8750,  40.0000,  38.0000,  35.8750,  33.6250,  31.3125,  28.8125,  26.1875,  23.4375,
    20.6250,  17.6875,  14.6250,  11.4375,  08.2500,  05.0000,  01.6875,  -01.6250, -04.9375, -08.2500, -11.4375, -14.5625,
    -17.6250, -20.6250, -23.4375, -26.1875, -28.8125, -31.2500, -33.6250, -35.8750, -38.0000, -40.0000, -41.8750, -43.6875,
    -45.3750, -46.9375, -48.4375, -49.8750, -51.1875, -52.5000, -53.6875, -54.8125, -55.8750, -56.8750, -57.8750, -58.7500,
    -59.6250, -60.4325, -61.2500, -62.0000, -62.6875, -63.3750, -64.0625, -64.6875, -65.2500, -65.8125, -66.3750, -66.8750,
    -67.3750, -67.8750, -68.3125, -68.7500, -69.1875, -69.6250, -70.0000, -70.3750, -70.7500, -71.1250, -71.4375, -71.7500,
    -72.1250, -72.3750, -72.6875, -73.0000, -73.2500, -73.5625, -73.8125, -74.0625, -74.3125, -74.5625, -74.7500, -75.0000};

static double angles_EM1000_CHANNEL_02_MS_60_FAIS[120] = {
    95.0000,  93.5000,  92.0000,  90.5000,  89.0000,  87.5000,  86.0000,  84.5000,  83.0000,  81.5000,  80.0000,  78.5000,
    77.0000,  75.5000,  74.0000,  72.5000,  71.0000,  69.5000,  68.0000,  66.5000,  65.0000,  63.5000,  62.0000,  61.3750,
    60.6875,  60.0000,  59.2500,  58.5000,  57.6875,  56.8125,  55.9375,  55.0000,  54.0625,  53.0625,  52.0000,  50.8750,
    49.6875,  48.4375,  47.1875,  45.8125,  44.3750,  42.8750,  41.2500,  39.6250,  37.8750,  36.0000,  34.1250,  32.0625,
    30.0000,  27.7500,  25.5000,  23.0625,  20.6250,  18.0625,  15.4375,  12.6875,  09.9375,  07.1250,  04.3125,  01.4375,
    -1.4375,  -4.3125,  -7.1250,  -9.9375,  -12.6875, -15.4375, -18.0625, -20.6250, -23.0625, -25.5000, -27.7500, -30.0000,
    -32.0625, -34.1250, -36.0000, -37.8750, -39.6250, -41.2500, -42.8750, -44.3750, -45.8125, -47.1875, -48.4375, -49.6875,
    -50.8750, -52.0000, -53.0625, -54.0625, -55.0000, -55.9375, -56.8125, -57.6875, -58.5000, -59.2500, -60.0000, -60.6875,
    -61.3750, -62.0000, -63.5000, -65.0000, -66.5000, -68.0000, -69.5000, -71.0000, -72.5000, -74.0000, -75.5000, -77.0000,
    -78.5000, -80.0000, -81.5000, -83.0000, -84.5000, -86.0000, -87.5000, -89.0000, -90.5000, -92.0000, -93.5000, -95.0000};
static double angles_EM1000_ISO_ANG_120_07_MS_48_FAIS[96] = {
    59.3750,  58.1250,  56.8750,  55.6250,  54.3750,  53.1250,  51.8750,  50.6250,  49.3750,  48.1250,  46.8750,  45.6250,
    44.3750,  43.1250,  41.8750,  40.6250,  39.3750,  38.1250,  36.8750,  35.6250,  34.3750,  33.1250,  31.8750,  30.6250,
    29.3750,  28.1250,  26.8750,  25.6250,  24.3750,  23.1250,  21.8750,  20.6250,  19.3750,  18.1250,  16.8750,  15.6250,
    14.3750,  13.1250,  11.8750,  10.6250,  09.3750,  08.1250,  06.8750,  05.6250,  04.3750,  03.1250,  01.8750,  00.6250,
    -0.6250,  -1.8750,  -3.1250,  -4.3750,  -5.6250,  -6.8750,  -8.1250,  -9.3750,  -10.6250, -11.8750, -13.1250, -14.3750,
    -15.6250, -16.8750, -18.1250, -19.3750, -20.6250, -21.8750, -23.1250, -24.3750, -25.6250, -26.8750, -28.1250, -29.3750,
    -30.6250, -31.8750, -33.1250, -34.3750, -35.6250, -36.8750, -38.1250, -39.3750, -40.6250, -41.8750, -43.1250, -44.3750,
    -45.6250, -46.8750, -48.1250, -49.3750, -50.6250, -51.8750, -53.1250, -54.3750, -55.6250, -56.8750, -58.1250, -59.3750};
static double angles_EM1000_ISO_ANG_150_02_MS_60_FAIS[120] = {
    74.3750,  73.1250,  71.8750,  70.6250,  69.3750,  68.1250,  66.8750,  65.6250,  64.3750,  63.1250,  61.8750,  60.6250,
    59.3750,  58.1250,  56.8750,  55.6250,  54.3750,  53.1250,  51.8750,  50.6250,  49.3750,  48.1250,  46.8750,  45.6250,
    44.3750,  43.1250,  41.8750,  40.6250,  39.3750,  38.1250,  36.8750,  35.6250,  34.3750,  33.1250,  31.8750,  30.6250,
    29.3750,  28.1250,  26.8750,  25.6250,  24.3750,  23.1250,  21.8750,  20.6250,  19.3750,  18.1250,  16.8750,  15.6250,
    14.3750,  13.1250,  11.8750,  10.6250,  09.3750,  08.1250,  06.8750,  05.6250,  04.3750,  03.1250,  01.8750,  00.6250,
    -0.6250,  -1.8750,  -3.1250,  -4.3750,  -5.6250,  -6.8750,  -8.1250,  -9.3750,  -10.6250, -11.8750, -13.1250, -14.3750,
    -15.6250, -16.8750, -18.1250, -19.3750, -20.6250, -21.8750, -23.1250, -24.3750, -25.6250, -26.8750, -28.1250, -29.3750,
    -30.6250, -31.8750, -33.1250, -34.3750, -35.6250, -36.8750, -38.1250, -39.3750, -40.6250, -41.8750, -43.1250, -44.3750,
    -45.6250, -46.8750, -48.1250, -49.3750, -50.6250, -51.8750, -53.1250, -54.3750, -55.6250, -56.8750, -58.1250, -59.3750,
    -60.6250, -61.8750, -63.1250, -64.3750, -65.6250, -66.8750, -68.1250, -69.3750, -70.6250, -71.8750, -73.1250, -74.3750};
static double angles_EM1000_ISO_ANG_60_2_MS_48_FAIS[48] = {
    29.3750,  28.1250,  26.8750,  25.6250,  24.3750,  23.1250,  21.8750,  20.6250,  19.3750,  18.1250,  16.8750,  15.6250,
    14.3750,  13.1250,  11.8750,  10.6250,  09.3750,  08.1250,  06.8750,  05.6250,  04.3750,  03.1250,  01.8750,  00.6250,
    -0.6250,  -1.8750,  -3.1250,  -4.3750,  -5.6250,  -6.8750,  -8.1250,  -9.3750,  -10.6250, -11.8750, -13.1250, -14.3750,
    -15.6250, -16.8750, -18.1250, -19.3750, -20.6250, -21.8750, -23.1250, -24.3750, -25.6250, -26.8750, -28.1250, -29.3750};
/* static double angles_EM1000_SHALLOW[60] = {
    72.5000,  70.0000,  67.5000,  65.0000,  62.5000,  60.0000,  57.5000,  55.0000,  52.5000,  50.0000,  47.5000,  45.0000,
    42.5000,  40.0000,  37.5000,  35.0000,  32.5000,  30.0000,  27.5000,  25.0000,  22.5000,  20.0000,  17.5000,  15.0000,
    12.5000,  10.0000,  7.50000,  5.00000,  2.50000,  0.00000,  0.0000,   -2.5000,  -5.0000,  -7.5000,  -10.0000, -12.5000,
    -15.0000, -17.5000, -20.0000, -22.5000, -25.0000, -27.5000, -30.0000, -32.5000, -35.0000, -37.5000, -40.0000, -42.5000,
    -45.0000, -47.5000, -50.0000, -52.5000, -55.0000, -57.5000, -60.0000, -62.5000, -65.0000, -67.5000, -70.0000, -72.5000}; */
static double angles_EM12DP_114[81] = {
    57.0000, 56.6875, 56.3125, 56.0000, 55.6250, 55.2500, 54.8750, 54.5000, 54.1250, 53.7500, 53.3750, 52.9375, 52.5625, 52.1250,
    51.6875, 51.3125, 50.8125, 50.3750, 49.9375, 49.4375, 49.0000, 48.5000, 48.0000, 47.7000, 47.0000, 46.4375, 45.9375, 45.3750,
    44.8125, 44.2500, 43.6875, 43.1250, 42.5000, 41.8750, 41.2500, 40.6250, 39.9375, 39.3125, 38.6250, 37.9375, 37.2500, 36.5000,
    35.8125, 35.0625, 34.3125, 33.5625, 32.7500, 31.9375, 31.1250, 30.3125, 29.5000, 28.6250, 27.7500, 26.8750, 26.0000, 25.0625,
    24.1250, 23.1875, 22.2500, 21.3125, 20.3125, 19.3125, 18.3125, 17.3125, 16.3125, 15.2500, 14.2500, 13.1875, 12.1250, 11.0000,
    09.9375, 08.8750, 07.7500, 06.6875, 05.5625, 04.4375, 03.3750, 02.2500, 01.1250, 00.0000, -1.1250};
static double angles_EM12DS_114[81] = {
    1.1250,   -0.0000,  -1.1250,  -2.2500,  -3.3750,  -4.4375,  -5.5625,  -6.6875,  -7.7500,  -8.8750,  -9.9375,  -11.0000,
    -12.1250, -13.1875, -14.2500, -15.2500, -16.3125, -17.3125, -18.3125, -19.3125, -20.3125, -21.3125, -22.2500, -23.1875,
    -24.1250, -25.0625, -26.0000, -26.8750, -27.7500, -28.6250, -29.5000, -30.3125, -31.1250, -31.9375, -32.7500, -33.5625,
    -34.3125, -35.0625, -35.8125, -36.5000, -37.2500, -37.9375, -38.6250, -39.3125, -39.9375, -40.6250, -41.2500, -41.8750,
    -42.5000, -43.1250, -43.6875, -44.2500, -44.8125, -45.3750, -45.9375, -46.4375, -47.0000, -47.7000, -48.0000, -48.5000,
    -49.0000, -49.4375, -49.9375, -50.3750, -50.8125, -51.3125, -51.6875, -52.1250, -52.5625, -52.9375, -53.3750, -53.7500,
    -54.1250, -54.5000, -54.8750, -55.2500, -55.6250, -56.0000, -56.3125, -56.6875, -57.0000};
static double angles_EM12DP_128[81] = {
    64.0000, 63.6875, 63.4375, 63.1250, 62.8125, 62.5000, 62.1875, 61.8750, 61.5000, 61.1875, 60.8125, 60.4375, 60.1250, 59.7500,
    59.3125, 58.9375, 58.5625, 58.1250, 57.7500, 57.3125, 56.8750, 56.3750, 55.9375, 55.5000, 55.0000, 54.5000, 54.0000, 53.4375,
    52.9375, 52.3750, 51.8125, 51.2500, 50.6250, 50.0625, 49.4375, 48.8125, 48.1250, 47.4375, 46.7500, 46.0625, 45.3750, 44.6250,
    43.8125, 43.0625, 42.2500, 41.4375, 40.5625, 39.6875, 38.8125, 37.8750, 36.9375, 36.0000, 35.0000, 34.0000, 33.0000, 31.9375,
    30.8125, 29.7500, 28.5625, 27.4375, 26.2500, 25.0625, 23.8125, 22.5625, 21.2500, 19.9375, 18.6250, 17.3125, 15.9375, 14.5625,
    13.1250, 11.7500, 10.3125, 08.8750, 07.3750, 05.9375, 04.4375, 03.0000, 01.5000, 00.0000, -1.5000};
static double angles_EM12DS_128[81] = {
    1.5000,   -0.0000,  -1.5000,  -3.0000,  -4.4375,  -5.9375,  -7.3750,  -8.8750,  -10.3125, -11.7500, -13.1250, -14.5625,
    -15.9375, -17.3125, -18.6250, -19.9375, -21.2500, -22.5625, -23.8125, -25.0625, -26.2500, -27.4375, -28.5625, -29.7500,
    -30.8125, -31.9375, -33.0000, -34.0000, -35.0000, -36.0000, -36.9375, -37.8750, -38.8125, -39.6875, -40.5625, -41.4375,
    -42.2500, -43.0625, -43.8125, -44.6250, -45.3750, -46.0625, -46.7500, -47.4375, -48.1250, -48.8125, -49.4375, -50.0625,
    -50.6250, -51.2500, -51.8125, -52.3750, -52.9375, -53.4375, -54.0000, -54.5000, -55.0000, -55.5000, -55.9375, -56.3750,
    -56.8750, -57.3125, -57.7500, -58.1250, -58.5625, -58.9375, -59.3125, -59.7500, -60.1250, -60.4375, -60.8125, -61.1875,
    -61.5000, -61.8750, -62.1875, -62.5000, -62.8125, -63.1250, -63.4375, -63.6875, -64.0000};
static double angles_EM12DP_140[81] = {
    70.000000, 69.750000, 69.500000, 69.250000, 69.000000, 68.750000, 68.500000, 68.250000, 67.937500, 67.687500, 67.375000,
    67.062500, 66.750000, 66.437500, 66.125000, 65.812500, 65.437500, 65.125000, 64.750000, 64.375000, 64.000000, 63.625000,
    63.250000, 62.812500, 62.375000, 61.937500, 61.500000, 61.062500, 60.562500, 60.125000, 59.625000, 59.062500, 58.562500,
    58.000000, 57.437500, 56.812500, 56.250000, 55.625000, 54.937500, 54.312500, 53.625000, 52.875000, 52.125000, 51.375000,
    50.625000, 49.750000, 48.937500, 48.062500, 47.125000, 46.187500, 45.250000, 44.250000, 43.187500, 42.125000, 41.000000,
    39.875000, 38.687500, 37.437500, 36.125000, 34.812500, 33.437500, 32.062500, 30.562500, 29.125000, 27.562500, 25.937500,
    24.312500, 22.625000, 20.937500, 19.187500, 17.375000, 15.562500, 13.687500, 11.812500, 09.875000, 07.937500, 05.937500,
    04.000000, 02.000000, 00.000000, -2.0000000};
static double angles_EM12DS_140[81] = {
    2.0000,   -0.0000,  -2.0000,  -4.0000,  -5.9375,  -7.9375,  -9.8750,  -11.8125, -13.6875, -15.5625, -17.3750, -19.1875,
    -20.9375, -22.6250, -24.3125, -25.9375, -27.5625, -29.1250, -30.5625, -32.0625, -33.4375, -34.8125, -36.1250, -37.4375,
    -38.6875, -39.8750, -41.0000, -42.1250, -43.1875, -44.2500, -45.2500, -46.1875, -47.1250, -48.0625, -48.9375, -49.7500,
    -50.6250, -51.3750, -52.1250, -52.8750, -53.6250, -54.3125, -54.9375, -55.6250, -56.2500, -56.8125, -57.4375, -58.0000,
    -58.5625, -59.0625, -59.6250, -60.1250, -60.5625, -61.0625, -61.5000, -61.9375, -62.3750, -62.8125, -63.2500, -63.6250,
    -64.0000, -64.3750, -64.7500, -65.1250, -65.4375, -65.8125, -66.1250, -66.4375, -66.7500, -67.0625, -67.3750, -67.6875,
    -67.9375, -68.2500, -68.5000, -68.7500, -69.0000, -69.2500, -69.5000, -69.7500, -70.0000};
static double angles_EM12DP_150[81] = {
    75.000000,  74.812500,  74.625000, 74.437500, 74.250000, 74.062500, 73.812500, 73.625000, 73.375000, 73.187500, 72.937500,
    72.687500,  72.437500,  72.187500, 71.937500, 71.687500, 71.437500, 71.125000, 70.875000, 70.562500, 70.250000, 69.937500,
    69.625000,  69.312500,  68.937500, 68.625000, 68.250000, 67.875000, 67.437500, 67.062500, 66.625000, 66.187500, 65.750000,
    65.312500,  64.812500,  64.312500, 63.812500, 63.250000, 62.687500, 62.125000, 61.500000, 60.875000, 60.250000, 59.562500,
    58.812500,  58.125000,  57.312500, 56.500000, 55.687500, 54.812500, 53.875000, 52.937500, 51.875000, 50.875000, 49.750000,
    48.562500,  47.375000,  46.125000, 44.750000, 43.375000, 41.937500, 40.375000, 38.750000, 37.062500, 35.312500, 33.500000,
    31.562500,  29.562500,  27.437500, 25.312500, 23.063499, 20.687500, 18.312500, 15.812500, 13.312500, 10.687500, 08.0625000,
    05.3750000, 02.6875000, 00.000000, -2.6875000};
static double angles_EM12DS_150[81] = {
    2.6875,   -0.0000,  -2.6875,  -5.3750,  -8.0625,  -10.6875, -13.3125, -15.8125, -18.3125, -20.6875, -23.0635, -25.3125,
    -27.4375, -29.5625, -31.5625, -33.5000, -35.3125, -37.0625, -38.7500, -40.3750, -41.9375, -43.3750, -44.7500, -46.1250,
    -47.3750, -48.5625, -49.7500, -50.8750, -51.8750, -52.9375, -53.8750, -54.8125, -55.6875, -56.5000, -57.3125, -58.1250,
    -58.8125, -59.5625, -60.2500, -60.8750, -61.5000, -62.1250, -62.6875, -63.2500, -63.8125, -64.3125, -64.8125, -65.3125,
    -65.7500, -66.1875, -66.6250, -67.0625, -67.4375, -67.8750, -68.2500, -68.6250, -68.9375, -69.3125, -69.6250, -69.9375,
    -70.2500, -70.5625, -70.8750, -71.1250, -71.4375, -71.6875, -71.9375, -72.1875, -72.4375, -72.6875, -72.9375, -73.1875,
    -73.3750, -73.6250, -73.8125, -74.0625, -74.2500, -74.4375, -74.6250, -74.8125, -75.0000};
static double angles_EM12DP_98[81] = {
    49.0000, 48.6250, 48.2500, 47.8750, 47.5000, 47.1250, 46.7500, 46.3750, 45.9375, 45.5625, 45.1250, 44.6875, 44.3125, 43.8750,
    43.4375, 43.0000, 42.5625, 42.0625, 41.6250, 41.1250, 40.6875, 40.1875, 39.6875, 39.1875, 38.6875, 38.1875, 37.6875, 37.1250,
    36.6250, 36.0625, 35.5000, 34.9375, 34.3750, 33.8125, 33.2500, 32.6250, 32.0625, 31.4375, 30.8125, 30.2500, 29.5625, 28.9375,
    28.3125, 27.6875, 27.0000, 26.3125, 25.6875, 25.0000, 24.3125, 23.6250, 22.8750, 22.1875, 21.4375, 20.7500, 20.0000, 19.2500,
    18.5000, 17.7500, 17.0000, 16.2500, 15.4375, 14.6875, 13.8750, 13.1250, 12.3125, 11.5000, 10.7500, 09.9375, 09.1250, 08.3125,
    07.4375, 06.6250, 05.8125, 05.0000, 04.1875, 03.3125, 02.5000, 01.6875, 00.8125, 00.0000, -0.8125};
static double angles_EM12DS_98[81] = {
    0.8125,   -0.0000,  -0.8125,  -1.6875,  -2.5000,  -3.3125,  -4.1875,  -5.0000,  -5.8125,  -6.6250,  -7.4375,  -8.3125,
    -9.1250,  -9.9375,  -10.7500, -11.5000, -12.3125, -13.1250, -13.8750, -14.6875, -15.4375, -16.2500, -17.0000, -17.7500,
    -18.5000, -19.2500, -20.0000, -20.7500, -21.4375, -22.1875, -22.8750, -23.6250, -24.3125, -25.0000, -25.6875, -26.3125,
    -27.0000, -27.6875, -28.3125, -28.9375, -29.5625, -30.2500, -30.8125, -31.4375, -32.0625, -32.6250, -33.2500, -33.8125,
    -34.3750, -34.9375, -35.5000, -36.0625, -36.6250, -37.1250, -37.6875, -38.1875, -38.6875, -39.1875, -39.6875, -40.1875,
    -40.6875, -41.1250, -41.6250, -42.0625, -42.5625, -43.0000, -43.4375, -43.8750, -44.3125, -44.6875, -45.1250, -45.5625,
    -45.9375, -46.3750, -46.7500, -47.1250, -47.5000, -47.8750, -48.2500, -48.6250, -49.0000};
static double angles_EM12DP_ISO_ANG_DEEP[81] = {
    75.0000, 74.0000, 73.0000, 72.0000, 71.0000, 70.0000, 69.0000, 68.0000, 67.0000, 66.0000, 65.0000, 64.0000, 63.0000, 62.0000,
    61.0000, 60.0000, 59.0000, 58.0000, 57.0000, 56.0000, 55.0000, 54.0000, 53.0000, 52.0000, 51.0000, 50.0000, 49.0000, 48.0000,
    47.0000, 46.0000, 45.0000, 44.0000, 43.0000, 42.0000, 41.0000, 40.0000, 39.0000, 38.0000, 37.0000, 36.0000, 35.0000, 34.0000,
    33.0000, 32.0000, 31.0000, 30.0000, 29.0000, 28.0000, 27.0000, 26.0000, 25.0000, 24.0000, 23.0000, 22.0000, 21.0000, 20.0000,
    19.0000, 18.0000, 17.0000, 16.0000, 15.0000, 14.0000, 13.0000, 12.0000, 11.0000, 10.0000, 09.0000, 08.0000, 07.0000, 06.0000,
    05.0000, 04.0000, 03.0000, 02.0000, 01.0000, 00.0000, -1.0000, -2.0000, -3.0000, -4.0000, -5.0000};
static double angles_EM12DS_ISO_ANG_DEEP[81] = {
    05.0000,  04.0000,  03.0000,  02.0000,  01.0000,  00.0000,  -01.0000, -02.0000, -03.0000, -04.0000, -05.0000, -06.0000,
    -07.0000, -08.0000, -09.0000, -10.0000, -11.0000, -12.0000, -13.0000, -14.0000, -15.0000, -16.0000, -17.0000, -18.0000,
    -19.0000, -20.0000, -21.0000, -22.0000, -23.0000, -24.0000, -25.0000, -26.0000, -27.0000, -28.0000, -29.0000, -30.0000,
    -31.0000, -32.0000, -33.0000, -34.0000, -35.0000, -36.0000, -37.0000, -38.0000, -39.0000, -40.0000, -41.0000, -42.0000,
    -43.0000, -44.0000, -45.0000, -46.0000, -47.0000, -48.0000, -49.0000, -50.0000, -51.0000, -52.0000, -53.0000, -54.0000,
    -55.0000, -56.0000, -57.0000, -58.0000, -59.0000, -60.0000, -61.0000, -62.0000, -63.0000, -64.0000, -65.0000, -66.0000,
    -67.0000, -68.0000, -69.0000, -70.0000, -71.0000, -72.0000, -73.0000, -74.0000, -75.0000};
static double angles_EM12DP_ISO_ANG_SHALLOW[81] = {
    75.0000, 74.0000, 73.0000, 72.0000, 71.0000, 70.0000, 69.0000, 68.0000, 67.0000, 66.0000, 65.0000, 64.0000, 63.0000, 62.0000,
    61.0000, 60.0000, 59.0000, 58.0000, 57.0000, 56.0000, 55.0000, 54.0000, 53.0000, 52.0000, 51.0000, 50.0000, 49.0000, 48.0000,
    47.0000, 46.0000, 45.0000, 44.0000, 43.0000, 42.0000, 41.0000, 40.0000, 39.0000, 38.0000, 37.0000, 36.0000, 35.0000, 34.0000,
    33.0000, 32.0000, 31.0000, 30.0000, 29.0000, 28.0000, 27.0000, 26.0000, 25.0000, 24.0000, 23.0000, 22.0000, 21.0000, 20.0000,
    19.0000, 18.0000, 17.0000, 16.0000, 15.0000, 14.0000, 13.0000, 12.0000, 11.0000, 10.0000, 09.0000, 08.0000, 07.0000, 06.0000,
    05.0000, 04.0000, 03.0000, 02.0000, 01.0000, 00.0000, -1.0000, -2.0000, -3.0000, -4.0000, -5.000};
static double angles_EM12DS_ISO_ANG_SHALLOW[81] = {
    5.0000,   4.0000,   3.0000,   2.0000,   1.0000,   -0.0000,  -1.0000,  -2.0000,  -3.0000,  -4.0000,  -5.0000,  -6.0000,
    -7.0000,  -8.0000,  -9.0000,  -10.0000, -11.0000, -12.0000, -13.0000, -14.0000, -15.0000, -16.0000, -17.0000, -18.0000,
    -19.0000, -20.0000, -21.0000, -22.0000, -23.0000, -24.0000, -25.0000, -26.0000, -27.0000, -28.0000, -29.0000, -30.0000,
    -31.0000, -32.0000, -33.0000, -34.0000, -35.0000, -36.0000, -37.0000, -38.0000, -39.0000, -40.0000, -41.0000, -42.0000,
    -43.0000, -44.0000, -45.0000, -46.0000, -47.0000, -48.0000, -49.0000, -50.0000, -51.0000, -52.0000, -53.0000, -54.0000,
    -55.0000, -56.0000, -57.0000, -58.0000, -59.0000, -60.0000, -61.0000, -62.0000, -63.0000, -64.0000, -65.0000, -66.0000,
    -67.0000, -68.0000, -69.0000, -70.0000, -71.0000, -72.0000, -73.0000, -74.0000, -75.0000};
static double angles_EM12DP_SHALLOW[81] = {
    75.00000, 74.81250, 74.62500, 74.43750, 74.25000, 74.06250, 73.81250, 73.62500, 73.37500, 73.18750, 72.93750, 72.68750,
    72.43750, 72.18750, 71.93750, 71.68750, 71.43750, 71.12500, 70.87500, 70.56250, 70.25000, 69.93750, 69.62500, 69.31250,
    68.93750, 68.62500, 68.25000, 67.87500, 67.43750, 67.06250, 66.62500, 66.18750, 65.75000, 65.31250, 64.81250, 64.31250,
    63.81250, 63.25000, 62.68750, 62.12500, 61.50000, 60.87500, 60.25000, 59.56250, 58.81250, 58.12500, 57.31250, 56.50000,
    55.68750, 54.81250, 53.87500, 52.93750, 51.87500, 50.87500, 49.75000, 48.56250, 47.37500, 46.12500, 44.75000, 43.37500,
    41.93750, 40.37500, 38.75000, 37.06250, 35.31250, 33.50000, 31.56250, 29.56250, 27.43750, 25.31250, 23.06250, 20.68750,
    18.31250, 15.81250, 13.31250, 10.68750, 08.06250, 05.37500, 02.68750, 00.00000, -02.6875};
static double angles_EM12DS_SHALLOW[81] = {
    02.68750, -00.0000, -02.6875, -05.3750, -08.0625, -10.6875, -13.3125, -15.8125, -18.3125, -20.6875, -23.0625, -25.3125,
    -27.4375, -29.5625, -31.5625, -33.5000, -35.3125, -37.0625, -38.7500, -40.3750, -41.9375, -43.3750, -44.7500, -46.1250,
    -47.3750, -48.5625, -49.7500, -50.8750, -51.8750, -52.9375, -53.8750, -54.8125, -55.6875, -56.5000, -57.3125, -58.1250,
    -58.8125, -59.5625, -60.2500, -60.8750, -61.5000, -62.1250, -62.6875, -63.2500, -63.8125, -64.3125, -64.8125, -65.3125,
    -65.7500, -66.1875, -66.6250, -67.0625, -67.4375, -67.8750, -68.2500, -68.6250, -68.9375, -69.3125, -69.6250, -69.9375,
    -70.2500, -70.5625, -70.8750, -71.1250, -71.4375, -71.6875, -71.9375, -72.1875, -72.4375, -72.6875, -72.9375, -73.1875,
    -73.3750, -73.6250, -73.8125, -74.0625, -74.2500, -74.4375, -74.6250, -74.8125, -75.0000};
static double angles_EM12S_105[81] = {
    52.5000,  51.8125,  51.0625,  50.3125,  49.5625,  48.7500,  47.9375,  47.0625,  46.1875,  45.3125,  44.3750,  43.3750,
    42.3750,  41.3125,  40.2500,  39.1875,  38.0000,  36.8750,  35.6250,  34.3750,  33.0625,  31.7500,  30.3750,  29.0000,
    27.5625,  26.0625,  24.5000,  22.9375,  21.3750,  19.6875,  18.0625,  16.3125,  14.6250,  12.8750,  11.0625,  09.2500,
    07.4375,  05.5625,  03.7500,  01.8750,  00.0000,  -1.8750,  -3.7500,  -5.5625,  -7.4375,  -9.2500,  -11.0625, -12.8750,
    -14.6250, -16.3125, -18.0625, -19.6875, -21.3750, -22.9375, -24.5000, -26.0625, -27.5625, -29.0000, -30.3750, -31.7500,
    -33.0625, -34.3750, -35.6250, -36.8750, -38.0000, -39.1875, -40.2500, -41.3125, -42.3750, -43.3750, -44.3750, -45.3125,
    -46.1875, -47.0625, -47.9375, -48.7500, -49.5625, -50.3125, -51.0625, -51.8125, -52.5000};
static double angles_EM12S_120[81] = {
    60.0000,  59.3750,  58.6875,  58.0000,  57.3125,  56.5625,  55.8125,  55.0000,  54.1875,  53.3125,  52.4375,  51.4375,
    50.5000,  49.4375,  48.3750,  47.2500,  46.1250,  44.8750,  43.6250,  42.2500,  40.8750,  39.4375,  37.9375,  36.3750,
    34.6875,  33.0000,  31.2500,  29.3750,  27.4375,  25.5000,  23.4375,  21.3125,  19.1250,  16.8750,  14.5625,  12.1875,
    09.8125,  07.3750,  04.9375,  02.5000,  00.0000,  -2.5000,  -4.9375,  -7.3750,  -9.8125,  -12.1875, -14.5625, -16.8750,
    -19.1250, -21.3125, -23.4375, -25.5000, -27.4375, -29.3750, -31.2500, -33.0000, -34.6875, -36.3750, -37.9375, -39.4375,
    -40.8750, -42.2500, -43.6250, -44.8750, -46.1250, -47.2500, -48.3750, -49.4375, -50.5000, -51.4375, -52.4375, -53.3125,
    -54.1875, -55.0000, -55.8125, -56.5625, -57.3125, -58.0000, -58.6875, -59.3750, -60.0000};
static double angles_EM12S_90[81] = {
    45.0000,  44.2500,  43.5000,  42.7500,  42.0000,  41.1875,  40.3750,  39.5000,  38.6875,  37.7500,  36.8750,  35.9375,
    35.0000,  34.0000,  33.0000,  32.0000,  30.9375,  29.8750,  28.8125,  27.6875,  26.5625,  25.4375,  24.2500,  23.0000,
    21.8125,  20.5625,  19.3125,  18.0000,  16.6875,  15.3750,  14.0625,  12.6875,  11.3125,  09.9375,  08.5000,  07.1250,
    05.6875,  04.3125,  02.8750,  01.4375,  00.0000,  -1.4375,  -2.8750,  -4.3125,  -5.6875,  -7.1250,  -8.5000,  -9.9375,
    -11.3125, -12.6875, -14.0625, -15.3750, -16.6875, -18.0000, -19.3125, -20.5625, -21.8125, -23.0000, -24.2500, -25.4375,
    -26.5625, -27.6875, -28.8125, -29.8750, -30.9375, -32.0000, -33.0000, -34.0000, -35.0000, -35.9375, -36.8750, -37.7500,
    -38.6875, -39.5000, -40.3750, -41.1875, -42.0000, -42.7500, -43.5000, -44.2500, -45.0000};
static double angles_EM12S_ISO_ANG_DEEP[81] = {
    45.0000,  43.8750,  42.7500,  41.6250,  40.5000,  39.3750,  38.2500,  37.1250,  36.0000,  34.8750,  33.7500,  32.6250,
    31.5000,  30.3750,  29.2500,  28.1250,  27.0000,  25.8750,  24.7500,  23.6250,  22.5000,  21.3750,  20.2500,  19.1250,
    18.0000,  16.8750,  15.7500,  14.6250,  13.5000,  12.3750,  11.2500,  10.1250,  09.0000,  07.8750,  06.7500,  05.6250,
    04.5000,  03.3700,  02.2500,  01.1250,  -0.0000,  -01.1250, -02.2500, -03.3700, -04.5000, -05.6250, -06.7500, -07.8750,
    -09.0000, -10.1250, -11.2500, -12.3750, -13.5000, -14.6250, -15.7500, -16.8750, -18.0000, -19.1250, -20.2500, -21.3750,
    -22.5000, -23.6250, -24.7500, -25.8750, -27.0000, -28.1250, -29.2500, -30.3750, -31.5000, -32.6250, -33.7500, -34.8750,
    -36.0000, -37.1250, -38.2500, -39.3750, -40.5000, -41.6250, -42.7500, -43.8750, -45.0000};
static double angles_EM12S_ISO_ANG_SHALLOW[81] = {
    45.0000,  43.8750,  42.7500,  41.6250,  40.5000,  39.3750,  38.2500,  37.1250,  36.0000,  34.8750,  33.7500,  32.6250,
    31.5000,  30.3750,  29.2500,  28.1250,  27.0000,  25.8750,  24.7500,  23.6250,  22.5000,  21.3750,  20.2500,  19.1250,
    18.0000,  16.8750,  15.7500,  14.6250,  13.5000,  12.3750,  11.2500,  10.1250,  09.0000,  07.8750,  06.7500,  05.6250,
    04.5000,  03.3700,  02.2500,  01.1250,  -0.0000,  -1.1250,  -2.2500,  -3.3700,  -4.5000,  -5.6250,  -6.7500,  -7.8750,
    -9.0000,  -10.1250, -11.2500, -12.3750, -13.5000, -14.6250, -15.7500, -16.8750, -18.0000, -19.1250, -20.2500, -21.3750,
    -22.5000, -23.6250, -24.7500, -25.8750, -27.0000, -28.1250, -29.2500, -30.3750, -31.5000, -32.6250, -33.7500, -34.8750,
    -36.0000, -37.1250, -38.2500, -39.3750, -40.5000, -41.6250, -42.7500, -43.8750, -45.0000};
static double angles_EM12S_SHALLOW[81] = {
    60.0000,  59.3750,  58.6875,  58.0000,  57.3125,  56.5625,  55.8125,  55.0000,  54.1875,  53.3125,  52.4375,  51.4375,
    50.5000,  49.4375,  48.3750,  47.2500,  46.1250,  44.8750,  43.6250,  42.2500,  40.8750,  39.4375,  37.9375,  36.3750,
    34.6875,  33.0000,  31.2500,  29.3750,  27.4375,  25.5000,  23.4375,  21.3125,  19.1250,  16.8750,  14.5625,  12.1875,
    09.8125,  07.3750,  04.9375,  02.5000,  00.0000,  -02.5000, -04.9375, -07.3750, -09.8125, -12.1875, -14.5625, -16.8750,
    -19.1250, -21.3125, -23.4375, -25.5000, -27.4375, -29.3750, -31.2500, -33.0000, -34.6875, -36.3750, -37.9375, -39.4375,
    -40.8750, -42.2500, -43.6250, -44.8750, -46.1250, -47.2500, -48.3750, -49.4375, -50.5000, -51.4375, -52.4375, -53.3125,
    -54.1875, -55.0000, -55.8125, -56.5625, -57.3125, -58.0000, -58.6875, -59.3750, -60.0000};
static double angles_EM121_GUESS[121] = {
    60.0,  59.0,  58.0,  57.0,  56.0,  55.0,  54.0,  53.0,  52.0,  51.0,  50.0,  49.0,  48.0,  47.0,  46.0,  45.0,  44.0,  43.0,
    42.0,  41.0,  40.0,  39.0,  38.0,  37.0,  36.0,  35.0,  34.0,  33.0,  32.0,  31.0,  30.0,  29.0,  28.0,  27.0,  26.0,  25.0,
    24.0,  23.0,  22.0,  21.0,  20.0,  19.0,  18.0,  17.0,  16.0,  15.0,  14.0,  13.0,  12.0,  11.0,  10.0,  9.0,   8.0,   7.0,
    6.0,   5.0,   4.0,   3.0,   2.0,   1.0,   0.0,   -1.0,  -2.0,  -3.0,  -4.0,  -5.0,  -6.0,  -7.0,  -8.0,  -9.0,  -10.0, -11.0,
    -12.0, -13.0, -14.0, -15.0, -16.0, -17.0, -18.0, -19.0, -20.0, -21.0, -22.0, -23.0, -24.0, -25.0, -26.0, -27.0, -28.0, -29.0,
    -30.0, -31.0, -32.0, -33.0, -34.0, -35.0, -36.0, -37.0, -38.0, -39.0, -40.0, -41.0, -42.0, -43.0, -44.0, -45.0, -46.0, -47.0,
    -48.0, -49.0, -50.0, -51.0, -52.0, -53.0, -54.0, -55.0, -56.0, -57.0, -58.0, -59.0, -60.0};

/*--------------------------------------------------------------------*/
int mbsys_simrad_alloc(int verbose, void *mbio_ptr, void **store_ptr, int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:    %d\n", verbose);
		fprintf(stderr, "dbg2       mbio_ptr:   %p\n", (void *)mbio_ptr);
	}

	/* get mbio descriptor */
	// struct mb_io_struct *mb_io_ptr = (struct mb_io_struct *)mbio_ptr;

	/* allocate memory for data structure */
	const int status = mb_mallocd(verbose, __FILE__, __LINE__, sizeof(struct mbsys_simrad_struct), (void **)store_ptr, error);

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)*store_ptr;

	/* initialize everything */
	store->kind = MB_DATA_NONE;
	store->sonar = MBSYS_SIMRAD_UNKNOWN;

	/* parameter datagram */
	store->par_year = 0;
	store->par_month = 0;
	store->par_day = 0;
	store->par_hour = 0;
	store->par_minute = 0;
	store->par_second = 0;
	store->par_centisecond = 0;
	store->pos_type = 0;         /* positioning system type */
	store->pos_delay = 0.0;      /* positioning system delay (sec) */
	store->roll_offset = 0.0;    /* roll offset (degrees) */
	store->pitch_offset = 0.0;   /* pitch offset (degrees) */
	store->heading_offset = 0.0; /* heading offset (degrees) */
	store->em100_td = 0.0;       /* EM-100 transducer depth (meters) */
	store->em100_tx = 0.0;       /* EM-100 transducer fore-aft
	                     offset (meters) */
	store->em100_ty = 0.0;       /* EM-100 transducer athwartships
	                     offset (meters) */
	store->em12_td = 0.0;        /* EM-12 transducer depth (meters) */
	store->em12_tx = 0.0;        /* EM-12 transducer fore-aft
	                     offset (meters) */
	store->em12_ty = 0.0;        /* EM-12 transducer athwartships
	                     offset (meters) */
	store->em1000_td = 0.0;      /* EM-1000 transducer depth (meters) */
	store->em1000_tx = 0.0;      /* EM-1000 transducer fore-aft
	                     offset (meters) */
	store->em1000_ty = 0.0;      /* EM-1000 transducer athwartships
	                     offset (meters) */
	for (int i = 0; i < 128; i++)
		store->spare_parameter[i] = '\0';
	store->survey_line = 0;
	for (int i = 0; i < 80; i++)
		store->comment[i] = '\0';

	/* position (position datagrams) */
	store->pos_year = 0;
	store->pos_month = 0;
	store->pos_day = 0;
	store->pos_hour = 0;
	store->pos_minute = 0;
	store->pos_second = 0;
	store->pos_centisecond = 0;
	store->pos_latitude = 0.0;
	store->pos_longitude = 0.0;
	store->utm_northing = 0.0;
	store->utm_easting = 0.0;
	store->utm_zone = 0;
	store->utm_zone_lon = 0.0;
	store->utm_system = 0;
	store->pos_quality = 0;
	store->speed = 0.0;        /* meters/second */
	store->line_heading = 0.0; /* degrees */

	/* sound velocity profile */
	store->svp_year = 0;
	store->svp_month = 0;
	store->svp_day = 0;
	store->svp_hour = 0;
	store->svp_minute = 0;
	store->svp_second = 0;
	store->svp_centisecond = 0;
	store->svp_num = 0;
	for (int i = 0; i < 100; i++) {
		store->svp_depth[i] = 0; /* meters */
		store->svp_vel[i] = 0;   /* 0.1 meters/sec */
	}

	/* time stamp */
	store->year = 0;
	store->month = 0;
	store->day = 0;
	store->hour = 0;
	store->minute = 0;
	store->second = 0;
	store->centisecond = 0;

	/* survey data structure not allocated yet */
	store->ping = NULL;

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       store_ptr:  %p\n", (void *)*store_ptr);
		fprintf(stderr, "dbg2       error:      %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:     %d\n", status);
	}

	return (status);
}

/*--------------------------------------------------------------------*/
int mbsys_simrad_survey_alloc(int verbose, void *mbio_ptr, void *store_ptr, int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:    %d\n", verbose);
		fprintf(stderr, "dbg2       mbio_ptr:   %p\n", (void *)mbio_ptr);
		fprintf(stderr, "dbg2       store_ptr:  %p\n", (void *)store_ptr);
	}

	/* get mbio descriptor */
	// struct mb_io_struct *mb_io_ptr = (struct mb_io_struct *)mbio_ptr;

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)store_ptr;

	int status = MB_SUCCESS;

	/* allocate memory for data structure if needed */
	if (store->ping == NULL)
		status =
		    mb_mallocd(verbose, __FILE__, __LINE__, sizeof(struct mbsys_simrad_survey_struct), (void **)&(store->ping), error);

	if (status == MB_SUCCESS) {
		/* get data structure pointer */
		struct mbsys_simrad_survey_struct *ping = (struct mbsys_simrad_survey_struct *)store->ping;

		/* initialize everything */
		ping->swath_id = EM_SWATH_CENTER;
		ping->longitude = 0.0;
		ping->latitude = 0.0;
		ping->ping_number = 0;
		ping->beams_bath = MBSYS_SIMRAD_MAXBEAMS;
		ping->bath_mode = 0;
		ping->bath_res = 0;
		ping->bath_quality = 0;
		ping->bath_num = 0;
		ping->pulse_length = 0;
		ping->beam_width = 0;
		ping->power_level = 0;
		ping->tx_status = 0;
		ping->rx_status = 0;
		ping->along_res = 0;
		ping->across_res = 0;
		ping->depth_res = 0;
		ping->range_res = 0;
		ping->keel_depth = 0;
		ping->heading = 0;
		ping->roll = 0;
		ping->pitch = 0;
		ping->xducer_pitch = 0;
		ping->ping_heave = 0;
		ping->sound_vel = 0;
		ping->ss_status = EM_SS_NONE;
		ping->pixels_ssraw = 0;
		ping->ss_mode = 0;
		for (int i = 0; i < MBSYS_SIMRAD_MAXBEAMS; i++) {
			ping->bath[i] = 0;
			ping->bath_acrosstrack[i] = 0;
			ping->bath_alongtrack[i] = 0;
			ping->tt[i] = 0;
			ping->amp[i] = 0;
			ping->quality[i] = 0;
			ping->heave[i] = 0;
			ping->beamflag[i] = MB_FLAG_NULL;
			ping->beam_frequency[i] = 0;
			ping->beam_samples[i] = 0;
			ping->beam_center_sample[i] = 0;
			ping->beam_start_sample[i] = 0;
		}
		ping->pixel_size = 0.0;
		ping->pixels_ss = 0;
		for (int i = 0; i < MBSYS_SIMRAD_MAXRAWPIXELS; i++) {
			ping->ssraw[i] = 0;
			ping->ssp[i] = 0;
		}
	}

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       error:      %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:     %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
int mbsys_simrad_deall(int verbose, void *mbio_ptr, void **store_ptr, int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:    %d\n", verbose);
		fprintf(stderr, "dbg2       mbio_ptr:   %p\n", (void *)mbio_ptr);
		fprintf(stderr, "dbg2       store_ptr:  %p\n", (void *)*store_ptr);
	}

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)*store_ptr;

	int status = MB_SUCCESS;

	/* deallocate memory for survey data structure */
	if (store->ping != NULL)
		status = mb_freed(verbose, __FILE__, __LINE__, (void **)&(store->ping), error);

	/* deallocate memory for data structure */
	status &= mb_freed(verbose, __FILE__, __LINE__, (void **)store_ptr, error);

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       error:      %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:     %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
int mbsys_simrad_dimensions(int verbose, void *mbio_ptr, void *store_ptr, int *kind, int *nbath, int *namp, int *nss,
                            int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:    %d\n", verbose);
		fprintf(stderr, "dbg2       mb_ptr:     %p\n", (void *)mbio_ptr);
		fprintf(stderr, "dbg2       store_ptr:  %p\n", (void *)store_ptr);
	}

	/* get mbio descriptor */
	// struct mb_io_struct *mb_io_ptr = (struct mb_io_struct *)mbio_ptr;

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)store_ptr;

	/* get data kind */
	*kind = store->kind;

	/* extract data from structure */
	if (*kind == MB_DATA_DATA) {
		/* get beam and pixel numbers */
		struct mbsys_simrad_survey_struct *ping = (struct mbsys_simrad_survey_struct *)store->ping;
		*nbath = ping->beams_bath;
		*namp = ping->beams_bath;
		*nss = MBSYS_SIMRAD_MAXPIXELS;
	}
	else {
		/* get beam and pixel numbers */
		*nbath = 0;
		*namp = 0;
		*nss = 0;
	}

	int status = MB_SUCCESS;

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       kind:       %d\n", *kind);
		fprintf(stderr, "dbg2       nbath:      %d\n", *nbath);
		fprintf(stderr, "dbg2        namp:      %d\n", *namp);
		fprintf(stderr, "dbg2        nss:       %d\n", *nss);
		fprintf(stderr, "dbg2       error:      %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:     %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
int mbsys_simrad_extract(int verbose, void *mbio_ptr, void *store_ptr, int *kind, int time_i[7], double *time_d, double *navlon,
                         double *navlat, double *speed, double *heading, int *nbath, int *namp, int *nss, char *beamflag,
                         double *bath, double *amp, double *bathacrosstrack, double *bathalongtrack, double *ss,
                         double *ssacrosstrack, double *ssalongtrack, char *comment, int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:    %d\n", verbose);
		fprintf(stderr, "dbg2       mb_ptr:     %p\n", (void *)mbio_ptr);
		fprintf(stderr, "dbg2       store_ptr:  %p\n", (void *)store_ptr);
	}

	/* get mbio descriptor */
	struct mb_io_struct *mb_io_ptr = (struct mb_io_struct *)mbio_ptr;

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)store_ptr;

	/* get data kind */
	*kind = store->kind;

	int status = MB_SUCCESS;

	/* extract data from structure */
	if (*kind == MB_DATA_DATA) {
		/* get survey data structure */
		struct mbsys_simrad_survey_struct *ping = (struct mbsys_simrad_survey_struct *)store->ping;

		/* get time */
		mb_fix_y2k(verbose, store->year, &time_i[0]);
		time_i[1] = store->month;
		time_i[2] = store->day;
		time_i[3] = store->hour;
		time_i[4] = store->minute;
		time_i[5] = store->second;
		time_i[6] = 10000 * store->centisecond;
		mb_get_time(verbose, time_i, time_d);

		/* get navigation */
		*navlon = ping->longitude;
		*navlat = ping->latitude;

		/* get heading */
		if (store->sonar == MBSYS_SIMRAD_EM121)
			*heading = 0.01 * ping->heading;
		else
			*heading = 0.1 * ping->heading;

		/* get speed  */
		*speed = 3.6 * store->speed;

		/* set beamwidths in mb_io structure */
		if (store->sonar == MBSYS_SIMRAD_EM1000) {
			mb_io_ptr->beamwidth_ltrack = 3.3;
			mb_io_ptr->beamwidth_xtrack = 3.3;
		}
		else if (store->sonar == MBSYS_SIMRAD_EM12S || store->sonar == MBSYS_SIMRAD_EM12D) {
			mb_io_ptr->beamwidth_ltrack = 1.7;
			mb_io_ptr->beamwidth_xtrack = 3.5;
		}
		else if (store->sonar == MBSYS_SIMRAD_EM121) {
			if (ping->bath_mode == 3) {
				mb_io_ptr->beamwidth_ltrack = 4.0;
				mb_io_ptr->beamwidth_xtrack = 4.0;
			}
			else if (ping->bath_mode == 2) {
				mb_io_ptr->beamwidth_ltrack = 2.0;
				mb_io_ptr->beamwidth_xtrack = 2.0;
			}
			else {
				mb_io_ptr->beamwidth_ltrack = 1.0;
				mb_io_ptr->beamwidth_xtrack = 1.0;
			}
		}

		double depthscale;
		double dacrscale;
		double daloscale;
		// double ttscale;
		double reflscale;

		/* read distance and depth values into storage arrays */
		*nbath = ping->beams_bath;
		*namp = ping->beams_bath;
		if (store->sonar == MBSYS_SIMRAD_EM1000) {
			depthscale = 0.02;
			dacrscale = 0.1;
			daloscale = 0.1;
			// ttscale = 0.05;
			reflscale = 0.5;
		} else if (store->sonar == MBSYS_SIMRAD_EM12S && ping->bath_res == 1) {
			depthscale = 0.1;
			dacrscale = 0.2;
			daloscale = 0.2;
			// ttscale = 0.2;
			reflscale = 0.5;
		} else if (store->sonar == MBSYS_SIMRAD_EM12S && ping->bath_res == 2) {
			depthscale = 0.2;
			dacrscale = 0.5;
			daloscale = 0.5;
			// ttscale = 0.8;
			reflscale = 0.5;
		} else if (store->sonar == MBSYS_SIMRAD_EM12D && ping->bath_res == 1) {
			depthscale = 0.1;
			dacrscale = 0.2;
			daloscale = 0.2;
			// ttscale = 0.2;
			reflscale = 0.5;
		} else if (store->sonar == MBSYS_SIMRAD_EM12D && ping->bath_res == 2) {
			depthscale = 0.2;
			dacrscale = 0.5;
			daloscale = 0.5;
			// ttscale = 0.8;
			reflscale = 0.5;
		} else if (store->sonar == MBSYS_SIMRAD_EM121) {
			depthscale = 0.01 * ping->depth_res;
			dacrscale = 0.01 * ping->across_res;
			daloscale = 0.01 * ping->along_res;
			// ttscale = 0.1 * ping->range_res;
			reflscale = 0.5;
		} else {
			depthscale = 0.1;
			dacrscale = 0.2;
			daloscale = 0.2;
			// ttscale = 0.2;
			reflscale = 0.5;
		}

		// double ss_spacing;
		// if (ping->ss_mode == 1)
		//	ss_spacing = 0.6;
		// else if (ping->ss_mode == 2)
		//	ss_spacing = 2.4;
		// else if (ping->ss_mode == 3)
		//	ss_spacing = 0.3;
		// else if (ping->ss_mode == 4)
		//	ss_spacing = 0.3;
		// else
		//	ss_spacing = 0.15;

		for (int i = 0; i < *nbath; i++) {
			beamflag[i] = ping->beamflag[i];
			bath[i] = depthscale * ping->bath[i];
			bathacrosstrack[i] = dacrscale * ping->bath_acrosstrack[i];
			bathalongtrack[i] = daloscale * ping->bath_alongtrack[i];
		}
		for (int i = 0; i < *namp; i++) {
			amp[i] = reflscale * ping->amp[i];
		}
		if (ss != NULL) {
			*nss = MBSYS_SIMRAD_MAXPIXELS;
			const double pixel_size = 0.01 * ping->pixel_size;
			for (int i = 0; i < MBSYS_SIMRAD_MAXPIXELS; i++) {
				if (ping->ss[i] != 0) {
					ss[i] = 0.01 * ping->ss[i];
					ssacrosstrack[i] = pixel_size * (i - MBSYS_SIMRAD_MAXPIXELS / 2);
					ssalongtrack[i] = daloscale * ping->ssalongtrack[i];
				}
				else {
					ss[i] = MB_SIDESCAN_NULL;
					ssacrosstrack[i] = pixel_size * (i - MBSYS_SIMRAD_MAXPIXELS / 2);
					ssalongtrack[i] = 0.0;
				}
			}
		}
		else {
			*nss = 0;
		}

		if (verbose >= 5) {
			fprintf(stderr, "\ndbg4  Data extracted by MBIO function <%s>\n", __func__);
			fprintf(stderr, "dbg4  Extracted values:\n");
			fprintf(stderr, "dbg4       kind:       %d\n", *kind);
			fprintf(stderr, "dbg4       error:      %d\n", *error);
			fprintf(stderr, "dbg4       time_i[0]:  %d\n", time_i[0]);
			fprintf(stderr, "dbg4       time_i[1]:  %d\n", time_i[1]);
			fprintf(stderr, "dbg4       time_i[2]:  %d\n", time_i[2]);
			fprintf(stderr, "dbg4       time_i[3]:  %d\n", time_i[3]);
			fprintf(stderr, "dbg4       time_i[4]:  %d\n", time_i[4]);
			fprintf(stderr, "dbg4       time_i[5]:  %d\n", time_i[5]);
			fprintf(stderr, "dbg4       time_i[6]:  %d\n", time_i[6]);
			fprintf(stderr, "dbg4       time_d:     %f\n", *time_d);
			fprintf(stderr, "dbg4       longitude:  %f\n", *navlon);
			fprintf(stderr, "dbg4       latitude:   %f\n", *navlat);
			fprintf(stderr, "dbg4       speed:      %f\n", *speed);
			fprintf(stderr, "dbg4       heading:    %f\n", *heading);
			fprintf(stderr, "dbg4       nbath:      %d\n", *nbath);
			for (int i = 0; i < *nbath; i++)
				fprintf(stderr, "dbg4       beam:%d  flag:%3d  bath:%f  acrosstrack:%f  alongtrack:%f\n", i, beamflag[i], bath[i],
				        bathacrosstrack[i], bathalongtrack[i]);
			fprintf(stderr, "dbg4        namp:     %d\n", *namp);
			for (int i = 0; i < *namp; i++)
				fprintf(stderr, "dbg4        beam:%d   amp:%f  acrosstrack:%f  alongtrack:%f\n", i, amp[i], bathacrosstrack[i],
				        bathalongtrack[i]);
			for (int i = 0; i < *nss; i++)
				fprintf(stderr, "dbg4        pixel:%d   ss:%f  acrosstrack:%f  alongtrack:%f\n", i, ss[i], ssacrosstrack[i],
				        ssalongtrack[i]);
		}

		/* done translating values */
	}

	/* extract data from structure */
	else if (*kind == MB_DATA_NAV) {
		/* get survey data structure */
		// struct mbsys_simrad_survey_struct *ping = (struct mbsys_simrad_survey_struct *)store->ping;

		/* get time */
		mb_fix_y2k(verbose, store->pos_year, &time_i[0]);
		time_i[1] = store->pos_month;
		time_i[2] = store->pos_day;
		time_i[3] = store->pos_hour;
		time_i[4] = store->pos_minute;
		time_i[5] = store->pos_second;
		time_i[6] = 10000 * store->pos_centisecond;
		mb_get_time(verbose, time_i, time_d);
		*navlon = store->pos_longitude;
		*navlat = store->pos_latitude;

		/* get heading */
		*heading = store->line_heading;

		/* get speed  */
		*speed = 3.6 * store->speed;

		*nbath = 0;
		*namp = 0;
		*nss = 0;

		if (verbose >= 5) {
			fprintf(stderr, "\ndbg4  Data extracted by MBIO function <%s>\n", __func__);
			fprintf(stderr, "dbg4  Extracted values:\n");
			fprintf(stderr, "dbg4       kind:       %d\n", *kind);
			fprintf(stderr, "dbg4       error:      %d\n", *error);
			fprintf(stderr, "dbg4       time_i[0]:  %d\n", time_i[0]);
			fprintf(stderr, "dbg4       time_i[1]:  %d\n", time_i[1]);
			fprintf(stderr, "dbg4       time_i[2]:  %d\n", time_i[2]);
			fprintf(stderr, "dbg4       time_i[3]:  %d\n", time_i[3]);
			fprintf(stderr, "dbg4       time_i[4]:  %d\n", time_i[4]);
			fprintf(stderr, "dbg4       time_i[5]:  %d\n", time_i[5]);
			fprintf(stderr, "dbg4       time_i[6]:  %d\n", time_i[6]);
			fprintf(stderr, "dbg4       time_d:     %f\n", *time_d);
			fprintf(stderr, "dbg4       longitude:  %f\n", *navlon);
			fprintf(stderr, "dbg4       latitude:   %f\n", *navlat);
			fprintf(stderr, "dbg4       speed:      %f\n", *speed);
			fprintf(stderr, "dbg4       heading:    %f\n", *heading);
		}

		/* done translating values */
	}

	/* extract comment from structure */
	else if (*kind == MB_DATA_COMMENT) {
		/* copy comment */
    memset((void *)comment, 0, MB_COMMENT_MAXLINE);
    strncpy(comment, store->comment, MIN(MB_COMMENT_MAXLINE, MBSYS_SIMRAD_COMMENT_LENGTH) - 1);

		if (verbose >= 4) {
			fprintf(stderr, "\ndbg4  New ping read by MBIO function <%s>\n", __func__);
			fprintf(stderr, "dbg4  New ping values:\n");
			fprintf(stderr, "dbg4       error:      %d\n", *error);
			fprintf(stderr, "dbg4       comment:    %s\n", comment);
		}
	}

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       kind:       %d\n", *kind);
	}
	if (verbose >= 2 && *error <= MB_ERROR_NO_ERROR && *kind == MB_DATA_COMMENT) {
		fprintf(stderr, "dbg2       comment:     \ndbg2       %s\n", comment);
	}
	else if (verbose >= 2 && *error <= MB_ERROR_NO_ERROR && *kind != MB_DATA_COMMENT) {
		fprintf(stderr, "dbg2       time_i[0]:     %d\n", time_i[0]);
		fprintf(stderr, "dbg2       time_i[1]:     %d\n", time_i[1]);
		fprintf(stderr, "dbg2       time_i[2]:     %d\n", time_i[2]);
		fprintf(stderr, "dbg2       time_i[3]:     %d\n", time_i[3]);
		fprintf(stderr, "dbg2       time_i[4]:     %d\n", time_i[4]);
		fprintf(stderr, "dbg2       time_i[5]:     %d\n", time_i[5]);
		fprintf(stderr, "dbg2       time_i[6]:     %d\n", time_i[6]);
		fprintf(stderr, "dbg2       time_d:        %f\n", *time_d);
		fprintf(stderr, "dbg2       longitude:     %f\n", *navlon);
		fprintf(stderr, "dbg2       latitude:      %f\n", *navlat);
		fprintf(stderr, "dbg2       speed:         %f\n", *speed);
		fprintf(stderr, "dbg2       heading:       %f\n", *heading);
	}
	if (verbose >= 2 && *error <= MB_ERROR_NO_ERROR && *kind == MB_DATA_DATA) {
		fprintf(stderr, "dbg2       nbath:      %d\n", *nbath);
		for (int i = 0; i < *nbath; i++)
			fprintf(stderr, "dbg2       beam:%d  flag:%3d  bath:%f  acrosstrack:%f  alongtrack:%f\n", i, beamflag[i], bath[i],
			        bathacrosstrack[i], bathalongtrack[i]);
		fprintf(stderr, "dbg2        namp:     %d\n", *namp);
		for (int i = 0; i < *namp; i++)
			fprintf(stderr, "dbg2       beam:%d   amp:%f  acrosstrack:%f  alongtrack:%f\n", i, amp[i], bathacrosstrack[i],
			        bathalongtrack[i]);
		fprintf(stderr, "dbg2        nss:      %d\n", *nss);
		for (int i = 0; i < *nss; i++)
			fprintf(stderr, "dbg2        pixel:%d   ss:%f  acrosstrack:%f  alongtrack:%f\n", i, ss[i], ssacrosstrack[i],
			        ssalongtrack[i]);
	}
	if (verbose >= 2) {
		fprintf(stderr, "dbg2       error:      %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:     %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
int mbsys_simrad_insert(int verbose, void *mbio_ptr, void *store_ptr, int kind, int time_i[7], double time_d, double navlon,
                        double navlat, double speed, double heading, int nbath, int namp, int nss, char *beamflag, double *bath,
                        double *amp, double *bathacrosstrack, double *bathalongtrack, double *ss, double *ssacrosstrack,
                        double *ssalongtrack, char *comment, int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:    %d\n", verbose);
		fprintf(stderr, "dbg2       mbio_ptr:   %p\n", (void *)mbio_ptr);
		fprintf(stderr, "dbg2       store_ptr:  %p\n", (void *)store_ptr);
		fprintf(stderr, "dbg2       kind:       %d\n", kind);
	}
	if (verbose >= 2 && (kind == MB_DATA_DATA || kind == MB_DATA_NAV)) {
		fprintf(stderr, "dbg2       time_i[0]:  %d\n", time_i[0]);
		fprintf(stderr, "dbg2       time_i[1]:  %d\n", time_i[1]);
		fprintf(stderr, "dbg2       time_i[2]:  %d\n", time_i[2]);
		fprintf(stderr, "dbg2       time_i[3]:  %d\n", time_i[3]);
		fprintf(stderr, "dbg2       time_i[4]:  %d\n", time_i[4]);
		fprintf(stderr, "dbg2       time_i[5]:  %d\n", time_i[5]);
		fprintf(stderr, "dbg2       time_i[6]:  %d\n", time_i[6]);
		fprintf(stderr, "dbg2       time_d:     %f\n", time_d);
		fprintf(stderr, "dbg2       navlon:     %f\n", navlon);
		fprintf(stderr, "dbg2       navlat:     %f\n", navlat);
		fprintf(stderr, "dbg2       speed:      %f\n", speed);
		fprintf(stderr, "dbg2       heading:    %f\n", heading);
	}
	if (verbose >= 2 && kind == MB_DATA_DATA) {
		fprintf(stderr, "dbg2       nbath:      %d\n", nbath);
		if (verbose >= 3)
			for (int i = 0; i < nbath; i++)
				fprintf(stderr, "dbg3       beam:%d  flag:%3d  bath:%f  acrosstrack:%f  alongtrack:%f\n", i, beamflag[i], bath[i],
				        bathacrosstrack[i], bathalongtrack[i]);
		fprintf(stderr, "dbg2       namp:       %d\n", namp);
		if (verbose >= 3)
			for (int i = 0; i < namp; i++)
				fprintf(stderr, "dbg3        beam:%d   amp:%f  acrosstrack:%f  alongtrack:%f\n", i, amp[i], bathacrosstrack[i],
				        bathalongtrack[i]);
		fprintf(stderr, "dbg2        nss:       %d\n", nss);
		if (verbose >= 3)
			for (int i = 0; i < nss; i++)
				fprintf(stderr, "dbg3        beam:%d   ss:%f  acrosstrack:%f  alongtrack:%f\n", i, ss[i], ssacrosstrack[i],
				        ssalongtrack[i]);
	}
	if (verbose >= 2 && kind == MB_DATA_COMMENT) {
		fprintf(stderr, "dbg2       comment:     \ndbg2       %s\n", comment);
	}

	/* get mbio descriptor */
	// struct mb_io_struct *mb_io_ptr = (struct mb_io_struct *)mbio_ptr;

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)store_ptr;

	/* set data kind */
	store->kind = kind;

	int status = MB_SUCCESS;

	/* insert data in structure */
	if (store->kind == MB_DATA_DATA) {
		/* allocate secondary data structure for
		    survey data if needed */
		if (store->ping == NULL) {
			status = mbsys_simrad_survey_alloc(verbose, mbio_ptr, store_ptr, error);
		}

		/* get survey data structure */
		struct mbsys_simrad_survey_struct *ping = (struct mbsys_simrad_survey_struct *)store->ping;

		/* get time */
		mb_unfix_y2k(verbose, time_i[0], &store->year);
		store->month = time_i[1];
		store->day = time_i[2];
		store->hour = time_i[3];
		store->minute = time_i[4];
		store->second = time_i[5];
		store->centisecond = time_i[6] / 10000;

		/* get nav */
		ping->longitude = navlon;
		ping->latitude = navlat;

		/* get heading */
		if (store->sonar == MBSYS_SIMRAD_EM121)
			ping->heading = (int)(heading * 100);
		else
			ping->heading = (int)(heading * 10);

		/* get speed  */
		store->speed = speed / 3.6;

		/* insert distance and depth values into storage arrays */
		ping->beams_bath = nbath;
		if (store->sonar == MBSYS_SIMRAD_UNKNOWN) {
			if (nbath <= 60) {
				store->sonar = MBSYS_SIMRAD_EM1000;
				ping->bath_mode = 0;
			}
			else if (nbath <= 81) {
				store->sonar = MBSYS_SIMRAD_EM12S;
				ping->bath_mode = 0;
				ping->bath_res = 2;
			}
			else if (nbath <= 121) {
				store->sonar = MBSYS_SIMRAD_EM121;
				ping->bath_mode = 0;
				ping->bath_res = 2;
			}
			else {
				*error = MB_ERROR_DATA_NOT_INSERTED;
				status = MB_FAILURE;
			}
		}

		double depthscale;
		double dacrscale;
		double daloscale;
		// double ttscale;
		double reflscale;

		if (store->sonar == MBSYS_SIMRAD_EM1000) {
			depthscale = 0.02;
			dacrscale = 0.1;
			daloscale = 0.1;
			// ttscale = 0.05;
			reflscale = 0.5;
		} else if (store->sonar == MBSYS_SIMRAD_EM12S && ping->bath_res == 1) {
			depthscale = 0.1;
			dacrscale = 0.2;
			daloscale = 0.2;
			// ttscale = 0.2;
			reflscale = 0.5;
		} else if (store->sonar == MBSYS_SIMRAD_EM12S && ping->bath_res == 2) {
			depthscale = 0.2;
			dacrscale = 0.5;
			daloscale = 0.5;
			// ttscale = 0.8;
			reflscale = 0.5;
		} else if (store->sonar == MBSYS_SIMRAD_EM12D && ping->bath_res == 1) {
			depthscale = 0.1;
			dacrscale = 0.2;
			daloscale = 0.2;
			// ttscale = 0.2;
			reflscale = 0.5;
		} else if (store->sonar == MBSYS_SIMRAD_EM12D && ping->bath_res == 2) {
			depthscale = 0.2;
			dacrscale = 0.5;
			daloscale = 0.5;
			// ttscalettscale = 0.8;
			reflscale = 0.5;
		} else if (store->sonar == MBSYS_SIMRAD_EM121) {
			depthscale = 0.01 * ping->depth_res;
			dacrscale = 0.01 * ping->across_res;
			daloscale = 0.01 * ping->along_res;
			// ttscale = 0.1 * ping->range_res;
			reflscale = 0.5;
		} else {
			*error = MB_ERROR_DATA_NOT_INSERTED;
			status = MB_FAILURE;
		}

		if (status == MB_SUCCESS) {
			for (int i = 0; i < nbath; i++) {
				ping->bath[i] = bath[i] / depthscale;
				ping->bath_acrosstrack[i] = bathacrosstrack[i] / dacrscale;
				ping->bath_alongtrack[i] = bathalongtrack[i] / daloscale;
				ping->beamflag[i] = beamflag[i];
				if (beamflag[i] == MB_FLAG_NULL)
					ping->bath[i] = 0;
			}
			for (int i = 0; i < namp; i++) {
				ping->amp[i] = amp[i] / reflscale;
			}
		}
		if (status == MB_SUCCESS) {
			for (int i = 0; i < nss; i++) {
				if (ss[i] > MB_SIDESCAN_NULL) {
					ping->ss[i] = 100 * ss[i];
					ping->ssalongtrack[i] = ssalongtrack[i] / daloscale;
				}
				else {
					ping->ss[i] = 0;
					ping->ssalongtrack[i] = 0;
				}
			}
		}
	}

	/* insert nav in structure */
	else if (store->kind == MB_DATA_NAV) {
		/* get time */
		mb_unfix_y2k(verbose, time_i[0], &store->pos_year);
		store->pos_month = time_i[1];
		store->pos_day = time_i[2];
		store->pos_hour = time_i[3];
		store->pos_minute = time_i[4];
		store->pos_second = time_i[5];
		store->pos_centisecond = time_i[6] / 10000;

		/* get nav */
		store->pos_longitude = navlon;
		store->pos_latitude = navlat;

		/* get heading */
		store->line_heading = heading;

		/* get speed  */
		store->speed = speed / 3.6;
	}

	/* insert comment in structure */
	else if (store->kind == MB_DATA_COMMENT) {
    memset((void *)store->comment, 0, MBSYS_SIMRAD_COMMENT_LENGTH);
    strncpy(store->comment, comment, MIN(MBSYS_SIMRAD_COMMENT_LENGTH, MB_COMMENT_MAXLINE) - 1);
	}

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       error:      %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:  %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
int mbsys_simrad_beamangles(int verbose, void *store_ptr, bool *interleave,
														int *nbeams, double **angles_simrad, int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:       %d\n", verbose);
		fprintf(stderr, "dbg2       store_ptr:     %p\n", (void *)store_ptr);
		fprintf(stderr, "dbg2       interleave:    %p\n", (void *)interleave);
		fprintf(stderr, "dbg2       nbeams:        %p\n", (void *)nbeams);
		fprintf(stderr, "dbg2       angles_simrad: %p\n", (void **)angles_simrad);
	}

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)store_ptr;

	int status = MB_SUCCESS;

	/* extract data from structure */
	if (store->kind == MB_DATA_DATA) {

		/* get survey data structure */
		struct mbsys_simrad_survey_struct *ping = (struct mbsys_simrad_survey_struct *)store->ping;

		/* get nbeams */
		*nbeams = ping->beams_bath;

		/* get angles */
		*interleave = false;
		if (store->sonar == MBSYS_SIMRAD_EM1000) {
			if (ping->bath_mode == 1) {
				*angles_simrad = angles_EM1000_ISO_ANG_60_2_MS_48_FAIS;
				*interleave = false;
			}
			else if (ping->bath_mode == 2) {
				*angles_simrad = angles_EM1000_ISO_ANG_120_07_MS_48_FAIS;
				*interleave = true;
			}
			else if (ping->bath_mode == 3) {
				*angles_simrad = angles_EM1000_ISO_ANG_150_02_MS_60_FAIS;
				*interleave = true;
			}
			else if (ping->bath_mode == 4) {
				*angles_simrad = angles_EM1000_CHANNEL_02_MS_60_FAIS;
				*interleave = true;
			}
			else if (ping->bath_mode == 5) {
				*angles_simrad = angles_EM1000_150_02_MS_60_FAIS;
				*interleave = true;
			}
			else if (ping->bath_mode == 6) {
				*angles_simrad = angles_EM1000_140_02_MS_60_FAIS;
				*interleave = true;
			}
			else if (ping->bath_mode == 7) {
				*angles_simrad = angles_EM1000_128_02_MS_60_FAIS;
				*interleave = true;
			}
			else if (ping->bath_mode == 8) {
				*angles_simrad = angles_EM1000_120_07_MS_48_FAIS;
				*interleave = true;
			}
			else if (ping->bath_mode == 9) {
				*angles_simrad = angles_EM1000_104_07_MS_48_FAIS;
				*interleave = true;
			}
			else if (ping->bath_mode == 10) {
				*angles_simrad = angles_EM1000_88_07_MS_48_FAIS;
				*interleave = true;
			}
			else if (ping->bath_mode == 11) {
				*angles_simrad = angles_EM1000_70_2_MS_48_FAIS;
				*interleave = false;
			}
			else if (ping->bath_mode == 12) {
				*angles_simrad = angles_EM1000_BERGE_02_MS_60_FAIS;
				*interleave = true;
			}
			else if (ping->bath_mode == 13) {
				*angles_simrad = angles_EM1000_BERGE_02_MS_60_FAIS;
				*interleave = true;
			}
		}
		else if (store->sonar == MBSYS_SIMRAD_EM12S) {
			if (ping->bath_mode == 1)
				*angles_simrad = angles_EM12S_ISO_ANG_SHALLOW;
			else if (ping->bath_mode == 2)
				*angles_simrad = angles_EM12S_ISO_ANG_DEEP;
			else if (ping->bath_mode == 3)
				*angles_simrad = angles_EM12S_SHALLOW;
			else if (ping->bath_mode == 4)
				*angles_simrad = angles_EM12S_120;
			else if (ping->bath_mode == 5)
				*angles_simrad = angles_EM12S_105;
			else if (ping->bath_mode == 6)
				*angles_simrad = angles_EM12S_90;
		}
		else if (store->sonar == MBSYS_SIMRAD_EM12D && ping->swath_id == EM_SWATH_PORT) {
			if (ping->bath_mode == 1)
				*angles_simrad = angles_EM12DP_ISO_ANG_SHALLOW;
			else if (ping->bath_mode == 2)
				*angles_simrad = angles_EM12DP_ISO_ANG_DEEP;
			else if (ping->bath_mode == 3)
				*angles_simrad = angles_EM12DP_SHALLOW;
			else if (ping->bath_mode == 4)
				*angles_simrad = angles_EM12DP_150;
			else if (ping->bath_mode == 5)
				*angles_simrad = angles_EM12DP_140;
			else if (ping->bath_mode == 6)
				*angles_simrad = angles_EM12DP_128;
			else if (ping->bath_mode == 7)
				*angles_simrad = angles_EM12DP_114;
			else if (ping->bath_mode == 8)
				*angles_simrad = angles_EM12DP_98;
		}
		else if (store->sonar == MBSYS_SIMRAD_EM12D && ping->swath_id == EM_SWATH_STARBOARD) {
			if (ping->bath_mode == 1)
				*angles_simrad = angles_EM12DS_ISO_ANG_SHALLOW;
			else if (ping->bath_mode == 2)
				*angles_simrad = angles_EM12DS_ISO_ANG_DEEP;
			else if (ping->bath_mode == 3)
				*angles_simrad = angles_EM12DS_SHALLOW;
			else if (ping->bath_mode == 4)
				*angles_simrad = angles_EM12DS_150;
			else if (ping->bath_mode == 5)
				*angles_simrad = angles_EM12DS_140;
			else if (ping->bath_mode == 6)
				*angles_simrad = angles_EM12DS_128;
			else if (ping->bath_mode == 7)
				*angles_simrad = angles_EM12DS_114;
			else if (ping->bath_mode == 8)
				*angles_simrad = angles_EM12DS_98;
		}
		else if (store->sonar == MBSYS_SIMRAD_EM121) {
			*angles_simrad = angles_EM121_GUESS;
		}

		/* set status */
		*error = MB_ERROR_NO_ERROR;
		status = MB_SUCCESS;

		/* done translating values */
	}

	/* deal with comment */
	else if (store->kind == MB_DATA_COMMENT) {
		/* set status */
		*error = MB_ERROR_COMMENT;
		status = MB_FAILURE;
		*interleave = false;
		*nbeams = 0;
	}

	/* deal with other record type */
	else {
		/* set status */
		*error = MB_ERROR_OTHER;
		status = MB_FAILURE;
		*interleave = false;
		*nbeams = 0;
	}

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
	}
	if (verbose >= 2 && *error == MB_ERROR_NO_ERROR) {
		fprintf(stderr, "dbg2       interleave: %d\n", *interleave);
		fprintf(stderr, "dbg2       nbeams:     %d\n", *nbeams);
		for (int i = 0; i < *nbeams; i++) {
			fprintf(stderr, "dbg2       beam %d: angles_simrad:%f\n",
			        i, (*angles_simrad)[i]);
		}
	}
	if (verbose >= 2) {
		fprintf(stderr, "dbg2       error:      %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:     %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
int mbsys_simrad_ttimes(int verbose, void *mbio_ptr, void *store_ptr, int *kind, int *nbeams, double *ttimes, double *angles,
                        double *angles_forward, double *angles_null, double *heave, double *alongtrack_offset, double *draft,
                        double *ssv, int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:    %d\n", verbose);
		fprintf(stderr, "dbg2       mb_ptr:     %p\n", (void *)mbio_ptr);
		fprintf(stderr, "dbg2       store_ptr:  %p\n", (void *)store_ptr);
		fprintf(stderr, "dbg2       ttimes:     %p\n", (void *)ttimes);
		fprintf(stderr, "dbg2       angles_xtrk:%p\n", (void *)angles);
		fprintf(stderr, "dbg2       angles_ltrk:%p\n", (void *)angles_forward);
		fprintf(stderr, "dbg2       angles_null:%p\n", (void *)angles_null);
		fprintf(stderr, "dbg2       heave:      %p\n", (void *)heave);
		fprintf(stderr, "dbg2       ltrk_off:   %p\n", (void *)alongtrack_offset);
	}

	/* get mbio descriptor */
	// struct mb_io_struct *mb_io_ptr = (struct mb_io_struct *)mbio_ptr;

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)store_ptr;

	/* get data kind */
	*kind = store->kind;

	int status = MB_SUCCESS;

	/* extract data from structure */
	if (*kind == MB_DATA_DATA) {
		/* get survey data structure */
		struct mbsys_simrad_survey_struct *ping = (struct mbsys_simrad_survey_struct *)store->ping;

		/* get nbeams */
		*nbeams = ping->beams_bath;

		/* get depth offset (heave + heave offset) */
		const double heave_use = 0.01 * ping->ping_heave;
		*ssv = 0.1 * ping->sound_vel;
		if (store->sonar == MBSYS_SIMRAD_EM12S)
			*draft = store->em12_td;
		else if (store->sonar == MBSYS_SIMRAD_EM12D)
			*draft = store->em12_td;
		else if (store->sonar == MBSYS_SIMRAD_EM100)
			*draft = store->em100_td;
		else if (store->sonar == MBSYS_SIMRAD_EM1000)
			*draft = store->em1000_td;

		/* get travel times, angles */
		bool interleave = false;
		double *angles_simrad;
		if (store->sonar == MBSYS_SIMRAD_EM1000) {
			if (ping->bath_mode == 1) {
				angles_simrad = angles_EM1000_ISO_ANG_60_2_MS_48_FAIS;
				interleave = false;
			}
			else if (ping->bath_mode == 2) {
				angles_simrad = angles_EM1000_ISO_ANG_120_07_MS_48_FAIS;
				interleave = true;
			}
			else if (ping->bath_mode == 3) {
				angles_simrad = angles_EM1000_ISO_ANG_150_02_MS_60_FAIS;
				interleave = true;
			}
			else if (ping->bath_mode == 4) {
				angles_simrad = angles_EM1000_CHANNEL_02_MS_60_FAIS;
				interleave = true;
			}
			else if (ping->bath_mode == 5) {
				angles_simrad = angles_EM1000_150_02_MS_60_FAIS;
				interleave = true;
			}
			else if (ping->bath_mode == 6) {
				angles_simrad = angles_EM1000_140_02_MS_60_FAIS;
				interleave = true;
			}
			else if (ping->bath_mode == 7) {
				angles_simrad = angles_EM1000_128_02_MS_60_FAIS;
				interleave = true;
			}
			else if (ping->bath_mode == 8) {
				angles_simrad = angles_EM1000_120_07_MS_48_FAIS;
				interleave = true;
			}
			else if (ping->bath_mode == 9) {
				angles_simrad = angles_EM1000_104_07_MS_48_FAIS;
				interleave = true;
			}
			else if (ping->bath_mode == 10) {
				angles_simrad = angles_EM1000_88_07_MS_48_FAIS;
				interleave = true;
			}
			else if (ping->bath_mode == 11) {
				angles_simrad = angles_EM1000_70_2_MS_48_FAIS;
				interleave = false;
			}
			else if (ping->bath_mode == 12) {
				angles_simrad = angles_EM1000_BERGE_02_MS_60_FAIS;
				interleave = true;
			}
			else if (ping->bath_mode == 13) {
				angles_simrad = angles_EM1000_BERGE_02_MS_60_FAIS;
				interleave = true;
			}
		}
		else if (store->sonar == MBSYS_SIMRAD_EM12S) {
			if (ping->bath_mode == 1)
				angles_simrad = angles_EM12S_ISO_ANG_SHALLOW;
			else if (ping->bath_mode == 2)
				angles_simrad = angles_EM12S_ISO_ANG_DEEP;
			else if (ping->bath_mode == 3)
				angles_simrad = angles_EM12S_SHALLOW;
			else if (ping->bath_mode == 4)
				angles_simrad = angles_EM12S_120;
			else if (ping->bath_mode == 5)
				angles_simrad = angles_EM12S_105;
			else if (ping->bath_mode == 6)
				angles_simrad = angles_EM12S_90;
		}
		else if (store->sonar == MBSYS_SIMRAD_EM12D && ping->swath_id == EM_SWATH_PORT) {
			if (ping->bath_mode == 1)
				angles_simrad = angles_EM12DP_ISO_ANG_SHALLOW;
			else if (ping->bath_mode == 2)
				angles_simrad = angles_EM12DP_ISO_ANG_DEEP;
			else if (ping->bath_mode == 3)
				angles_simrad = angles_EM12DP_SHALLOW;
			else if (ping->bath_mode == 4)
				angles_simrad = angles_EM12DP_150;
			else if (ping->bath_mode == 5)
				angles_simrad = angles_EM12DP_140;
			else if (ping->bath_mode == 6)
				angles_simrad = angles_EM12DP_128;
			else if (ping->bath_mode == 7)
				angles_simrad = angles_EM12DP_114;
			else if (ping->bath_mode == 8)
				angles_simrad = angles_EM12DP_98;
		}
		else if (store->sonar == MBSYS_SIMRAD_EM12D && ping->swath_id == EM_SWATH_STARBOARD) {
			if (ping->bath_mode == 1)
				angles_simrad = angles_EM12DS_ISO_ANG_SHALLOW;
			else if (ping->bath_mode == 2)
				angles_simrad = angles_EM12DS_ISO_ANG_DEEP;
			else if (ping->bath_mode == 3)
				angles_simrad = angles_EM12DS_SHALLOW;
			else if (ping->bath_mode == 4)
				angles_simrad = angles_EM12DS_150;
			else if (ping->bath_mode == 5)
				angles_simrad = angles_EM12DS_140;
			else if (ping->bath_mode == 6)
				angles_simrad = angles_EM12DS_128;
			else if (ping->bath_mode == 7)
				angles_simrad = angles_EM12DS_114;
			else if (ping->bath_mode == 8)
				angles_simrad = angles_EM12DS_98;
		}
		else if (store->sonar == MBSYS_SIMRAD_EM121) {
			angles_simrad = angles_EM121_GUESS;
		}

		double ttscale;
		if (store->sonar == MBSYS_SIMRAD_EM1000) {
			ttscale = 0.00005;
		} else if ((store->sonar == MBSYS_SIMRAD_EM12S || store->sonar == MBSYS_SIMRAD_EM12D) && ping->bath_res == 1) {
			ttscale = 0.0002;
		} else if ((store->sonar == MBSYS_SIMRAD_EM12S || store->sonar == MBSYS_SIMRAD_EM12D) && ping->bath_res == 2) {
			ttscale = 0.0008;
		} else if (store->sonar == MBSYS_SIMRAD_EM121) {
			ttscale = 0.0001 * ping->range_res;
		} else {
			ttscale = 0.0002;
		}

		/* if interleaved get center beam */
		int istep = 0;
		if (interleave) {
			if (ping->bath_mode == 12 && abs(ping->bath_acrosstrack[28]) < abs(ping->bath_acrosstrack[29]))
				istep = 1;
			else if (ping->bath_mode == 13 && abs(ping->bath_acrosstrack[31]) < abs(ping->bath_acrosstrack[30]))
				istep = 1;
			else if (abs(ping->bath_acrosstrack[*nbeams / 2 - 1]) < abs(ping->bath_acrosstrack[*nbeams / 2]))
				istep = 1;
			else
				istep = 0;
		}

		/* get travel times and angles */
		for (int i = 0; i < *nbeams; i++) {
			ttimes[i] = ttscale * ping->tt[i];
			const double alpha = 0.01 * ping->pitch;
			double beta;
			if (store->sonar == MBSYS_SIMRAD_EM1000 && ping->bath_mode == 13) {
				beta = 90.0 - angles_simrad[*nbeams - 1 - (2 * i + istep)];
			} else if (store->sonar == MBSYS_SIMRAD_EM1000 && interleave) {
				beta = 90.0 + angles_simrad[2 * i + istep];
			// } else if (store->sonar == MBSYS_SIMRAD_EM1000) {
			//	beta = 90.0 + angles_simrad[i];
			} else {
				beta = 90.0 + angles_simrad[i];
			}

			mb_rollpitch_to_takeoff(verbose, alpha, beta, &angles[i], &angles_forward[i], error);
			if (store->sonar == MBSYS_SIMRAD_EM1000)
				angles_null[i] = angles[i];
			else if (store->sonar == MBSYS_SIMRAD_EM1000)
				angles_null[i] = angles[i];
			else if (store->sonar == MBSYS_SIMRAD_EM12S)
				angles_null[i] = 0.0;
			else if (store->sonar == MBSYS_SIMRAD_EM12D)
				angles_null[i] = 0.0; /* wrong for sure */
			heave[i] = heave_use;
			alongtrack_offset[i] = 0.0;
		}

		/* reset null angles for EM1000 outer beams */
		if (store->sonar == MBSYS_SIMRAD_EM1000 && *nbeams == 60) {
			for (int i = 0; i < 6; i++)
				angles_null[i] = angles_null[6];
			for (int i = 55; i <= 60; i++)
				angles_null[i] = angles_null[54];
		}

		/* set status */
		*error = MB_ERROR_NO_ERROR;
		status = MB_SUCCESS;

		/* done translating values */
	}

	/* deal with comment */
	else if (*kind == MB_DATA_COMMENT) {
		/* set status */
		*error = MB_ERROR_COMMENT;
		status = MB_FAILURE;
	}

	/* deal with other record type */
	else {
		/* set status */
		*error = MB_ERROR_OTHER;
		status = MB_FAILURE;
	}

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       kind:       %d\n", *kind);
	}
	if (verbose >= 2 && *error == MB_ERROR_NO_ERROR) {
		fprintf(stderr, "dbg2       draft:      %f\n", *draft);
		fprintf(stderr, "dbg2       ssv:        %f\n", *ssv);
		fprintf(stderr, "dbg2       nbeams:     %d\n", *nbeams);
		for (int i = 0; i < *nbeams; i++)
			fprintf(stderr, "dbg2       beam %d: tt:%f  angle_xtrk:%f  angle_ltrk:%f  angle_null:%f  depth_off:%f  ltrk_off:%f\n",
			        i, ttimes[i], angles[i], angles_forward[i], angles_null[i], heave[i], alongtrack_offset[i]);
	}
	if (verbose >= 2) {
		fprintf(stderr, "dbg2       error:      %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:     %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
int mbsys_simrad_detects(int verbose, void *mbio_ptr, void *store_ptr, int *kind, int *nbeams, int *detects, int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:    %d\n", verbose);
		fprintf(stderr, "dbg2       mb_ptr:     %p\n", (void *)mbio_ptr);
		fprintf(stderr, "dbg2       store_ptr:  %p\n", (void *)store_ptr);
		fprintf(stderr, "dbg2       detects:    %p\n", (void *)detects);
	}

	/* get mbio descriptor */
	// struct mb_io_struct *mb_io_ptr = (struct mb_io_struct *)mbio_ptr;

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)store_ptr;

	/* get data kind */
	*kind = store->kind;

	int status = MB_SUCCESS;

	/* extract data from structure */
	if (*kind == MB_DATA_DATA) {
		/* get survey data structure */
		struct mbsys_simrad_survey_struct *ping = (struct mbsys_simrad_survey_struct *)store->ping;

		*nbeams = ping->beams_bath;
		for (int i = 0; i < ping->beams_bath; i++) {
			if (ping->bath[i] == 0)
				detects[i] = MB_DETECT_UNKNOWN;
			else if (ping->quality[i] & 128)
				detects[i] = MB_DETECT_PHASE;
			else
				detects[i] = MB_DETECT_AMPLITUDE;
		}

		/* set status */
		*error = MB_ERROR_NO_ERROR;
		status = MB_SUCCESS;

		/* done translating values */
	}

	/* deal with comment */
	else if (*kind == MB_DATA_COMMENT) {
		/* set status */
		*error = MB_ERROR_COMMENT;
		status = MB_FAILURE;
	}

	/* deal with other record type */
	else {
		/* set status */
		*error = MB_ERROR_OTHER;
		status = MB_FAILURE;
	}

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       kind:       %d\n", *kind);
	}
	if (verbose >= 2 && *error == MB_ERROR_NO_ERROR) {
		fprintf(stderr, "dbg2       nbeams:     %d\n", *nbeams);
		for (int i = 0; i < *nbeams; i++)
			fprintf(stderr, "dbg2       beam %d: detects:%d\n", i, detects[i]);
	}
	if (verbose >= 2) {
		fprintf(stderr, "dbg2       error:      %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:     %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
int mbsys_simrad_pulses(int verbose, void *mbio_ptr, void *store_ptr, int *kind, int *nbeams, int *pulses, int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:    %d\n", verbose);
		fprintf(stderr, "dbg2       mb_ptr:     %p\n", (void *)mbio_ptr);
		fprintf(stderr, "dbg2       store_ptr:  %p\n", (void *)store_ptr);
		fprintf(stderr, "dbg2       pulses:     %p\n", (void *)pulses);
	}

	/* get mbio descriptor */
	// struct mb_io_struct *mb_io_ptr = (struct mb_io_struct *)mbio_ptr;

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)store_ptr;

	/* get data kind */
	*kind = store->kind;

	int status = MB_SUCCESS;

	/* extract data from structure */
	if (*kind == MB_DATA_DATA) {
		/* get survey data structure */
		struct mbsys_simrad_survey_struct *ping = (struct mbsys_simrad_survey_struct *)store->ping;

		*nbeams = ping->beams_bath;
		for (int i = 0; i < ping->beams_bath; i++) {
			pulses[i] = MB_PULSE_CW;
		}

		/* set status */
		*error = MB_ERROR_NO_ERROR;
		status = MB_SUCCESS;

		/* done translating values */
	}

	/* deal with comment */
	else if (*kind == MB_DATA_COMMENT) {
		/* set status */
		*error = MB_ERROR_COMMENT;
		status = MB_FAILURE;
	}

	/* deal with other record type */
	else {
		/* set status */
		*error = MB_ERROR_OTHER;
		status = MB_FAILURE;
	}

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       kind:       %d\n", *kind);
	}
	if (verbose >= 2 && *error == MB_ERROR_NO_ERROR) {
		fprintf(stderr, "dbg2       nbeams:     %d\n", *nbeams);
		for (int i = 0; i < *nbeams; i++)
			fprintf(stderr, "dbg2       beam %d: pulses:%d\n", i, pulses[i]);
	}
	if (verbose >= 2) {
		fprintf(stderr, "dbg2       error:      %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:     %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
int mbsys_simrad_gains(int verbose, void *mbio_ptr, void *store_ptr, int *kind, double *transmit_gain, double *pulse_length,
                       double *receive_gain, int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:    %d\n", verbose);
		fprintf(stderr, "dbg2       mb_ptr:     %p\n", (void *)mbio_ptr);
		fprintf(stderr, "dbg2       store_ptr:  %p\n", (void *)store_ptr);
	}

	/* get mbio descriptor */
	// struct mb_io_struct *mb_io_ptr = (struct mb_io_struct *)mbio_ptr;

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)store_ptr;

	/* get data kind */
	*kind = store->kind;

	int status = MB_SUCCESS;

	/* extract data from structure */
	if (*kind == MB_DATA_DATA) {
		/* get survey data structure */
		struct mbsys_simrad_survey_struct *ping = (struct mbsys_simrad_survey_struct *)store->ping;

		/* get transmit_gain (dB) */
		*transmit_gain = (double)ping->power_level;

		/* get pulse_length (sec) */
		*pulse_length = 0.001 * ((double)ping->pulse_length);

		/* get receive_gain (dB) */
		*receive_gain = (double)0.0;

		/* set status */
		*error = MB_ERROR_NO_ERROR;
		status = MB_SUCCESS;

		/* done translating values */
	}

	/* deal with comment */
	else if (*kind == MB_DATA_COMMENT) {
		/* set status */
		*error = MB_ERROR_COMMENT;
		status = MB_FAILURE;
	}

	/* deal with other record type */
	else {
		/* set status */
		*error = MB_ERROR_OTHER;
		status = MB_FAILURE;
	}

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       kind:       %d\n", *kind);
	}
	if (verbose >= 2 && *error == MB_ERROR_NO_ERROR) {
		fprintf(stderr, "dbg2       transmit_gain: %f\n", *transmit_gain);
		fprintf(stderr, "dbg2       pulse_length:  %f\n", *pulse_length);
		fprintf(stderr, "dbg2       receive_gain:  %f\n", *receive_gain);
	}
	if (verbose >= 2) {
		fprintf(stderr, "dbg2       error:      %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:     %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
int mbsys_simrad_extract_altitude(int verbose, void *mbio_ptr, void *store_ptr, int *kind, double *transducer_depth,
                                  double *altitude, int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:    %d\n", verbose);
		fprintf(stderr, "dbg2       mb_ptr:     %p\n", (void *)mbio_ptr);
		fprintf(stderr, "dbg2       store_ptr:  %p\n", (void *)store_ptr);
	}

	/* get mbio descriptor */
	// struct mb_io_struct *mb_io_ptr = (struct mb_io_struct *)mbio_ptr;

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)store_ptr;

	/* get data kind */
	*kind = store->kind;

	int status = MB_SUCCESS;

	/* extract data from structure */
	if (*kind == MB_DATA_DATA) {
		/* get survey data structure */
		struct mbsys_simrad_survey_struct *ping = (struct mbsys_simrad_survey_struct *)store->ping;

		/* get transducer depth and altitude */
		if (store->sonar == MBSYS_SIMRAD_EM12S)
			*transducer_depth = 0.01 * ping->ping_heave + store->em12_td;
		else if (store->sonar == MBSYS_SIMRAD_EM12D)
			*transducer_depth = 0.01 * ping->ping_heave + store->em12_td;
		else if (store->sonar == MBSYS_SIMRAD_EM100)
			*transducer_depth = 0.01 * ping->ping_heave + store->em100_td;
		else if (store->sonar == MBSYS_SIMRAD_EM1000)
			*transducer_depth = 0.01 * ping->ping_heave + store->em1000_td;
		else if (store->sonar == MBSYS_SIMRAD_EM121)
			*transducer_depth = 0.01 * ping->ping_heave + store->em12_td;
		else
			*transducer_depth = 0.0;

		double depthscale;
		double dacrscale;
		double bath_best;
		double xtrack_min;

		if (store->sonar == MBSYS_SIMRAD_EM1000) {
			depthscale = 0.02;
			dacrscale = 0.1;
		}
		else if (store->sonar == MBSYS_SIMRAD_EM12S && ping->bath_res == 1) {
			depthscale = 0.1;
			dacrscale = 0.2;
		}
		else if (store->sonar == MBSYS_SIMRAD_EM12S && ping->bath_res == 2) {
			depthscale = 0.2;
			dacrscale = 0.5;
		}
		else if (store->sonar == MBSYS_SIMRAD_EM12D && ping->bath_res == 1) {
			depthscale = 0.1;
			dacrscale = 0.2;
		}
		else if (store->sonar == MBSYS_SIMRAD_EM12D && ping->bath_res == 2) {
			depthscale = 0.2;
			dacrscale = 0.5;
		}
		else if (store->sonar == MBSYS_SIMRAD_EM121) {
			depthscale = 0.01 * ping->depth_res;
			dacrscale = 0.01 * ping->across_res;
		}
		else {
			depthscale = 0.1;
			dacrscale = 0.1;
		}
		bath_best = 0.0;
		if (ping->bath[ping->beams_bath / 2] > 0)
			bath_best = depthscale * ping->bath[ping->beams_bath / 2];
		else {
			xtrack_min = 99999999.9;
			for (int i = 0; i < ping->beams_bath; i++) {
				if (ping->bath[i] > 0.0 && fabs(dacrscale * ping->bath_acrosstrack[i]) < xtrack_min) {
					xtrack_min = fabs(dacrscale * ping->bath_acrosstrack[i]);
					bath_best = depthscale * ping->bath[i];
				}
			}
		}
		if (bath_best <= 0.0) {
			xtrack_min = 99999999.9;
			for (int i = 0; i < ping->beams_bath; i++) {
				if (ping->bath[i] < 0.0 && fabs(dacrscale * ping->bath_acrosstrack[i]) < xtrack_min) {
					xtrack_min = fabs(dacrscale * ping->bath_acrosstrack[i]);
					bath_best = -depthscale * ping->bath[i];
				}
			}
		}
		*altitude = bath_best - *transducer_depth;

		/* set status */
		*error = MB_ERROR_NO_ERROR;
		status = MB_SUCCESS;

		/* done translating values */
	}

	/* deal with comment */
	else if (*kind == MB_DATA_COMMENT) {
		/* set status */
		*error = MB_ERROR_COMMENT;
		status = MB_FAILURE;
	}

	/* deal with other record type */
	else {
		/* set status */
		*error = MB_ERROR_OTHER;
		status = MB_FAILURE;
	}

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       kind:              %d\n", *kind);
		fprintf(stderr, "dbg2       transducer_depth:  %f\n", *transducer_depth);
		fprintf(stderr, "dbg2       altitude:          %f\n", *altitude);
		fprintf(stderr, "dbg2       error:             %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:            %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
int mbsys_simrad_extract_nav(int verbose, void *mbio_ptr, void *store_ptr, int *kind, int time_i[7], double *time_d,
                             double *navlon, double *navlat, double *speed, double *heading, double *draft, double *roll,
                             double *pitch, double *heave, int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:    %d\n", verbose);
		fprintf(stderr, "dbg2       mb_ptr:     %p\n", (void *)mbio_ptr);
		fprintf(stderr, "dbg2       store_ptr:  %p\n", (void *)store_ptr);
	}

	/* get mbio descriptor */
	// struct mb_io_struct *mb_io_ptr = (struct mb_io_struct *)mbio_ptr;

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)store_ptr;

	/* get data kind */
	*kind = store->kind;

	int status = MB_SUCCESS;

	/* extract data from structure */
	if (*kind == MB_DATA_DATA) {
		/* get survey data structure */
		struct mbsys_simrad_survey_struct *ping = (struct mbsys_simrad_survey_struct *)store->ping;

		/* get time */
		mb_fix_y2k(verbose, store->year, &time_i[0]);
		time_i[1] = store->month;
		time_i[2] = store->day;
		time_i[3] = store->hour;
		time_i[4] = store->minute;
		time_i[5] = store->second;
		time_i[6] = 10000 * store->centisecond;
		mb_get_time(verbose, time_i, time_d);

		/* get navigation */
		*navlon = ping->longitude;
		*navlat = ping->latitude;

		/* get heading */
		if (store->sonar == MBSYS_SIMRAD_EM121)
			*heading = 0.01 * ping->heading;
		else
			*heading = 0.1 * ping->heading;

		/* get speed  */
		*speed = 3.6 * store->speed;

		/* get draft  */
		if (store->sonar == MBSYS_SIMRAD_EM12S)
			*draft = store->em12_td;
		else if (store->sonar == MBSYS_SIMRAD_EM12D)
			*draft = store->em12_td;
		else if (store->sonar == MBSYS_SIMRAD_EM100)
			*draft = store->em100_td;
		else if (store->sonar == MBSYS_SIMRAD_EM1000)
			*draft = store->em1000_td;

		/* get roll pitch and heave */
		*roll = 0.01 * ping->roll;
		*pitch = 0.01 * ping->pitch;
		*heave = 0.01 * ping->ping_heave;

		if (verbose >= 5) {
			fprintf(stderr, "\ndbg4  Data extracted by MBIO function <%s>\n", __func__);
			fprintf(stderr, "dbg4  Extracted values:\n");
			fprintf(stderr, "dbg4       kind:       %d\n", *kind);
			fprintf(stderr, "dbg4       error:      %d\n", *error);
			fprintf(stderr, "dbg4       time_i[0]:  %d\n", time_i[0]);
			fprintf(stderr, "dbg4       time_i[1]:  %d\n", time_i[1]);
			fprintf(stderr, "dbg4       time_i[2]:  %d\n", time_i[2]);
			fprintf(stderr, "dbg4       time_i[3]:  %d\n", time_i[3]);
			fprintf(stderr, "dbg4       time_i[4]:  %d\n", time_i[4]);
			fprintf(stderr, "dbg4       time_i[5]:  %d\n", time_i[5]);
			fprintf(stderr, "dbg4       time_i[6]:  %d\n", time_i[6]);
			fprintf(stderr, "dbg4       time_d:     %f\n", *time_d);
			fprintf(stderr, "dbg4       longitude:  %f\n", *navlon);
			fprintf(stderr, "dbg4       latitude:   %f\n", *navlat);
			fprintf(stderr, "dbg4       speed:      %f\n", *speed);
			fprintf(stderr, "dbg4       heading:    %f\n", *heading);
			fprintf(stderr, "dbg4       draft:      %f\n", *draft);
			fprintf(stderr, "dbg4       roll:       %f\n", *roll);
			fprintf(stderr, "dbg4       pitch:      %f\n", *pitch);
			fprintf(stderr, "dbg4       heave:      %f\n", *heave);
		}

		/* done translating values */
	}

	/* extract data from structure */
	else if (*kind == MB_DATA_NAV) {
		/* get time */
		mb_fix_y2k(verbose, store->pos_year, &time_i[0]);
		time_i[1] = store->pos_month;
		time_i[2] = store->pos_day;
		time_i[3] = store->pos_hour;
		time_i[4] = store->pos_minute;
		time_i[5] = store->pos_second;
		time_i[6] = 10000 * store->pos_centisecond;
		mb_get_time(verbose, time_i, time_d);
		*navlon = store->pos_longitude;
		*navlat = store->pos_latitude;

		/* get heading */
		*heading = store->line_heading;

		/* get speed  */
		*speed = 3.6 * store->speed;

		/* get draft  */
		if (store->sonar == MBSYS_SIMRAD_EM12S)
			*draft = store->em12_td;
		else if (store->sonar == MBSYS_SIMRAD_EM12D)
			*draft = store->em12_td;
		else if (store->sonar == MBSYS_SIMRAD_EM100)
			*draft = store->em100_td;
		else if (store->sonar == MBSYS_SIMRAD_EM1000)
			*draft = store->em1000_td;

		/* get roll pitch and heave */
		*roll = 0.0;
		*pitch = 0.0;
		*heave = 0.0;

		if (verbose >= 5) {
			fprintf(stderr, "\ndbg4  Data extracted by MBIO function <%s>\n", __func__);
			fprintf(stderr, "dbg4  Extracted values:\n");
			fprintf(stderr, "dbg4       kind:       %d\n", *kind);
			fprintf(stderr, "dbg4       error:      %d\n", *error);
			fprintf(stderr, "dbg4       time_i[0]:  %d\n", time_i[0]);
			fprintf(stderr, "dbg4       time_i[1]:  %d\n", time_i[1]);
			fprintf(stderr, "dbg4       time_i[2]:  %d\n", time_i[2]);
			fprintf(stderr, "dbg4       time_i[3]:  %d\n", time_i[3]);
			fprintf(stderr, "dbg4       time_i[4]:  %d\n", time_i[4]);
			fprintf(stderr, "dbg4       time_i[5]:  %d\n", time_i[5]);
			fprintf(stderr, "dbg4       time_i[6]:  %d\n", time_i[6]);
			fprintf(stderr, "dbg4       time_d:     %f\n", *time_d);
			fprintf(stderr, "dbg4       longitude:  %f\n", *navlon);
			fprintf(stderr, "dbg4       latitude:   %f\n", *navlat);
			fprintf(stderr, "dbg4       speed:      %f\n", *speed);
			fprintf(stderr, "dbg4       heading:    %f\n", *heading);
			fprintf(stderr, "dbg4       draft:      %f\n", *draft);
			fprintf(stderr, "dbg4       roll:       %f\n", *roll);
			fprintf(stderr, "dbg4       pitch:      %f\n", *pitch);
			fprintf(stderr, "dbg4       heave:      %f\n", *heave);
		}

		/* done translating values */
	}

	/* deal with comment */
	else if (*kind == MB_DATA_COMMENT) {
		/* set status */
		*error = MB_ERROR_COMMENT;
		status = MB_FAILURE;
	}

	/* deal with other record type */
	else {
		/* set status */
		*error = MB_ERROR_OTHER;
		status = MB_FAILURE;
	}

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       kind:       %d\n", *kind);
	}
	if (verbose >= 2 && *error <= MB_ERROR_NO_ERROR && *kind == MB_DATA_DATA) {
		fprintf(stderr, "dbg2       time_i[0]:     %d\n", time_i[0]);
		fprintf(stderr, "dbg2       time_i[1]:     %d\n", time_i[1]);
		fprintf(stderr, "dbg2       time_i[2]:     %d\n", time_i[2]);
		fprintf(stderr, "dbg2       time_i[3]:     %d\n", time_i[3]);
		fprintf(stderr, "dbg2       time_i[4]:     %d\n", time_i[4]);
		fprintf(stderr, "dbg2       time_i[5]:     %d\n", time_i[5]);
		fprintf(stderr, "dbg2       time_i[6]:     %d\n", time_i[6]);
		fprintf(stderr, "dbg2       time_d:        %f\n", *time_d);
		fprintf(stderr, "dbg2       longitude:     %f\n", *navlon);
		fprintf(stderr, "dbg2       latitude:      %f\n", *navlat);
		fprintf(stderr, "dbg2       speed:         %f\n", *speed);
		fprintf(stderr, "dbg2       heading:       %f\n", *heading);
		fprintf(stderr, "dbg2       draft:         %f\n", *draft);
		fprintf(stderr, "dbg2       roll:          %f\n", *roll);
		fprintf(stderr, "dbg2       pitch:         %f\n", *pitch);
		fprintf(stderr, "dbg2       heave:         %f\n", *heave);
	}
	if (verbose >= 2) {
		fprintf(stderr, "dbg2       error:      %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:     %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
int mbsys_simrad_insert_nav(int verbose, void *mbio_ptr, void *store_ptr, int time_i[7], double time_d, double navlon,
                            double navlat, double speed, double heading, double draft, double roll, double pitch, double heave,
                            int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:    %d\n", verbose);
		fprintf(stderr, "dbg2       mbio_ptr:   %p\n", (void *)mbio_ptr);
		fprintf(stderr, "dbg2       store_ptr:  %p\n", (void *)store_ptr);
		fprintf(stderr, "dbg2       time_i[0]:  %d\n", time_i[0]);
		fprintf(stderr, "dbg2       time_i[1]:  %d\n", time_i[1]);
		fprintf(stderr, "dbg2       time_i[2]:  %d\n", time_i[2]);
		fprintf(stderr, "dbg2       time_i[3]:  %d\n", time_i[3]);
		fprintf(stderr, "dbg2       time_i[4]:  %d\n", time_i[4]);
		fprintf(stderr, "dbg2       time_i[5]:  %d\n", time_i[5]);
		fprintf(stderr, "dbg2       time_i[6]:  %d\n", time_i[6]);
		fprintf(stderr, "dbg2       time_d:     %f\n", time_d);
		fprintf(stderr, "dbg2       navlon:     %f\n", navlon);
		fprintf(stderr, "dbg2       navlat:     %f\n", navlat);
		fprintf(stderr, "dbg2       speed:      %f\n", speed);
		fprintf(stderr, "dbg2       heading:    %f\n", heading);
		fprintf(stderr, "dbg2       draft:      %f\n", draft);
		fprintf(stderr, "dbg2       roll:       %f\n", roll);
		fprintf(stderr, "dbg2       pitch:      %f\n", pitch);
		fprintf(stderr, "dbg2       heave:      %f\n", heave);
	}

	/* get mbio descriptor */
	// struct mb_io_struct *mb_io_ptr = (struct mb_io_struct *)mbio_ptr;

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)store_ptr;

	/* insert data in structure */
	if (store->kind == MB_DATA_DATA) {
		/* get survey data structure */
		struct mbsys_simrad_survey_struct *ping = (struct mbsys_simrad_survey_struct *)store->ping;

		/* get time */
		mb_unfix_y2k(verbose, time_i[0], &store->year);
		store->month = time_i[1];
		store->day = time_i[2];
		store->hour = time_i[3];
		store->minute = time_i[4];
		store->second = time_i[5];
		store->centisecond = time_i[6] / 10000;

		/* get nav */
		ping->longitude = navlon;
		ping->latitude = navlat;

		/* get heading */
		if (store->sonar == MBSYS_SIMRAD_EM121)
			ping->heading = (int)(heading * 100);
		else
			ping->heading = (int)(heading * 10);

		/* get speed  */
		store->speed = speed / 3.6;

		/* get draft  */
		if (store->sonar == MBSYS_SIMRAD_EM12S)
			store->em12_td = draft;
		else if (store->sonar == MBSYS_SIMRAD_EM12D)
			store->em12_td = draft;
		else if (store->sonar == MBSYS_SIMRAD_EM100)
			store->em100_td = draft;
		else if (store->sonar == MBSYS_SIMRAD_EM1000)
			store->em1000_td = draft;

		/* get roll pitch and heave */
		ping->roll = roll * 100.0;
		ping->pitch = pitch * 100.0;
		ping->ping_heave = heave * 100.0;
	}

	/* insert nav in structure */
	else if (store->kind == MB_DATA_NAV) {
		/* get time */
		mb_unfix_y2k(verbose, time_i[0], &store->pos_year);
		store->pos_month = time_i[1];
		store->pos_day = time_i[2];
		store->pos_hour = time_i[3];
		store->pos_minute = time_i[4];
		store->pos_second = time_i[5];
		store->pos_centisecond = time_i[6] / 10000;

		/* get nav */
		store->pos_longitude = navlon;
		store->pos_latitude = navlat;

		/* get heading */
		store->line_heading = heading;

		/* get speed  */
		store->speed = speed / 3.6;

		/* get draft  */
		if (store->sonar == MBSYS_SIMRAD_EM12S)
			store->em12_td = draft;
		else if (store->sonar == MBSYS_SIMRAD_EM12D)
			store->em12_td = draft;
		else if (store->sonar == MBSYS_SIMRAD_EM100)
			store->em100_td = draft;
		else if (store->sonar == MBSYS_SIMRAD_EM1000)
			store->em1000_td = draft;
	}

	int status = MB_SUCCESS;

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       error:      %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:  %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
int mbsys_simrad_extract_svp(int verbose, void *mbio_ptr, void *store_ptr, int *kind, int *nsvp, double *depth, double *velocity,
                             int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:    %d\n", verbose);
		fprintf(stderr, "dbg2       mb_ptr:     %p\n", (void *)mbio_ptr);
		fprintf(stderr, "dbg2       store_ptr:  %p\n", (void *)store_ptr);
	}

	/* get mbio descriptor */
	// struct mb_io_struct *mb_io_ptr = (struct mb_io_struct *)mbio_ptr;

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)store_ptr;

	/* get data kind */
	*kind = store->kind;

	int status = MB_SUCCESS;

	/* extract data from structure */
	if (*kind == MB_DATA_VELOCITY_PROFILE) {
		/* get number of depth-velocity pairs */
		*nsvp = store->svp_num;

		/* get profile */
		for (int i = 0; i < *nsvp; i++) {
			depth[i] = store->svp_depth[i];
			velocity[i] = 0.1 * store->svp_vel[i];
		}

		/* done translating values */
	}

	/* deal with comment */
	else if (*kind == MB_DATA_COMMENT) {
		/* set status */
		*error = MB_ERROR_COMMENT;
		status = MB_FAILURE;
	}

	/* deal with other record type */
	else {
		/* set status */
		*error = MB_ERROR_OTHER;
		status = MB_FAILURE;
	}

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       kind:              %d\n", *kind);
		fprintf(stderr, "dbg2       nsvp:              %d\n", *nsvp);
		for (int i = 0; i < *nsvp; i++)
			fprintf(stderr, "dbg2       depth[%d]: %f   velocity[%d]: %f\n", i, depth[i], i, velocity[i]);
		fprintf(stderr, "dbg2       error:             %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:            %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
int mbsys_simrad_insert_svp(int verbose, void *mbio_ptr, void *store_ptr, int nsvp, double *depth, double *velocity, int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:    %d\n", verbose);
		fprintf(stderr, "dbg2       mbio_ptr:   %p\n", (void *)mbio_ptr);
		fprintf(stderr, "dbg2       store_ptr:  %p\n", (void *)store_ptr);
		fprintf(stderr, "dbg2       nsvp:       %d\n", nsvp);
		for (int i = 0; i < nsvp; i++)
			fprintf(stderr, "dbg2       depth[%d]: %f   velocity[%d]: %f\n", i, depth[i], i, velocity[i]);
	}

	/* get mbio descriptor */
	// struct mb_io_struct *mb_io_ptr = (struct mb_io_struct *)mbio_ptr;

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)store_ptr;

	/* insert data in structure */
	if (store->kind == MB_DATA_VELOCITY_PROFILE) {
		/* get number of depth-velocity pairs */
		store->svp_num = MIN(nsvp, MBSYS_SIMRAD_MAXSVP);

		/* get profile */
		for (int i = 0; i < store->svp_num; i++) {
			store->svp_depth[i] = (int)depth[i];
			store->svp_vel[i] = (int)(10 * velocity[i]);
		}
	}

	int status = MB_SUCCESS;

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       error:      %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:  %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
int mbsys_simrad_copy(int verbose, void *mbio_ptr, void *store_ptr, void *copy_ptr, int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:    %d\n", verbose);
		fprintf(stderr, "dbg2       mbio_ptr:   %p\n", (void *)mbio_ptr);
		fprintf(stderr, "dbg2       store_ptr:  %p\n", (void *)store_ptr);
		fprintf(stderr, "dbg2       copy_ptr:   %p\n", (void *)copy_ptr);
	}

	/* get mbio descriptor */
	// struct mb_io_struct *mb_io_ptr = (struct mb_io_struct *)mbio_ptr;

	/* get data structure pointers */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)store_ptr;
	struct mbsys_simrad_struct *copy = (struct mbsys_simrad_struct *)copy_ptr;

	int status = MB_SUCCESS;

	char *ping_save = NULL;

	/* check if survey data needs to be copied */
	if (store->kind == MB_DATA_DATA && store->ping != NULL) {
		/* make sure a survey data structure exists to
		    be copied into */
		if (copy->ping == NULL) {
			status = mbsys_simrad_survey_alloc(verbose, mbio_ptr, copy_ptr, error);
		}

		/* save pointer value */
		ping_save = (char *)copy->ping;
	}

	/* copy the main structure */
	*copy = *store;

	/* if needed copy the survey data structure */
	if (store->kind == MB_DATA_DATA && store->ping != NULL && status == MB_SUCCESS) {
		copy->ping = (struct mbsys_simrad_survey_struct *)ping_save;
		struct mbsys_simrad_survey_struct *ping_store = (struct mbsys_simrad_survey_struct *)store->ping;
		struct mbsys_simrad_survey_struct *ping_copy = (struct mbsys_simrad_survey_struct *)copy->ping;
		*ping_copy = *ping_store;
	} else {
		copy->ping = NULL;
	}

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       error:      %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:     %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
int mbsys_simrad_makess(int verbose, void *mbio_ptr, void *store_ptr, int pixel_size_set, double *pixel_size, int swath_width_set,
                        double *swath_width, int pixel_int, int *error) {
	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> called\n", __func__);
		fprintf(stderr, "dbg2  Input arguments:\n");
		fprintf(stderr, "dbg2       verbose:         %d\n", verbose);
		fprintf(stderr, "dbg2       mbio_ptr:        %p\n", (void *)mbio_ptr);
		fprintf(stderr, "dbg2       store_ptr:       %p\n", (void *)store_ptr);
		fprintf(stderr, "dbg2       pixel_size_set:  %d\n", pixel_size_set);
		fprintf(stderr, "dbg2       pixel_size:      %f\n", *pixel_size);
		fprintf(stderr, "dbg2       swath_width_set: %d\n", swath_width_set);
		fprintf(stderr, "dbg2       swath_width:     %f\n", *swath_width);
		fprintf(stderr, "dbg2       pixel_int:       %d\n", pixel_int);
	}

	/* get mbio descriptor */
	// struct mb_io_struct *mb_io_ptr = (struct mb_io_struct *)mbio_ptr;

	/* get data structure pointer */
	struct mbsys_simrad_struct *store = (struct mbsys_simrad_struct *)store_ptr;

	/* insert data in structure */
	if (store->kind == MB_DATA_DATA) {
		/* get pointer to raw data structure */
		struct mbsys_simrad_survey_struct *ping = (struct mbsys_simrad_survey_struct *)store->ping;

		double ss[MBSYS_SIMRAD_MAXPIXELS];
		int ss_cnt[MBSYS_SIMRAD_MAXPIXELS];
		double ssacrosstrack[MBSYS_SIMRAD_MAXPIXELS];
		double ssalongtrack[MBSYS_SIMRAD_MAXPIXELS];

		/* zero the sidescan */
		for (int i = 0; i < MBSYS_SIMRAD_MAXPIXELS; i++) {
			ss[i] = 0.0;
			ssacrosstrack[i] = 0.0;
			ssalongtrack[i] = 0.0;
			ss_cnt[i] = 0;
		}

		double depthscale;
		double dacrscale;
		double daloscale;
		double reflscale;

		/* set scaling parameters */
		if (store->sonar == MBSYS_SIMRAD_EM1000) {
			depthscale = 0.02;
			dacrscale = 0.1;
			daloscale = 0.1;
			reflscale = 0.5;
		} else if (store->sonar == MBSYS_SIMRAD_EM12S && ping->bath_res == 1) {
			depthscale = 0.1;
			dacrscale = 0.2;
			daloscale = 0.2;
			reflscale = 0.5;
		}
		else if (store->sonar == MBSYS_SIMRAD_EM12S && ping->bath_res == 2) {
			depthscale = 0.2;
			dacrscale = 0.5;
			daloscale = 0.5;
			reflscale = 0.5;
		} else if (store->sonar == MBSYS_SIMRAD_EM12D && ping->bath_res == 1) {
			depthscale = 0.1;
			dacrscale = 0.2;
			daloscale = 0.2;
			reflscale = 0.5;
		} else if (store->sonar == MBSYS_SIMRAD_EM12D && ping->bath_res == 2) {
			depthscale = 0.2;
			dacrscale = 0.5;
			daloscale = 0.5;
			reflscale = 0.5;
		} else if (store->sonar == MBSYS_SIMRAD_EM121) {
			depthscale = 0.01 * ping->depth_res;
			dacrscale = 0.01 * ping->across_res;
			daloscale = 0.01 * ping->along_res;
			reflscale = 0.5;
		} else {
			depthscale = 0.1;
			dacrscale = 0.2;
			daloscale = 0.2;
			reflscale = 0.5;
		}

		/* get angles */
		bool interleave = false;
		double *angles_simrad;
		if (store->sonar == MBSYS_SIMRAD_EM1000) {
			if (ping->bath_mode == 1) {
				angles_simrad = angles_EM1000_ISO_ANG_60_2_MS_48_FAIS;
				interleave = false;
			} else if (ping->bath_mode == 2) {
				angles_simrad = angles_EM1000_ISO_ANG_120_07_MS_48_FAIS;
				interleave = true;
			} else if (ping->bath_mode == 3) {
				angles_simrad = angles_EM1000_ISO_ANG_150_02_MS_60_FAIS;
				interleave = true;
			} else if (ping->bath_mode == 4) {
				angles_simrad = angles_EM1000_CHANNEL_02_MS_60_FAIS;
				interleave = true;
			} else if (ping->bath_mode == 5) {
				angles_simrad = angles_EM1000_150_02_MS_60_FAIS;
				interleave = true;
			} else if (ping->bath_mode == 6) {
				angles_simrad = angles_EM1000_140_02_MS_60_FAIS;
				interleave = true;
			} else if (ping->bath_mode == 7) {
				angles_simrad = angles_EM1000_128_02_MS_60_FAIS;
				interleave = true;
			} else if (ping->bath_mode == 8) {
				angles_simrad = angles_EM1000_120_07_MS_48_FAIS;
				interleave = true;
			} else if (ping->bath_mode == 9) {
				angles_simrad = angles_EM1000_104_07_MS_48_FAIS;
				interleave = true;
			} else if (ping->bath_mode == 10) {
				angles_simrad = angles_EM1000_88_07_MS_48_FAIS;
				interleave = true;
			} else if (ping->bath_mode == 11) {
				angles_simrad = angles_EM1000_70_2_MS_48_FAIS;
				interleave = false;
			} else if (ping->bath_mode == 12) {
				angles_simrad = angles_EM1000_BERGE_02_MS_60_FAIS;
				interleave = true;
			} else if (ping->bath_mode == 13) {
				angles_simrad = angles_EM1000_BERGE_02_MS_60_FAIS;
				interleave = true;
			}
		} else if (store->sonar == MBSYS_SIMRAD_EM12S) {
			if (ping->bath_mode == 1)
				angles_simrad = angles_EM12S_ISO_ANG_SHALLOW;
			else if (ping->bath_mode == 2)
				angles_simrad = angles_EM12S_ISO_ANG_DEEP;
			else if (ping->bath_mode == 3)
				angles_simrad = angles_EM12S_SHALLOW;
			else if (ping->bath_mode == 4)
				angles_simrad = angles_EM12S_120;
			else if (ping->bath_mode == 5)
				angles_simrad = angles_EM12S_105;
			else if (ping->bath_mode == 6)
				angles_simrad = angles_EM12S_90;
		} else if (store->sonar == MBSYS_SIMRAD_EM12D && ping->swath_id == EM_SWATH_PORT) {
			if (ping->bath_mode == 1)
				angles_simrad = angles_EM12DP_ISO_ANG_SHALLOW;
			else if (ping->bath_mode == 2)
				angles_simrad = angles_EM12DP_ISO_ANG_DEEP;
			else if (ping->bath_mode == 3)
				angles_simrad = angles_EM12DP_SHALLOW;
			else if (ping->bath_mode == 4)
				angles_simrad = angles_EM12DP_150;
			else if (ping->bath_mode == 5)
				angles_simrad = angles_EM12DP_140;
			else if (ping->bath_mode == 6)
				angles_simrad = angles_EM12DP_128;
			else if (ping->bath_mode == 7)
				angles_simrad = angles_EM12DP_114;
			else if (ping->bath_mode == 8)
				angles_simrad = angles_EM12DP_98;
		} else if (store->sonar == MBSYS_SIMRAD_EM12D && ping->swath_id == EM_SWATH_STARBOARD) {
			if (ping->bath_mode == 1)
				angles_simrad = angles_EM12DS_ISO_ANG_SHALLOW;
			else if (ping->bath_mode == 2)
				angles_simrad = angles_EM12DS_ISO_ANG_DEEP;
			else if (ping->bath_mode == 3)
				angles_simrad = angles_EM12DS_SHALLOW;
			else if (ping->bath_mode == 4)
				angles_simrad = angles_EM12DS_150;
			else if (ping->bath_mode == 5)
				angles_simrad = angles_EM12DS_140;
			else if (ping->bath_mode == 6)
				angles_simrad = angles_EM12DS_128;
			else if (ping->bath_mode == 7)
				angles_simrad = angles_EM12DS_114;
			else if (ping->bath_mode == 8)
				angles_simrad = angles_EM12DS_98;
		} else if (store->sonar == MBSYS_SIMRAD_EM121) {
			angles_simrad = angles_EM121_GUESS;
		}

		/* if interleaved get center beam */
		int istep;
		if (interleave) {
			if (ping->bath_mode == 12 && abs(ping->bath_acrosstrack[28]) < abs(ping->bath_acrosstrack[29]))
				istep = 1;
			else if (ping->bath_mode == 13 && abs(ping->bath_acrosstrack[31]) < abs(ping->bath_acrosstrack[30]))
				istep = 1;
			else if (abs(ping->bath_acrosstrack[ping->beams_bath / 2 - 1]) < abs(ping->bath_acrosstrack[ping->beams_bath / 2]))
				istep = 1;
			else
				istep = 0;
		}

		double ss_spacing;

		/* get raw pixel size */
		if (store->sonar == MBSYS_SIMRAD_EM12D || store->sonar == MBSYS_SIMRAD_EM12S || store->sonar == MBSYS_SIMRAD_EM121) {
			if (ping->ss_mode == 1)
				ss_spacing = 0.6;
			else if (ping->ss_mode == 2)
				ss_spacing = 2.4;
			else if (ping->bath_mode == 1 || ping->bath_mode == 3)
				ss_spacing = 0.6;
			else
				ss_spacing = 2.4;
		} else if (store->sonar == MBSYS_SIMRAD_EM1000) {
			if (ping->ss_mode == 3)
				ss_spacing = 0.3;
			else if (ping->ss_mode == 4)
				ss_spacing = 0.3;
			// else if (ping->ss_mode == 5)
			//	ss_spacing = 0.15;
			else
				ss_spacing = 0.15;
		}

		/* get beam angle size */
		double beamwidth;
		if (store->sonar == MBSYS_SIMRAD_EM12D || store->sonar == MBSYS_SIMRAD_EM12S) {
			beamwidth = 2.00;
		}
		else if (store->sonar == MBSYS_SIMRAD_EM121) {
			beamwidth = ping->beam_width;
		}
		else if (store->sonar == MBSYS_SIMRAD_EM1000) {
			beamwidth = 2.5;
		} else {
			assert(false);
		}

		/* get median depth */
		int nbathsort = 0;
		double bathsort[MBSYS_SIMRAD_MAXBEAMS];
		for (int i = 0; i < ping->beams_bath; i++) {
			if (ping->bath[i] > 0.0) {
				bathsort[nbathsort] = depthscale * ping->bath[i];
				nbathsort++;
			}
		}

		/* get sidescan pixel size */
		if (!swath_width_set && nbathsort > 0) {
			(*swath_width) = 2.5 + angles_simrad[0];
			(*swath_width) = MAX((*swath_width), 60.0);
		}
		if (!pixel_size_set && nbathsort > 0) {
			qsort((char *)bathsort, nbathsort, sizeof(double), (void *)mb_double_compare);
			double pixel_size_calc = 2 * tan(DTR * (*swath_width)) * bathsort[nbathsort / 2] / MBSYS_SIMRAD_MAXPIXELS;
			pixel_size_calc = MAX(pixel_size_calc, bathsort[nbathsort / 2] * sin(DTR * 0.1));
			if ((*pixel_size) <= 0.0)
				(*pixel_size) = pixel_size_calc;
			else if (0.95 * (*pixel_size) > pixel_size_calc)
				(*pixel_size) = 0.95 * (*pixel_size);
			else if (1.05 * (*pixel_size) < pixel_size_calc)
				(*pixel_size) = 1.05 * (*pixel_size);
			else
				(*pixel_size) = pixel_size_calc;
		}

		/* get pixel interpolation */
		const int pixel_int_use = pixel_int + 1;

		// const double depthoffset = 0.0;

		if (verbose >= 2) {
			fprintf(stderr, "\ndbg2  Sidescan regenerated in <%s>\n", __func__);
			fprintf(stderr, "dbg2       depthscale:    %f\n", depthscale);
			fprintf(stderr, "dbg2       dacrscale:     %f\n", dacrscale);
			fprintf(stderr, "dbg2       daloscale:     %f\n", daloscale);
			fprintf(stderr, "dbg2       reflscale:     %f\n", reflscale);
			fprintf(stderr, "dbg2       depthscale:    %f\n", depthscale);
			// fprintf(stderr, "dbg2       depthoffset:   %f\n", depthoffset);
			fprintf(stderr, "dbg2       depthscale:    %f\n", depthscale);
			fprintf(stderr, "dbg2       ss_spacing:    %f\n", ss_spacing);
			fprintf(stderr, "dbg2       pixel_size:    %f\n", *pixel_size);
			fprintf(stderr, "dbg2       swath_width:   %f\n", *swath_width);
			for (int i = 0; i < ping->beams_bath; i++)
				fprintf(stderr, "dbg2       beam:%d  bath: %d %d %d freq:%d nsamp:%d center:%d start:%d\n", i, ping->bath[i],
				        ping->bath_acrosstrack[i], ping->bath_alongtrack[i], ping->beam_frequency[i], ping->beam_samples[i],
				        ping->beam_center_sample[i], ping->beam_start_sample[i]);
		}

		/* loop over raw sidescan, putting each raw pixel into
		    the binning arrays */
		{
		double ltrack;
		double ss_spacing_use;
		double xtrack;

		for (int i = 0; i < ping->beams_bath; i++) {
			mb_s_char *beam_ss = &ping->ssraw[ping->beam_start_sample[i]];
			if (ping->bath[i] > 0.0) {
				if (ping->beam_samples[i] > 0) {
					const double depth = depthscale * ping->bath[i];
					xtrack = dacrscale * ping->bath_acrosstrack[i];
					ltrack = daloscale * ping->bath_alongtrack[i];
					const double range = sqrt(depth * depth + xtrack * xtrack);
					double angle;
					if (store->sonar == MBSYS_SIMRAD_EM1000 && ping->bath_mode == 13) {
						angle = angles_simrad[ping->beams_bath - 1 - (2 * i + istep)];
					} else if (store->sonar == MBSYS_SIMRAD_EM1000 && interleave) {
						angle = -angles_simrad[2 * i + istep];
					// } else if (store->sonar == MBSYS_SIMRAD_EM1000) {
					//	angle = -angles_simrad[i];
					} else {
						angle = -angles_simrad[i];
					}
					const double beam_foot = range * sin(DTR * beamwidth) / cos(DTR * angle);
					const double sint = fabs(sin(DTR * angle));
					if (sint < ping->beam_samples[i] * ss_spacing / beam_foot)
						ss_spacing_use = beam_foot / ping->beam_samples[i];
					else
						ss_spacing_use = ss_spacing / sint;
				}
				for (int k = 0; k < ping->beam_samples[i]; k++) {
					const double xtrackss = xtrack + ss_spacing_use * (k - ping->beam_center_sample[i]);
					const int kk = MBSYS_SIMRAD_MAXPIXELS / 2 + (int)(xtrackss / (*pixel_size));
					if (kk > 0 && kk < MBSYS_SIMRAD_MAXPIXELS) {
						ss[kk] += reflscale * ((double)beam_ss[k]);
						ssalongtrack[kk] += ltrack;
						ss_cnt[kk]++;
					}
				}
			}
		}
		}

		/* average the sidescan */
		int first = MBSYS_SIMRAD_MAXPIXELS;
		int last = -1;
		for (int k = 0; k < MBSYS_SIMRAD_MAXPIXELS; k++) {
			if (ss_cnt[k] > 0) {
				ss[k] /= ss_cnt[k];
				ssalongtrack[k] /= ss_cnt[k];
				ssacrosstrack[k] = (k - MBSYS_SIMRAD_MAXPIXELS / 2) * (*pixel_size);
				first = MIN(first, k);
				last = k;
			}
			else
				ss[k] = MB_SIDESCAN_NULL;
		}

		/* interpolate the sidescan */
		int k1 = first;
		int k2 = first;
		for (int k = first + 1; k < last; k++) {
			if (ss_cnt[k] <= 0) {
				if (k2 <= k) {
					k2 = k + 1;
					while (k2 < last && ss_cnt[k2] <= 0)
						k2++;
				}
				if (k2 - k1 <= pixel_int_use) {
					ss[k] = ss[k1] + (ss[k2] - ss[k1]) * ((double)(k - k1)) / ((double)(k2 - k1));
					ssacrosstrack[k] = (k - MBSYS_SIMRAD_MAXPIXELS / 2) * (*pixel_size);
					ssalongtrack[k] =
					    ssalongtrack[k1] + (ssalongtrack[k2] - ssalongtrack[k1]) * ((double)(k - k1)) / ((double)(k2 - k1));
				}
			}
			else {
				k1 = k;
			}
		}

		/* insert the new sidescan into store */
		ping->pixel_size = (int)(100 * (*pixel_size));
		if (last > first)
			ping->pixels_ss = MBSYS_SIMRAD_MAXPIXELS;
		else
			ping->pixels_ss = 0;
		for (int i = 0; i < MBSYS_SIMRAD_MAXPIXELS; i++) {
			if (ss[i] > MB_SIDESCAN_NULL) {
				ping->ss[i] = (short)(100 * ss[i]);
				ping->ssalongtrack[i] = (short)(ssalongtrack[i] / daloscale);
			}
			else {
				ping->ss[i] = 0;
				ping->ssalongtrack[i] = 0;
			}
		}

		if (verbose >= 2) {
			fprintf(stderr, "\ndbg2  Sidescan regenerated in <%s>\n", __func__);
			fprintf(stderr, "dbg2       beams_bath:    %d\n", ping->beams_bath);
			for (int i = 0; i < ping->beams_bath; i++)
				fprintf(stderr, "dbg2       beam:%d  bath:%d  amp:%d  acrosstrack:%d  alongtrack:%d\n", i, ping->bath[i],
				        ping->amp[i], ping->bath_acrosstrack[i], ping->bath_alongtrack[i]);
			fprintf(stderr, "dbg2       pixels_ss:  %d\n", MBSYS_SIMRAD_MAXPIXELS);
			for (int i = 0; i < MBSYS_SIMRAD_MAXPIXELS; i++)
				fprintf(stderr, "dbg2       pixel:%4d  cnt:%3d  ss:%10f  xtrack:%10f  ltrack:%10f\n", i, ss_cnt[i], ss[i],
				        ssacrosstrack[i], ssalongtrack[i]);
			fprintf(stderr, "dbg2       pixels_ss:  %d\n", ping->pixels_ss);
			for (int i = 0; i < ping->pixels_ss; i++)
				fprintf(stderr, "dbg2       pixel:%4d  ss:%8d  ltrack:%8d\n", i, ping->ss[i], ping->ssalongtrack[i]);
		}
	}

	int status = MB_SUCCESS;

	if (verbose >= 2) {
		fprintf(stderr, "\ndbg2  MBIO function <%s> completed\n", __func__);
		fprintf(stderr, "dbg2  Return values:\n");
		fprintf(stderr, "dbg2       pixel_size:      %f\n", *pixel_size);
		fprintf(stderr, "dbg2       swath_width:     %f\n", *swath_width);
		fprintf(stderr, "dbg2       error:           %d\n", *error);
		fprintf(stderr, "dbg2  Return status:\n");
		fprintf(stderr, "dbg2       status:          %d\n", status);
	}

	return (status);
}
/*--------------------------------------------------------------------*/
