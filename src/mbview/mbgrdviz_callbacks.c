/*
 * README: This file is appended to at file generation time.
 * Edits can be made throughout the file
 */
/*
 * Generated by the ICS Builder Xcessory (BX).
 *
 * Builder Xcessory Version 5.0.3
 * Code Generator Xcessory 5.0.1 (09/29/98) 
 *
 */
#include <Xm/Xm.h>


/*
 * Standard includes for builtins.
 */
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

/* MBIO include files */
#include "../../include/mb_status.h"
#include "../../include/mb_define.h"
#include "../../include/mb_format.h"

/* GMT include files */
#include "gmt.h"

/* get NaN detector */
#if defined(isnanf)
#define check_fnan(x) isnanf((x))
#elif defined(isnan)
#define check_fnan(x) isnan((double)(x))
#elif HAVE_ISNANF == 1
#define check_fnan(x) isnanf(x)
extern int isnanf(float x);
#elif HAVE_ISNAN == 1
#define check_fnan(x) isnan((double)(x))
#elif HAVE_ISNAND == 1
#define check_fnan(x) isnand((double)(x))
#else
#define check_fnan(x) ((x) != (x))
#endif

/* mbview include file */
#include "mbview.h"

/* fileSelectionBox modes */
#define MBGRDVIZ_OPENGRID	0
#define MBGRDVIZ_OPENOVERLAY	1
#define MBGRDVIZ_OPENROUTE	2
#define MBGRDVIZ_OPENSITE	3
#define MBGRDVIZ_OPENNAV	4
#define MBGRDVIZ_OPENSWATH	5
#define MBGRDVIZ_SAVEROUTE	6
#define MBGRDVIZ_SAVESITE	7

/* Projection defines */
#define ModelTypeProjected	     1
#define ModelTypeGeographic	     2
#define GCS_WGS_84		  4326

/* Site and route file versions */
#define MBGRDVIZ_SITE_VERSION "1.00"
#define MBGRDVIZ_ROUTE_VERSION "1.00"

/* id variables */
static char rcs_id[] = "$Id: mbgrdviz_callbacks.c,v 5.2 2004-02-24 22:52:28 caress Exp $";
static char program_name[] = "MBgrdviz";
static char help_message[] = "MBgrdviz is an interactive 2D/3D visualization tool for GMT grid files.";
static char usage_message[] = "mbgrdviz [-H -T -V]";

/* status variables */
int	verbose;
int	error;
int	pargc;
char	**pargv;

/* widgets */
int	mbview_id[MBV_MAX_WINDOWS];
extern 	Widget mainWindow;
Widget	fileSelectionList;
Widget	fileSelectionText;

/* function prototypes */
int do_mbgrdviz_dismiss_notify(int instance);
void do_mbgrdviz_fileSelectionBox( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_fileSelectionBox_openoverlay( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_fileSelectionBox_openroute( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_fileSelectionBox_opensite( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_fileSelectionBox_opennav( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_fileSelectionBox_openswath( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_fileSelectionBox_saveroute( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_fileSelectionBox_savesite( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_open_region( Widget w, XtPointer client_data, XtPointer call_data);

/*
 * Motif required Headers
 */
#include <X11/StringDefs.h>
#include <Xm/Xm.h>
#include <Xm/DialogS.h>
#if (XmVersion >= 1002)
#include <Xm/RepType.h>
#endif
#include <Xm/MwmUtil.h>
#include "mbgrdviz_creation.h"

/*
 * Macros to make code look nicer between ANSI and K&R.
 */
#ifndef ARGLIST
#if (NeedFunctionPrototypes == 0)
#define PROTOTYPE(p)	()
#define ARGLIST(p)	p
#define ARG(a, b)	a b;
#define GRA(a, b)	a b;
#define UARG(a, b)      a b;
#define GRAU(a, b)      a b;
#else
#define PROTOTYPE(p)	p
#define ARGLIST(p)	(
#define ARG(a, b)	a b,
#define GRA(a, b)	a b)
#ifdef __cplusplus
#define UARG(a, b)      a,
#define GRAU(a, b)      a)
#else
#define UARG(a, b)      a b,
#define GRAU(a, b)      a b)
#endif
#endif
#endif

Widget		BxFindTopShell PROTOTYPE((Widget));
WidgetList	BxWidgetIdsFromNames PROTOTYPE((Widget, char*, char*));


/*      Function Name:	BxExitCB
 *
 *      Description:   	This functions expects an integer to be passed in
 *		       	client data.  It calls the exit() system call with
 *			the integer value as the argument to the function.
 *
 *      Arguments:      Widget		w: 	the activating widget.
 *			XtPointer	client:	the integer exit value.
 *			XtPointer	call:	the call data (unused).
 */

#ifdef VMS
#include <stdlib.h>
#endif

/* ARGSUSED */
void
BxExitCB ARGLIST((w, client, call))
UARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
    long	exitValue = (long)client;
    exit(exitValue);
}

/*      Function Name: 	BxManageCB
 *
 *      Description:   	Given a string of the form:
 *		       	"(WL)[widgetName, widgetName, ...]"
 *			BxManageCB attempts to convert the name to a Widget
 *			ID and manage the widget.
 *
 *      Arguments:     	Widget	    w:      the widget activating the callback.
 *		       	XtPointer   client: the list of widget names to attempt
 *					    to find and manage.
 *		       	XtPointer   call:   the call data (unused).
 *
 *      Notes:        *	This function expects that there is an application
 *		       	shell from which all other widgets are descended.
 */

/* ARGSUSED */
void
BxManageCB ARGLIST((w, client, call))
ARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
    WidgetList		widgets;
    int			i;

    /*
     * This function returns a NULL terminated WidgetList.  The memory for
     * the list needs to be freed when it is no longer needed.
     */
    widgets = BxWidgetIdsFromNames(w, "BxManageCB", (String)client);

    i = 0;
    while( widgets && widgets[i] != NULL )
    {
	XtManageChild(widgets[i]);
	i++;
    }
    XtFree((char *)widgets);
}

/*      Function Name: 	BxUnmanageCB
 *
 *      Description:   	Given a string of the form:
 *		       	"(WL)[widgetName, widgetName, ...]"
 *			BxUnmanageCB attempts to convert the name to a Widget
 *			ID and unmanage the widget.
 *
 *      Arguments:     	Widget	    w:      the widget activating the callback.
 *		       	XtPointer   client: the list of widget names to attempt
 *					    to find and unmanage.
 *		       	XtPointer   call:   the call data (unused).
 *
 *      Notes:        *	This function expects that there is an application
 *		       	shell from which all other widgets are descended.
 */

/* ARGSUSED */
void
BxUnmanageCB ARGLIST((w, client, call))
ARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
    WidgetList		widgets;
    int			i;

    /*
     * This function returns a NULL terminated WidgetList.  The memory for
     * the list needs to be freed when it is no longer needed.
     */
    widgets = BxWidgetIdsFromNames(w, "BxUnmanageCB", (String)client);

    i = 0;
    while( widgets && widgets[i] != NULL )
    {
	XtUnmanageChild(widgets[i]);
	i++;
    }
    XtFree((char *)widgets);
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_init(int argc, char **argv, int verbosity)
{
	char function_name[] = "do_mbgrdviz_init";
	int	status = MB_SUCCESS;
	int	instance;
	char	value_text[MB_PATH_MAXLINE];
	int	i, j;

	pargc = argc;
	pargv = argv;
	verbose = verbosity;
	error = MB_ERROR_NO_ERROR;
			
	/* set about version label */
	sprintf(value_text, "::#TimesMedium14:t\"MB-System Release %s\"#TimesMedium14\"%s\"", 
		MB_VERSION, MB_BUILD_DATE);
	set_mbview_label_multiline_string(label_about_version, value_text);
   
	/* get additional widgets */
	fileSelectionList = (Widget) 
	    XmFileSelectionBoxGetChild(fileSelectionBox, 
					XmDIALOG_LIST);
	fileSelectionText = (Widget) 
	    XmFileSelectionBoxGetChild(fileSelectionBox, 
					XmDIALOG_TEXT);
	XtUnmanageChild(
		(Widget) XmFileSelectionBoxGetChild(
					fileSelectionBox, 
					XmDIALOG_HELP_BUTTON));
	
	/* initialize mbview_id list */
	for (i=0;i<MBV_MAX_WINDOWS;i++)
	    {
	    mbview_id[i] = MB_NO;
	    }
	
	return(0);
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox( Widget w, XtPointer client_data, XtPointer call_data)
{
 	int	actionid;
	int	mode;
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* figure out what kind of file is to be opened */
	actionid = (int) client_data;
	mode = actionid / MBV_MAX_WINDOWS;
	if (mode > 0)
		instance = actionid - mode * MBV_MAX_WINDOWS;
	
	/* set title to open primary grid */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Open GMT Grid File"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	
	/* open primary grid */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*.grd", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;

	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox_openoverlay( Widget w, XtPointer client_data, XtPointer call_data)
{
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	int	actionid;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* get instance */
	instance = (int) client_data;
	
	/* set title to open file dialog  */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Open Overlay GMT Grid File"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	/* set fileSelectionBox parameters */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*.grd", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;
	actionid = MBGRDVIZ_OPENOVERLAY * MBV_MAX_WINDOWS + instance;
	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox_openroute( Widget w, XtPointer client_data, XtPointer call_data)
{
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	int	actionid;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* get instance */
	instance = (int) client_data;
	
	/* set title to open file dialog  */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Open Route File"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	/* set fileSelectionBox parameters */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;
	actionid = MBGRDVIZ_OPENROUTE * MBV_MAX_WINDOWS + instance;
	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox_opensite( Widget w, XtPointer client_data, XtPointer call_data)
{
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	int	actionid;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* get instance */
	instance = (int) client_data;
	
	/* set title to open file dialog  */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Open Site File"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	/* set fileSelectionBox parameters */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;
	actionid = MBGRDVIZ_OPENSITE * MBV_MAX_WINDOWS + instance;
	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox_opennav( Widget w, XtPointer client_data, XtPointer call_data)
{
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	int	actionid;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* get instance */
	instance = (int) client_data;
	
	/* set title to open file dialog  */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Open Navigation Datalist File"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	/* set fileSelectionBox parameters */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*.mb-1", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;
	actionid = MBGRDVIZ_OPENNAV * MBV_MAX_WINDOWS + instance;
	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox_openswath( Widget w, XtPointer client_data, XtPointer call_data)
{
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	int	actionid;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* get instance */
	instance = (int) client_data;
	
	/* set title to open file dialog  */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Open Swath Datalist File"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	/* set fileSelectionBox parameters */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*.mb-1", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;
	actionid = MBGRDVIZ_OPENSWATH * MBV_MAX_WINDOWS + instance;
	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox_saveroute( Widget w, XtPointer client_data, XtPointer call_data)
{
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	int	actionid;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* get instance */
	instance = (int) client_data;
	
	/* set title to open file dialog  */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Save Route File"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	/* set fileSelectionBox parameters */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;
	actionid = MBGRDVIZ_SAVEROUTE * MBV_MAX_WINDOWS + instance;
	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox_savesite( Widget w, XtPointer client_data, XtPointer call_data)
{
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	int	actionid;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* get instance */
	instance = (int) client_data;
	
	/* set title to open file dialog  */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Save Site File"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	/* set fileSelectionBox parameters */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;
	actionid = MBGRDVIZ_SAVESITE * MBV_MAX_WINDOWS + instance;
	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_close( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
fprintf(stderr,"Called do_mbgrdviz_close\n");
}
/*---------------------------------------------------------------------------------------*/

void
do_mbgrdviz_quit( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_dismiss_notify(int instance)
{
	char function_name[] = "do_mbgrdviz_dismiss_notify";
	int	status = MB_SUCCESS;
	int	verbose = 0;
	int	i, j, k;
	
	/* set mbview window <id> to inactive */
	if (instance >= 0 && instance < MBV_MAX_WINDOWS
		&& mbview_id[instance] == MB_YES)
		{
		mbview_id[instance] = MB_NO;
		}
	else
	    	{
	   	fprintf(stderr, "Unable to free mbview - mbview window %d not found in local list...\n", 
				instance);
	    	}

	/* update widgets of remaining mbview windows */
	for (i=0;i<MBV_MAX_WINDOWS;i++)
		{
		if (mbview_id[i] == MB_YES)
			status = mbview_update(verbose, i, &error);
		}
	
	return(status);
}
/*---------------------------------------------------------------------------------------*/

void
do_mbgrdviz_openfile( Widget w, XtPointer client_data, XtPointer call_data)
{
	char function_name[] = "do_mbgrdviz_openfile";
	int	status = MB_SUCCESS;
	int	actionid;
	int	mode;
	int	instance;
	char    *file_ptr;
        Cardinal ac = 0;
        Arg      args[256];
    XmFileSelectionBoxCallbackStruct *acs=(XmFileSelectionBoxCallbackStruct*)call_data;

fprintf(stderr,"do_mbgrdviz_openfile\n");

    	/* figure out what kind of file is to be opened */

	ac = 0;
	XtSetArg(args[ac], XmNuserData, (XtPointer) &actionid); ac++;
	XtGetValues(fileSelectionBox, args, ac);

	mode = actionid / MBV_MAX_WINDOWS;
	if (mode > 0)
		instance = actionid - mode * MBV_MAX_WINDOWS;
	else
		instance = 0;

	/* read the input file name */
	XmStringGetLtoR(acs->value, XmSTRING_DEFAULT_CHARSET, 
			&file_ptr);
	if (strlen(file_ptr) <= 0 && file_ptr != NULL)
		{
		XtFree(file_ptr);
		file_ptr = NULL;
		}
	
	/* open primary grid */
	if (mode <= MBGRDVIZ_OPENGRID)
		{
		/* read the grid and open mbview window */
		fprintf(stderr, "call do_mbgrdviz_openprimary\n");
		status = do_mbgrdviz_openprimary(file_ptr);
		}
	
	/* else open overlay grid */
	else if (mode == MBGRDVIZ_OPENOVERLAY)
		{
		/* read the grid and update mbview window */
		do_mbview_message_on("Reading overlay grid...", instance);
		fprintf(stderr, "call do_mbgrdviz_openoverlay\n");
		status = do_mbgrdviz_openoverlay(instance, file_ptr);
		}
	
	/* else open route data */
	else if (mode == MBGRDVIZ_OPENROUTE)
		{
		/* read route file and update mbview window */
		do_mbview_message_on("Reading route data...", instance);
		fprintf(stderr, "call do_mbgrdviz_openroute\n");
		status = do_mbgrdviz_openroute(instance, file_ptr);
		}
	
	/* else open site data */
	else if (mode == MBGRDVIZ_OPENSITE)
		{
		/* read site file and update mbview window */
		do_mbview_message_on("Reading site data...", instance);
		fprintf(stderr, "call do_mbgrdviz_opensite\n");
		status = do_mbgrdviz_opensite(instance, file_ptr);
		}
	
	/* else open nav data */
	else if (mode == MBGRDVIZ_OPENNAV)
		{
		/* read nav file and update mbview window */
		do_mbview_message_on("Reading navigation data...", instance);
		fprintf(stderr, "call do_mbgrdviz_opennav\n");
		status = do_mbgrdviz_opennav(instance, MB_NO, file_ptr);
		}
	
	/* else open swath data */
	else if (mode == MBGRDVIZ_OPENSWATH)
		{
		/* read nav file and update mbview window */
		do_mbview_message_on("Reading swath data...", instance);
		fprintf(stderr, "call do_mbgrdviz_opennav\n");
		status = do_mbgrdviz_opennav(instance, MB_YES, file_ptr);
		}
	
	/* else write site data */
	else if (mode == MBGRDVIZ_SAVESITE)
		{
		/* write site file */
		do_mbview_message_on("Saving site data...", instance);
		fprintf(stderr, "call do_mbgrdviz_savesite\n");
		status = do_mbgrdviz_savesite(instance, file_ptr);
		}
	
	/* else write route data */
	else if (mode == MBGRDVIZ_SAVEROUTE)
		{
		/* write route file */
		do_mbview_message_on("Saving route data...", instance);
		fprintf(stderr, "call do_mbgrdviz_saveroute\n");
		status = do_mbgrdviz_saveroute(instance, file_ptr);
		}

	/* free the string */
	if (file_ptr != NULL)
		{
		XtFree(file_ptr);
		file_ptr = NULL;
		}

	/* close the message */
	if (mode > MBGRDVIZ_OPENGRID)
		do_mbview_message_off(instance);
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_openprimary(char *input_file_ptr)
{
	char function_name[] = "do_mbgrdviz_openprimary";
	int	status = MB_SUCCESS;
	char    *button_name_ptr;
	double	xx, yy;
	int	instance;
	int	i, j, k;
        Cardinal ac = 0;
        Arg      args[256];
        Cardinal cdc = 0;
        Boolean  argok = False;
        XmString    tmp0;
	int	actionid;
	char	*testname = "Internal Test Grid";
	int	projectionid, utmzone;
	double	reference_lon;
	
	/* mbview parameters */
	int 	(*mbview_dismiss_notify)(int id);
	char	mbv_title[MB_PATH_MAXLINE];
	int	mbv_xo;
	int	mbv_yo;
	int	mbv_width;
	int	mbv_height;
	int	mbv_lorez_dimension;
	int	mbv_hirez_dimension;
	int	mbv_display_mode;
	int	mbv_mouse_mode;
	int	mbv_grid_mode;
	int	mbv_primary_shade_mode;
	int	mbv_slope_shade_mode;
	int	mbv_secondary_shade_mode;
	int	mbv_grid_contour_mode;
	int	mbv_site_view_mode;
	int	mbv_route_view_mode;
	int	mbv_nav_view_mode;
	int	mbv_navdrape_view_mode;
	int	mbv_primary_colortable;
	int	mbv_primary_colortable_mode;
	double	mbv_primary_colortable_min;
	double	mbv_primary_colortable_max;
	int	mbv_slope_colortable;
	int	mbv_slope_colortable_mode;
	double	mbv_slope_colortable_min;
	double	mbv_slope_colortable_max;
	int	mbv_secondary_colortable;
	int	mbv_secondary_colortable_mode;
	double	mbv_secondary_colortable_min;
	double	mbv_secondary_colortable_max;
	double	mbv_exageration;
	double	mbv_modelelevation3d;
	double	mbv_modelazimuth3d;
	double	mbv_viewelevation3d;
	double	mbv_viewazimuth3d;
	double	mbv_illuminate_magnitude;
	double	mbv_illuminate_elevation;
	double	mbv_illuminate_azimuth;
	double	mbv_slope_magnitude;
	double	mbv_overlay_shade_magnitude;
	double	mbv_overlay_shade_center;
	int	mbv_overlay_shade_mode;
	double	mbv_contour_interval;
	int	mbv_primary_grid_projection_mode;
	char	mbv_primary_grid_projection_id[MB_PATH_MAXLINE];
	int	mbv_secondary_grid_projection_mode;
	char	mbv_secondary_grid_projection_id[MB_PATH_MAXLINE];
	int	mbv_display_projection_mode;
	char	mbv_display_projection_id[MB_PATH_MAXLINE];
	float	mbv_primary_nodatavalue;
	int	mbv_primary_nxy;
	int	mbv_primary_nx;
	int	mbv_primary_ny;
	double	mbv_primary_min;
	double	mbv_primary_max;
	double	mbv_primary_xmin;
	double	mbv_primary_xmax;
	double	mbv_primary_ymin;
	double	mbv_primary_ymax;
	double	mbv_primary_dx;
	double	mbv_primary_dy;
	float	*mbv_primary_data;

	/* get next instance number */
	status = mbview_init(verbose, &instance, &error);
	if (instance < 0)
		{
		fprintf(stderr, "Unable to create mbview - %d mbview windows already created\n", 
		MBV_MAX_WINDOWS);
		}
	    
	else if (instance >= 0)
		{
if (input_file_ptr != NULL)
fprintf(stderr, "opening input grid:%s\n",input_file_ptr);
else
fprintf(stderr, "using internal test grid...\n");

		/* get button name */
		if (input_file_ptr != NULL)
			{
			button_name_ptr = (char *) rindex(input_file_ptr, '/');
			if (button_name_ptr == NULL)
				button_name_ptr = input_file_ptr;
			else
				button_name_ptr++;
			}
		else
			{
			button_name_ptr = testname;
			}
				

		/* set parameters */
		sprintf(mbv_title, "MBgrdviz: %s\n", button_name_ptr);
		mbv_xo = 200;
		mbv_yo = 200;
		mbv_width = 560;
		mbv_height = 500;
		mbv_lorez_dimension = 100;
		mbv_hirez_dimension = 500;

		/* set basic mbview window parameters */
		status = mbview_setwindowparms(verbose, instance,
					&do_mbgrdviz_dismiss_notify,
					mbv_title,
					mbv_xo,
					mbv_yo,
					mbv_width,
					mbv_height,
					mbv_lorez_dimension,
					mbv_hirez_dimension,
					&error);
		
		/* read in the grd file */
		if (status == MB_SUCCESS
			&& input_file_ptr != NULL)
		status = do_mbgrdviz_readgrd(instance, input_file_ptr,
			&mbv_primary_grid_projection_mode,
			mbv_primary_grid_projection_id,
			&mbv_primary_nodatavalue,
			&mbv_primary_nxy,
			&mbv_primary_nx,
			&mbv_primary_ny,
			&mbv_primary_min,
			&mbv_primary_max,
			&mbv_primary_xmin,
			&mbv_primary_xmax,
			&mbv_primary_ymin,
			&mbv_primary_ymax,
			&mbv_primary_dx,
			&mbv_primary_dy,
			&mbv_primary_data);
			
		else if (status == MB_SUCCESS)
		status = do_mbgrdviz_opentest(instance, 
			1000.0, 3.0, 2.0, 
			&mbv_primary_grid_projection_mode,
			mbv_primary_grid_projection_id,
			&mbv_primary_nodatavalue,
			&mbv_primary_nxy,
			&mbv_primary_nx,
			&mbv_primary_ny,
			&mbv_primary_min,
			&mbv_primary_max,
			&mbv_primary_xmin,
			&mbv_primary_xmax,
			&mbv_primary_ymin,
			&mbv_primary_ymax,
			&mbv_primary_dx,
			&mbv_primary_dy,
			&mbv_primary_data);

		/* set parameters */
		mbv_display_mode = MBV_DISPLAY_2D;
		mbv_mouse_mode = MBV_MOUSE_MOVE;
		mbv_grid_mode = MBV_GRID_VIEW_PRIMARY;
		mbv_primary_shade_mode = MBV_SHADE_VIEW_SLOPE;
		mbv_slope_shade_mode = MBV_SHADE_VIEW_NONE;
		mbv_secondary_shade_mode = MBV_SHADE_VIEW_NONE;
		mbv_grid_contour_mode = MBV_VIEW_OFF;
		mbv_site_view_mode = MBV_VIEW_OFF;
		mbv_route_view_mode = MBV_VIEW_OFF;
		mbv_nav_view_mode = MBV_VIEW_OFF;
		mbv_navdrape_view_mode = MBV_VIEW_OFF;
		mbv_primary_colortable = MBV_COLORTABLE_HAXBY;
		mbv_primary_colortable_mode = MBV_COLORTABLE_NORMAL;
		mbv_primary_colortable_min = mbv_primary_min;
		mbv_primary_colortable_max = mbv_primary_max;
		mbv_slope_colortable = MBV_COLORTABLE_HAXBY;
		mbv_slope_colortable_mode = MBV_COLORTABLE_REVERSED;
		mbv_slope_colortable_min = 0.0;
		mbv_slope_colortable_max = 0.5;
		mbv_secondary_colortable = MBV_COLORTABLE_HAXBY;
		mbv_secondary_colortable_mode = MBV_COLORTABLE_NORMAL;
		mbv_secondary_colortable_min = 0.0;
		mbv_secondary_colortable_max = 0.0;
		mbv_exageration = 1.0;
		mbv_modelelevation3d = 90.0;
		mbv_modelazimuth3d = 0.0;
		mbv_viewelevation3d = 90.0;
		mbv_viewazimuth3d = 0.0;
		mbv_illuminate_magnitude = 5.0;
		mbv_illuminate_elevation = 30.0;
		mbv_illuminate_azimuth = 90.0;
		mbv_slope_magnitude = 1.0;
		mbv_overlay_shade_magnitude = 1.0;
		mbv_overlay_shade_center = 0.0;
		mbv_overlay_shade_mode = MBV_COLORTABLE_NORMAL;
		mbv_contour_interval
			= pow(10.0, floor(log10(mbv_primary_max 
						- mbv_primary_min)) - 1.0);

		/* set the display projection */
		/* if grid projected then use the same projected coordinate system by default */
		if (mbv_primary_grid_projection_mode == MBV_PROJECTION_PROJECTED)
			{
			mbv_display_projection_mode = mbv_primary_grid_projection_mode;
			strcpy(mbv_display_projection_id,mbv_primary_grid_projection_id);
			}
			
		/* else if grid geographic and covers much of the world use spheroid */
		else if (mbv_primary_xmax - mbv_primary_xmin > 15.0
			|| mbv_primary_ymax - mbv_primary_ymin > 15.0)
			{
			mbv_display_projection_mode = MBV_PROJECTION_SPHEROID;
			sprintf(mbv_display_projection_id, "SPHEROID", projectionid);
			}
			
		/* else if grid geographic then use appropriate UTM zone for non-polar grids */
		else if (mbv_primary_ymax > -80.0
			&& mbv_primary_ymin < 84.0)
			{
			mbv_display_projection_mode = MBV_PROJECTION_PROJECTED;
			reference_lon = 0.5 * (mbv_primary_xmin + mbv_primary_xmax);
			if (reference_lon > 180.0)
				reference_lon -= 360.0;
			utmzone = (int)(((reference_lon + 183.0)
					/ 6.0) + 0.5);
			if (0.5 * (mbv_primary_ymin + mbv_primary_ymax) >= 0.0)
				projectionid = 32600 + utmzone;
			else
				projectionid = 32700 + utmzone;
			sprintf(mbv_display_projection_id, "epsg%d", projectionid);
			}
			
		/* else if grid geographic and more northerly than 84 deg N then use 
			North Univeral Polar Stereographic Projection */
		else if (mbv_primary_ymin > 84.0)
			{
			mbv_display_projection_mode = MBV_PROJECTION_PROJECTED;
			projectionid = 32661;
			sprintf(mbv_display_projection_id, "epsg%d", projectionid);
			}

		/* else if grid geographic and more southerly than 80 deg S then use 
			South Univeral Polar Stereographic Projection */
		else if (mbv_primary_ymax < 80.0)
			{
			mbv_display_projection_mode = MBV_PROJECTION_PROJECTED;
			projectionid = 32761;
			sprintf(mbv_display_projection_id, "epsg%d", projectionid);
			}

		/* else just use geographic */
		else
			{
			mbv_display_projection_mode = MBV_PROJECTION_GEOGRAPHIC;
			sprintf(mbv_display_projection_id, "epsg%d", GCS_WGS_84);
			}

		/* set basic mbview view controls */
		if (status == MB_SUCCESS)
		status = mbview_setviewcontrols(verbose, instance,
					mbv_display_mode,
					mbv_mouse_mode,
					mbv_grid_mode,
					mbv_primary_shade_mode,
					mbv_slope_shade_mode,
					mbv_secondary_shade_mode,
					mbv_grid_contour_mode,
					mbv_site_view_mode,
					mbv_route_view_mode,
					mbv_nav_view_mode,
					mbv_navdrape_view_mode,
					mbv_exageration,
					mbv_modelelevation3d,
					mbv_modelazimuth3d,
					mbv_viewelevation3d,
					mbv_viewazimuth3d,
					mbv_illuminate_magnitude,
					mbv_illuminate_elevation,
					mbv_illuminate_azimuth,
					mbv_slope_magnitude,
					mbv_overlay_shade_magnitude,
					mbv_overlay_shade_center,
					mbv_overlay_shade_mode,
					mbv_contour_interval,
					mbv_display_projection_mode,
					mbv_display_projection_id,
					&error);
		

		/* set more mbview control values */
		if (status == MB_SUCCESS)
		status = mbview_setprimarygrid(verbose, instance,
					mbv_primary_grid_projection_mode,
					mbv_primary_grid_projection_id,
					mbv_primary_nodatavalue,
					mbv_primary_nx,
					mbv_primary_ny,
					mbv_primary_min,
					mbv_primary_max,
					mbv_primary_xmin,
					mbv_primary_xmax,
					mbv_primary_ymin,
					mbv_primary_ymax,
					mbv_primary_dx,
					mbv_primary_dy,
					mbv_primary_data,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_setprimarycolortable(verbose, instance,
					mbv_primary_colortable,
					mbv_primary_colortable_mode,
					mbv_primary_colortable_min,
					mbv_primary_colortable_max,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_setslopecolortable(verbose, instance,
					mbv_slope_colortable,
					mbv_slope_colortable_mode,
					mbv_slope_colortable_min,
					mbv_slope_colortable_max,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_enableeditsites(verbose, instance,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_enableeditroutes(verbose, instance,
					&error);

		/* open up mbview window */
		if (status == MB_SUCCESS)
			{
fprintf(stderr,"about to open mbview instance:%d\n",instance);
			status = mbview_open(verbose, instance, &error);
			if (status == MB_SUCCESS)
				mbview_id[instance] = MB_YES;
			else
				mbview_id[instance] = MB_NO;
fprintf(stderr,"done opening mbview instance:%d\n",instance);

			/* add action button */
			if (status == MB_SUCCESS)
				{
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_openoverlay,
					"Open Overlay Grid", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_opensite,
					"Open Site File", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_openroute,
					"Open Route File", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_opennav,
					"Open Navigation", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_openswath,
					"Open Swath Data", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_savesite,
					"Save Site File", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_saveroute,
					"Save Route File", 
					MBV_PICKMASK_NONE, &error);

				mbview_addaction(verbose, instance,
					do_mbgrdviz_open_region,
					"Open Region as New View", 
					MBV_PICKMASK_REGION, &error);
				}
			}

		}
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_openoverlay(int instance, char *input_file_ptr)
{
	char function_name[] = "do_mbgrdviz_openoverlay";
	int	status = MB_SUCCESS;
	char    *button_name_ptr;
	double	xx, yy;
	int	i, j, k;
        Cardinal ac = 0;
        Arg      args[256];
        Cardinal cdc = 0;
        Boolean  argok = False;
        XmString    tmp0;
	char	*testname = "Internal Test Grid";
	
	/* mbview parameters */
	int	mbv_secondary_colortable;
	int	mbv_secondary_colortable_mode;
	double	mbv_secondary_colortable_min;
	double	mbv_secondary_colortable_max;
	int	mbv_secondary_grid_projection_mode;
	char	mbv_secondary_grid_projection_id[MB_PATH_MAXLINE];
	float	mbv_secondary_nodatavalue;
	int	mbv_secondary_nxy;
	int	mbv_secondary_nx;
	int	mbv_secondary_ny;
	double	mbv_secondary_min;
	double	mbv_secondary_max;
	double	mbv_secondary_xmin;
	double	mbv_secondary_xmax;
	double	mbv_secondary_ymin;
	double	mbv_secondary_ymax;
	double	mbv_secondary_dx;
	double	mbv_secondary_dy;
	float	*mbv_secondary_data;
	double	mbv_overlay_shade_magnitude;
	double	mbv_overlay_shade_center;
	int	mbv_overlay_shade_mode;

	/* read data for valid instance */
	if (instance >= 0)
		{
		
		/* read in the grd file */
		if (status == MB_SUCCESS
			&& input_file_ptr != NULL)
		status = do_mbgrdviz_readgrd(instance, input_file_ptr,
			&mbv_secondary_grid_projection_mode,
			mbv_secondary_grid_projection_id,
			&mbv_secondary_nodatavalue,
			&mbv_secondary_nxy,
			&mbv_secondary_nx,
			&mbv_secondary_ny,
			&mbv_secondary_min,
			&mbv_secondary_max,
			&mbv_secondary_xmin,
			&mbv_secondary_xmax,
			&mbv_secondary_ymin,
			&mbv_secondary_ymax,
			&mbv_secondary_dx,
			&mbv_secondary_dy,
			&mbv_secondary_data);
			
		else if (status == MB_SUCCESS)
		status = do_mbgrdviz_opentest(instance, 
			1000.0, 6.0, 1.5, 
			&mbv_secondary_grid_projection_mode,
			mbv_secondary_grid_projection_id,
			&mbv_secondary_nodatavalue,
			&mbv_secondary_nxy,
			&mbv_secondary_nx,
			&mbv_secondary_ny,
			&mbv_secondary_min,
			&mbv_secondary_max,
			&mbv_secondary_xmin,
			&mbv_secondary_xmax,
			&mbv_secondary_ymin,
			&mbv_secondary_ymax,
			&mbv_secondary_dx,
			&mbv_secondary_dy,
			&mbv_secondary_data);

		/* set parameters */
		mbv_secondary_colortable = MBV_COLORTABLE_HAXBY;
		mbv_secondary_colortable_mode = MBV_COLORTABLE_NORMAL;
		mbv_secondary_colortable_min = mbv_secondary_min;
		mbv_secondary_colortable_max = mbv_secondary_max;
		mbv_overlay_shade_magnitude = 1.0;
		mbv_overlay_shade_center = 0.5 * (mbv_secondary_max + mbv_secondary_min);
		mbv_overlay_shade_mode = MBV_COLORTABLE_NORMAL;

		/* set more mbview control values */
		if (status == MB_SUCCESS)
		status = mbview_setsecondarygrid(verbose, instance,
					mbv_secondary_grid_projection_mode,
					mbv_secondary_grid_projection_id,
					mbv_secondary_nodatavalue,
					mbv_secondary_nx,
					mbv_secondary_ny,
					mbv_secondary_min,
					mbv_secondary_max,
					mbv_secondary_xmin,
					mbv_secondary_xmax,
					mbv_secondary_ymin,
					mbv_secondary_ymax,
					mbv_secondary_dx,
					mbv_secondary_dy,
					mbv_secondary_data,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_setsecondarycolortable(verbose, instance,
					mbv_secondary_colortable,
					mbv_secondary_colortable_mode,
					mbv_secondary_colortable_min,
					mbv_secondary_colortable_max,
					mbv_overlay_shade_magnitude,
					mbv_overlay_shade_center,
					mbv_overlay_shade_mode,
					&error);
					
		/* update widgets */
		if (status == MB_SUCCESS)
		status = mbview_update(verbose, instance, &error);

		}
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_opensite(int instance, char *input_file_ptr)
{
	char function_name[] = "do_mbgrdviz_opensite";
	int	status = MB_SUCCESS;
	FILE	*sfp;
	char	buffer[MB_PATH_MAXLINE];
	int	nsite;
	double	*sitelon;
	double	*sitelat;
	double	*sitetopo;
	int	*sitecolor;
	int	*sitesize;
	mb_path	*sitename;
	char	*result;
	char	*name;
	int	nget;
	int	site_ok;
	int	i;

	/* read data for valid instance */
	if (instance >= 0)
	    {

	    /* count the sites in the input file */
	    nsite = 0;
	    if ((sfp = fopen(input_file_ptr, "r")) == NULL) 
		    {
		    error = MB_ERROR_OPEN_FAIL;
		    fprintf(stderr,"\nUnable to Open Site File <%s> for reading\n",input_file_ptr);
		    XBell((Display *) XtDisplay(mainWindow),100);
		    return(MB_FAILURE);
		    }
	    while ((result = fgets(buffer,MB_PATH_MAXLINE,sfp)) == buffer)
		    {
		    if (buffer[0] != '#')
		    	nsite++;
		    }
	    fclose(sfp);
	    
	    /* allocate arrays for sites */
	    if (nsite > 0)
		{
		/* allocate the arrays */
		sitelon = NULL;
		sitelat = NULL;
		sitetopo = NULL;
		sitecolor = NULL;
		sitesize = NULL;
		sitename = NULL;
		status = mbview_allocsitearrays(verbose, 
			nsite, &sitelon, &sitelat, &sitetopo,
			&sitecolor, &sitesize, &sitename, &error);

		/* if error initializing memory then cancel dealing with sites */
		if (status == MB_FAILURE)
			{
			nsite = 0;		    
			fprintf(stderr,"\nUnable to allocate arrays for %d sites\n",nsite);
			XBell((Display *) XtDisplay(mainWindow),100);
			return(status);
			}
		}
		
	    /* read the sites from the input file */
	    if (nsite > 0)
	    	{
		nsite = 0;
		if ((sfp = fopen(input_file_ptr, "r")) == NULL) 
			{
			error = MB_ERROR_OPEN_FAIL;
			status = MB_FAILURE;
			fprintf(stderr,"\nUnable to open site file <%s> for reading\n",input_file_ptr);
			XBell((Display *) XtDisplay(mainWindow),100);
			return(status);
			}
		while ((result = fgets(buffer,MB_PATH_MAXLINE,sfp)) == buffer)
		    {
		    site_ok = MB_NO;

		    /* deal with site in form: lon lat topo color size name */
		    if (buffer[0] != '#')
		    	{
			nget = sscanf(buffer,"%lf %lf %lf %d %d %[^\n]",
			    &sitelon[nsite], &sitelat[nsite], &sitetopo[nsite], 
			    &sitecolor[nsite], &sitesize[nsite],
			    &sitename[nsite]);
fprintf(stderr,"nget:%d\n",nget);
		    	if (nget >= 2)
			    site_ok = MB_YES;
			}
		    if (site_ok == MB_YES)
			{
		    	if (nget < 6)
		    	    {
			    name = (char *) sitename[nsite];
			    name[0] = '\0';
			    }
		    	if (nget < 5)
			    sitesize[nsite] = 0;
		    	if (nget < 4)
			    sitecolor[nsite] = 0;
		    	if (nget < 3)
			    sitetopo[nsite] = MBV_DEFAULT_NODATA;
			}

		    /* output some debug values */
		    if (verbose >= 0 && site_ok == MB_YES)
			    {
			    fprintf(stderr,"\ndbg5  Site point read in program <%s>\n",program_name);
			    fprintf(stderr,"dbg5       site[%d]: %f %f %f  %d %d  %s\n",
				    nsite,sitelon[nsite],sitelat[nsite],sitetopo[nsite],
				    sitecolor[nsite],sitesize[nsite],
				    sitename[nsite]);
			    }
		    else if (verbose >= 0 && site_ok == MB_NO)
			    {
			    fprintf(stderr,"\ndbg5  Unintelligible line read from site file in program <%s>\n",program_name);
			    fprintf(stderr,"dbg5       buffer:  %s\n",
				   buffer);
			    }

		    strncpy(buffer,"\0",sizeof(buffer));
		    if (site_ok == MB_YES)
		    	nsite++;
		    }
		fclose(sfp);
		}
	    
	    /* add the sites */
	    if (nsite > 0)
	    	{
	    	status = mbview_addsites(verbose, instance,
			nsite, sitelon, sitelat, sitetopo, 
			sitecolor, sitesize, sitename,
			&error);

	    	/* update widgets */
	    	if (status == MB_SUCCESS)
	    	status = mbview_update(verbose, instance, &error);
		}
	    
	    /* deallocate memory */
	    if (nsite > 0)
	    	{
		status = mbview_freesitearrays(verbose, 
			&sitelon, &sitelat, &sitetopo,
			&sitecolor, &sitesize, &sitename, &error);
		}

	    }
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_savesite(int instance, char *output_file_ptr)
{
	char function_name[] = "do_mbgrdviz_savesite";
	int	status = MB_SUCCESS;
	FILE	*sfp;
	char	buffer[MB_PATH_MAXLINE];
	int	nsite;
	double	*sitelon;
	double	*sitelat;
	double	*sitetopo;
	int	*sitecolor;
	int	*sitesize;
	mb_path	*sitename;
	char	*result;
	char	*name;
	int	nget;
	int	site_ok;
	int	i;

	/* time, user, host variables */
	time_t	right_now;
	char	date[25], *user_ptr, host[MB_PATH_MAXLINE];
	char	*unknown = "Unknown";

	/* read data for valid instance */
	if (instance >= 0)
	    {

	    /* get the number of sites to be written to the outpuf file */
	    status = mbview_getsitecount(verbose, instance, &nsite, &error);
	    if (status == MB_SUCCESS && nsite <= 0)
	    	{
		fprintf(stderr,"Unable to write site file...\nCurrently %d sites defined for instance %d!\n",
			nsite, instance);
		XBell((Display *) XtDisplay(mainWindow),100);
		status = MB_FAILURE;
		}
	    
	    /* allocate arrays for sites */
	    if (status == MB_SUCCESS && nsite > 0)
		{
		/* allocate the arrays */
		sitelon = NULL;
		sitelat = NULL;
		sitetopo = NULL;
		sitecolor = NULL;
		sitesize = NULL;
		sitename = NULL;
		status = mbview_allocsitearrays(verbose, 
			nsite, &sitelon, &sitelat, &sitetopo,
			&sitecolor, &sitesize, &sitename, &error);

		/* if error initializing memory then cancel dealing with sites */
		if (status == MB_FAILURE)
	    		{
			nsite = 0;		    
			fprintf(stderr,"Unable to write site file...\nArray allocation for %d sites failed for instance %d!\n",
				nsite, instance);
			XBell((Display *) XtDisplay(mainWindow),100);
			}
		}
	    
	    /* get the sites */
	    if (status == MB_SUCCESS)
	    	{
	    	status = mbview_getsites(verbose, instance,
			&nsite, sitelon, sitelat, sitetopo, 
			sitecolor, sitesize, sitename,
			&error);
		}
		
	    /* write the sites to the output file */
	    if (status == MB_SUCCESS)
	    	{
		/* open the output file */
		if ((sfp = fopen(output_file_ptr, "w")) != NULL) 
			{
			/* write the site file header */
			fprintf(sfp, "## Site File Version %s\n", MBGRDVIZ_SITE_VERSION);
			fprintf(sfp, "## Output by Program %s\n",program_name); 
			fprintf(sfp, "## Program Version %s\n",rcs_id);
			fprintf(sfp, "## MB-System Version %s\n",MB_VERSION);
			strncpy(date,"\0",25);
			right_now = time((time_t *)0);
			strncpy(date,ctime(&right_now),24);
			if ((user_ptr = getenv("USER")) == NULL)
				if ((user_ptr = getenv("LOGNAME")) == NULL)
					user_ptr = unknown;
			gethostname(host,MB_PATH_MAXLINE);
			fprintf(sfp, "## Run by user <%s> on cpu <%s> at <%s>\n",
				user_ptr,host,date);
			fprintf(sfp, "## Number of sites: %d\n",nsite); 
			
			/* loop over the sites */
			for (i=0;i<nsite;i++)
				{
				fprintf(sfp,"%12.7f %12.7f %10.3f %2d %2d %s\n",
			 	   	sitelon[i], sitelat[i], sitetopo[i], 
			    		sitecolor[i], sitesize[i],
			    		sitename[i]);
				
				}

			/* close the output file */
			fclose(sfp);
			}
			
		/* output error message */
		else
			{
			error = MB_ERROR_OPEN_FAIL;
			fprintf(stderr,"\nUnable to Open Site File <%s> for writing\n",output_file_ptr);
			XBell((Display *) XtDisplay(mainWindow),100);
			status = MB_FAILURE;
			}
		}
	    
	    /* deallocate arrays for sites */
	    if (nsite > 0)
	    	{
		status = mbview_freesitearrays(verbose, 
			&sitelon, &sitelat, &sitetopo,
			&sitecolor, &sitesize, &sitename, &error);
		}

	    }
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_openroute(int instance, char *input_file_ptr)
{
	char function_name[] = "do_mbgrdviz_openroute";
	int	status = MB_SUCCESS;
	FILE	*sfp;
	char	buffer[MB_PATH_MAXLINE];
	int	npoint = 0;
	int	npointalloc = 0;
	double	*routelon = NULL;
	double	*routelat = NULL;
	double	lon, lat, topo;
	int	waypoint;
	int	routecolor;
	int	routesize;
	mb_path	routename;
	int	rawroutefile = MB_YES;
	char	*result;
	char	*name;
	int	nget;
	int	point_ok;
	int	i;

	/* read data for valid instance */
	if (instance >= 0)
	    {
	    /* initialize route values */
	    routecolor = MBV_COLOR_BLUE;
	    routesize = 1;
	    routename[0] = '\0';
	    rawroutefile = MB_YES;
	    npoint = 0;
	    npointalloc = 0;
	    
	    /* open the input file */
	    if ((sfp = fopen(input_file_ptr, "r")) == NULL) 
		    {
		    error = MB_ERROR_OPEN_FAIL;
		    status == MB_FAILURE;
		    fprintf(stderr,"\nUnable to open route file <%s> for reading\n",input_file_ptr);
		    XBell((Display *) XtDisplay(mainWindow),100);
		    }

	    /* loop over reading */
	    if (status == MB_SUCCESS)
	    	{
		while ((result = fgets(buffer,MB_PATH_MAXLINE,sfp)) == buffer)
		    {
		    /* deal with comments */
fprintf(stderr,"Route Buffer: %s",buffer);
		    if (buffer[0] == '#')
		    	{
			if (rawroutefile == MB_YES
				&& strncmp(buffer,"## Route File Version", 21) == 0)
				rawroutefile = MB_NO;
			else if (strncmp(buffer,"## ROUTENAME", 12) == 0)
				sscanf(buffer,"## ROUTENAME %[^\n]", routename);
			else if (strncmp(buffer,"## ROUTECOLOR", 12) == 0)
				sscanf(buffer,"## ROUTENAME %d", &routecolor);
			else if (strncmp(buffer,"## ROUTESIZE", 12) == 0)
				sscanf(buffer,"## ROUTENAME %d", &routesize);
			}
		
		    /* deal with route segment marker */
		    else if (buffer[0] == '>')
		    	{
			/* if data accumulated call mbview_addroute() */
			if (npoint > 0)
			    {
			    status = mbview_addroute(2, instance,
			    				npoint, routelon, routelat,
							routecolor, routesize, routename,
							&error);
			    npoint = 0;
			    }
			}
			
		    /* deal with data */
		    else
		        {
			/* read the data from the buffer */
			nget = sscanf(buffer,"%lf %lf %lf %d",
			    &lon, &lat, &topo, &waypoint);
		    	if ((rawroutefile == MB_YES && nget >= 2)
				|| (rawroutefile == MB_NO && nget >= 3 && waypoint == MB_YES))
			    point_ok = MB_YES;
			else
			    point_ok = MB_NO;
			    
			/* if good data check for need to allocate more space */
			if (point_ok == MB_YES
				&& npoint + 1 > npointalloc)
			    {
			    npointalloc += MBV_ALLOC_NUM;
			    status = mbview_allocroutearrays(2, 
						    npointalloc,
						    &routelon,
						    &routelat,
						    NULL,
						    NULL,
						    NULL,
						    NULL,
						    NULL,
						    &error);
			    if (status != MB_SUCCESS)
				    {
				    npointalloc = 0;
				    }
			    }
			    
			/* add good point to route */
			if (point_ok == MB_YES && npointalloc > npoint + 1)
			    {
			    routelon[npoint] = lon;
			    routelat[npoint] = lat;
			    npoint++;
			    }
			}
		    }
		    
		/* add last route if not already handled */
		if (npoint > 0)
		    {
		    status = mbview_addroute(2, instance,
			    			npoint, routelon, routelat,
						routecolor, routesize, routename,
						&error);
		    npoint = 0;
		    }
		    
		/* free the memory */
		if (npointalloc > 0)
		status = mbview_freeroutearrays(verbose, 
						    &routelon,
						    &routelat,
						    NULL,
						    NULL,
						    NULL,
						    NULL,
						    NULL,
						    &error);

		/* close the input file */
		fclose(sfp);
		}

	    /* update widgets */
	    if (status == MB_SUCCESS)
	    status = mbview_update(verbose, instance, &error);
	    }
			
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_saveroute(int instance, char *output_file_ptr)
{
	char function_name[] = "do_mbgrdviz_saveroute";
	int	status = MB_SUCCESS;
	FILE	*sfp;
	char	buffer[MB_PATH_MAXLINE];
	int	nroute = 0;
	int	npoint = 0;
	int	nintpoint = 0;
	int	npointtotal = 0;
	int	npointalloc = 0;
	double	*routelon = NULL;
	double	*routelat = NULL;
	int	*waypoint = NULL;
	double	*routetopo = NULL;
	double	*distlateral = NULL;
	double	*distovertopo = NULL;
	double	*slope = NULL;
	int	routecolor;
	int	routesize;
	mb_path	routename;
	int	iroute, j;

	/* time, user, host variables */
	time_t	right_now;
	char	date[25], *user_ptr, host[MB_PATH_MAXLINE];
	char	*unknown = "Unknown";

	/* read data for valid instance */
	if (instance >= 0)
	    {

	    /* get the number of routes to be written to the outpuf file */
	    status = mbview_getroutecount(verbose, instance, &nroute, &error);
	    if (nroute <= 0)
	    	{
		fprintf(stderr,"Unable to write route file...\nCurrently %d routes defined for instance %d!\n",
			nroute, instance);
		XBell((Display *) XtDisplay(mainWindow),100);
		status = MB_FAILURE;
		}
		
	    /* initialize the output file */
	    if (status == MB_SUCCESS && nroute > 0)
	    	{
		/* open the output file */
		if ((sfp = fopen(output_file_ptr, "w")) != NULL) 
			{
			/* write the route file header */
			fprintf(sfp, "## Route File Version %s\n", MBGRDVIZ_ROUTE_VERSION);
			fprintf(sfp, "## Output by Program %s\n",program_name); 
			fprintf(sfp, "## Program Version %s\n",rcs_id);
			fprintf(sfp, "## MB-System Version %s\n",MB_VERSION);
			strncpy(date,"\0",25);
			right_now = time((time_t *)0);
			strncpy(date,ctime(&right_now),24);
			if ((user_ptr = getenv("USER")) == NULL)
				if ((user_ptr = getenv("LOGNAME")) == NULL)
					user_ptr = unknown;
			gethostname(host,MB_PATH_MAXLINE);
			fprintf(sfp, "## Run by user <%s> on cpu <%s> at <%s>\n",
				user_ptr,host,date);
			fprintf(sfp, "## Number of routes: %d\n",nroute); 
			fprintf(sfp, "## Route point format:\n"); 
			fprintf(sfp, "##   <longitude (deg)> <latitude (deg)> <waypoint (boolean)> <topography (m)> <lateral distance (m)> <distance along topography (m)> <slope (m/m)>\n"); 
			}
			
		/* output error message */
		else
			{
			error = MB_ERROR_OPEN_FAIL;
			status = MB_FAILURE;
			fprintf(stderr,"\nUnable to Open route file <%s> for writing\n",output_file_ptr);
			XBell((Display *) XtDisplay(mainWindow),100);
			}
		}
	    
	    /* if all ok proceed to extract and output routes */
	    if (status == MB_SUCCESS)
	    	{
	        /* loop over routes */
		for (iroute=0;iroute<nroute;iroute++)
	    	    {
		    /* get point count for current route */
		    status = mbview_getroutepointcount(verbose, instance,
			    iroute, &npoint, &nintpoint, &error);

		    /* allocate route arrays */
		    npointtotal = npoint + nintpoint;
		    if (status == MB_SUCCESS
			    && npointalloc < npointtotal)
			    {
			    status = mbview_allocroutearrays(verbose, 
						    npointtotal,
						    &routelon,
						    &routelat,
						    &waypoint,
						    &routetopo,
						    &distlateral,
						    &distovertopo,
						    &slope,
						    &error);
			    if (status == MB_SUCCESS)
				    {
				    npointalloc = npointtotal;
				    }

			    /* if error initializing memory then cancel dealing with this route */
			    else
	    			    {
				    fprintf(stderr,"Unable to write route...\nArray allocation for %d points failed for instance %d!\n",
					    npointtotal, instance);
				    XBell((Display *) XtDisplay(mainWindow),100);
				    npoint = 0;		    
				    nintpoint = 0;		    
				    npointtotal = 0;		    
				    }
			    }

		    /* extract data for route */
		    status = mbview_getroute(verbose, instance,
					    iroute,
					    &npointtotal,
					    routelon,
					    routelat,
					    waypoint,
					    routetopo,
					    distlateral,
					    distovertopo,
					    slope,
					    &routecolor,
					    &routesize,
					    routename,
					    &error);

		    /* write the route header */
		    fprintf(sfp,"## ROUTENAME %s\n", routename);
		    fprintf(sfp,"## ROUTESIZE %d\n", routesize);
		    fprintf(sfp,"## ROUTECOLOR %d\n", routecolor);
		    fprintf(sfp,"## ROUTEPOINTS %d\n", npointtotal);
		    fprintf(sfp,"> ## STARTROUTE\n");

		    /* write the route points */
		    for (j=0;j<npointtotal;j++)
			    {
			    fprintf(sfp,"%f %f %f %d %f %f %f",
				    routelon[j], routelat[j], routetopo[j],
				    waypoint[j],
				    distlateral[j], distovertopo[j], slope[j]);
			    if (waypoint[j] == MB_YES)
			    	fprintf(sfp," ## WAYPOINT\n");
			    else
			    	fprintf(sfp,"\n");
			    }

		    /* write the route end */
		    fprintf(sfp,"> ## ENDROUTE\n");
		    }

		/* close the output file */
		fclose(sfp);

		/* deallocate arrays */
		if (npointalloc > 0)
	    	    {
		    status = mbview_freeroutearrays(verbose, 
					    &routelon,
					    &routelat,
					    &waypoint,
					    &routetopo,
					    &distlateral,
					    &distovertopo,
					    &slope,
					    &error);
		    }
		}
	    }
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_opennav(int instance, int swathbounds, char *input_file_ptr)
{
	char function_name[] = "do_mbgrdviz_opennav";
	int	status = MB_SUCCESS;
	void	*datalist;
	mb_path	swathfile;
	int	format;
	double	weight;
	int	done;

	/* read data for valid instance */
	if (instance >= 0)
	    {
	    done = MB_NO;
	    while (done == MB_NO)
		{
		if (status = mb_datalist_open(verbose,&datalist,
						input_file_ptr,
						MB_DATALIST_LOOK_NO,&error) == MB_SUCCESS)
			{
			while (done == MB_NO)
				{
				if (status = mb_datalist_read(verbose,datalist,
						swathfile,&format,&weight,&error)
						== MB_SUCCESS
					&& format != MBF_ASCIIXYZ
					&& format != MBF_ASCIIYXZ)
					{

					/* check for available nav file if that is
					   all that is needed */
					if (swathbounds == MB_NO)
						mb_get_fnv(verbose, swathfile, &format, &error);

					/* else check for available fbt file  */
					else
						mb_get_fbt(verbose, swathfile, &format, &error);

					/* read the swath or nav data using mbio calls */
					do_mbgrdviz_readnav(instance, swathfile, 
								format, weight, &error);
					}
				else
					{
					mb_datalist_close(verbose,&datalist,&error);
					done = MB_YES;
					}
				}
			}
		}

	    /* update widgets */
	    mbview_enableviewnavs(verbose, instance, &error);
	    status = mbview_update(verbose, instance, &error);
	    }
			
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_readnav(int instance, char *swathfile, int format, double weight, int *error)
{
	char function_name[] = "do_mbgrdviz_readnav";
	int	status = MB_SUCCESS;
	char	*error_message;

	/* MBIO control parameters */
	int	pings = 1;
	int	lonflip;
	double	bounds[4];
	int	btime_i[7];
	int	etime_i[7];
	double	btime_d;
	double	etime_d;
	double	speedmin;
	double	timegap;
	int	beams_bath;
	int	beams_amp;
	int	pixels_ss;
	void	*mbio_ptr = NULL;

	/* mbio read and write values */
	void	*store_ptr = NULL;
	int	kind;
	int	time_i[7];
	double	time_d;
	double	lon;
	double	lat;
	double	speed;
	double	heading;
	double	distance;
	double	altitude;
	double	sonardepth;
	double	draft;
	double	roll;
	double	pitch;
	double	heave;
	int	nbath;
	int	namp;
	int	nss;
	char	*beamflag = NULL;
	double	*bath = NULL;
	double	*bathacrosstrack = NULL;
	double	*bathalongtrack = NULL;
	double	*amp = NULL;
	double	*ss = NULL;
	double	*ssacrosstrack = NULL;
	double	*ssalongtrack = NULL;
	char	comment[256];

	int	npoint;
	int	npointalloc;
	double	*navtime_d = NULL;
	double	*navlon = NULL;
	double	*navlat = NULL;
	double	*navz = NULL;
	double	*navheading = NULL;
	double	*navspeed = NULL;
	double	*navportlon = NULL;
	double	*navportlat = NULL;
	double	*navstbdlon = NULL;
	double	*navstbdlat = NULL;
	int	*navcdp = NULL;
	int	*navshot = NULL;
	int	color;
	int	size;
	mb_path	name;
	int	swathbounds;
	int	shot;
	int	cdp;

	struct mbview_struct *data;
	
	double	mtodeglon, mtodeglat;
	double	headingx, headingy;
	double	xd, yd;

	int	form;
	int	icenter, iport, istbd;
	double	centerdistance, portdistance, stbddistance;
	char	*lastslash;
	int	i;
	
	*error = MB_ERROR_NO_ERROR;

	/* initialize nav values */
	color = MBV_COLOR_BLACK;
	size = 2;
	name[0] = '\0'; 
	lastslash = strrchr(swathfile, '/');
	if ((lastslash = strrchr(swathfile, '/')) != NULL)
		strcpy(name,&(lastslash[1]));
	else
		strcpy(name,swathfile);

	swathbounds = MB_NO;
	shot = MB_NO;
	cdp = MB_NO;
	npoint = 0;
	npointalloc = 0;

	/* set mbio default values */
	status = mb_defaults(verbose,&form,&pings,&lonflip,bounds,
		btime_i,etime_i,&speedmin,&timegap);

	/* get data structure of current instance */
	status = mbview_getdataptr(verbose, instance, &data, error);
	if (status == MB_SUCCESS)
		{
		bounds[0] = data->primary_xmin;
		bounds[1] = data->primary_xmax;
		bounds[2] = data->primary_ymin;
		bounds[3] = data->primary_ymax;
		status = mbview_projectforward(instance, MB_YES,
				data->primary_xmin, data->primary_ymin,
				&bounds[0], &bounds[2],
				&xd, &yd);
		status = mbview_projectforward(instance, MB_YES,
				data->primary_xmax, data->primary_ymax,
				&bounds[1], &bounds[3],
				&xd, &yd);

		}
	
	/* initialize reading the swath file */
	if ((status = mb_read_init(
		verbose,swathfile,format,pings,lonflip,bounds,
		btime_i,etime_i,speedmin,timegap,
		&mbio_ptr,&btime_d,&etime_d,
		&beams_bath,&beams_amp,&pixels_ss,error)) != MB_SUCCESS)
		{
		mb_error(verbose,*error,&error_message);
		fprintf(stderr,"\nMBIO Error returned from function <mb_read_init>:\n%s\n",error_message);
		fprintf(stderr,"\nSwath sonar File <%s> not initialized for reading\n",swathfile);
		}

	/* allocate memory for data arrays */
	if (status == MB_SUCCESS)
		{
		status = mb_malloc(verbose,beams_bath*sizeof(char),
					&beamflag,error);
		if (status == MB_SUCCESS)
			status = mb_malloc(verbose,beams_bath*sizeof(double),
						&bath,error);
		if (status == MB_SUCCESS)
			status = mb_malloc(verbose,beams_bath*sizeof(double),
						&bathacrosstrack,error);
		if (status == MB_SUCCESS)
			status = mb_malloc(verbose,beams_bath*sizeof(double),
						&bathalongtrack,error);
		if (status == MB_SUCCESS)
			status = mb_malloc(verbose,beams_amp*sizeof(double),
						&amp,error);
		if (status == MB_SUCCESS)
			status = mb_malloc(verbose,pixels_ss*sizeof(double),
						&ss,error);
		if (status == MB_SUCCESS)
			status = mb_malloc(verbose,pixels_ss*sizeof(double),
						&ssacrosstrack,error);
		if (status == MB_SUCCESS)
			status = mb_malloc(verbose,pixels_ss*sizeof(double),
						&ssalongtrack,error);

		/* if error initializing memory then don't read the file */
		if (*error != MB_ERROR_NO_ERROR)
			{
			mb_error(verbose,*error,&error_message);
			fprintf(stderr,"\nMBIO Error allocating data arrays:\n%s\n",
				error_message);
			}
 		}


	/* read data */
	if (status == MB_SUCCESS)
		{
		/* set swathbounds true if nore than one beam is expected */
		if (beams_bath > 1)
			swathbounds = MB_YES;
		
		/* loop over successful reads and nonfatal errors 
		   until a fatal error is encountered */
		while (*error <= MB_ERROR_NO_ERROR)
			{
			/* read a ping of data */
			status = mb_get_all(verbose,mbio_ptr,&store_ptr,&kind,
				time_i,&time_d,&lon,&lat,&speed,
				&heading,&distance,&altitude,&sonardepth,
				&beams_bath,&beams_amp,&pixels_ss,
				beamflag,bath,amp,bathacrosstrack,bathalongtrack,
				ss,ssacrosstrack,ssalongtrack,
				comment,error);
				
			/* ignore minor errors */
			if (kind == MB_DATA_DATA
				&& (*error == MB_ERROR_TIME_GAP
					|| *error == MB_ERROR_OUT_TIME
					|| *error == MB_ERROR_SPEED_TOO_SMALL))
				{
				status = MB_SUCCESS;
				*error = MB_ERROR_NO_ERROR;
				}
				
			if (kind == MB_DATA_DATA 
				&& *error == MB_ERROR_NO_ERROR)
				{
/*fprintf(stderr,"Ping %d: %4d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d.%.6.6d %f %f\n",
npoint,time_i[0],time_i[1],time_i[2],time_i[3],time_i[4],time_i[5],time_i[6],lon,lat);*/

				/* allocate memory if required */
				if (npoint >= npointalloc)
					{
					npointalloc += MBV_ALLOC_NUM;
					status = mb_realloc(verbose,npointalloc*sizeof(double),
								&navtime_d,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navlon,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navlat,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navz,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navheading,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navspeed,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navportlon,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navportlat,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navstbdlon,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navstbdlat,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(int),
									&navcdp,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(int),
									&navshot,error);

					/* if error initializing memory then don't read the file */
					if (*error != MB_ERROR_NO_ERROR)
						{
						npointalloc = 0;
						mb_error(verbose,*error,&error_message);
						fprintf(stderr,"\nMBIO Error allocating navigation data arrays:\n%s\n",
							error_message);
						}
					}
					
				/* find centermost beam */
				icenter = -1;
				iport = -1;
				istbd = -1;
				centerdistance = 0.0;
				portdistance = 0.0;
				stbddistance = 0.0;
				for (i=0;i<beams_bath;i++)
					{
					if (mb_beam_ok(beamflag[i]))
						{
						if (icenter == -1
							|| fabs(bathacrosstrack[i]) < centerdistance)
							{
							icenter = i;
							centerdistance = bathacrosstrack[i];
							}
						if (iport == -1
							|| bathacrosstrack[i] < portdistance)
							{
							iport = i;
							portdistance = bathacrosstrack[i];
							}
						if (istbd == -1
							|| bathacrosstrack[i] > stbddistance)
							{
							istbd = i;
							stbddistance = bathacrosstrack[i];
							}
						}
					}
					
				/* store the navigation values */
				navtime_d[npoint] = time_d;
				navlon[npoint] = lon;
				navlat[npoint] = lat;
				navz[npoint] = -sonardepth;
				navheading[npoint] = heading;
				navspeed[npoint] = speed;

				mb_coor_scale(verbose,lat,&mtodeglon,&mtodeglat);
				headingx = sin(heading * DTR);
				headingy = cos(heading * DTR);
				if (icenter >= 0)
					{
					navportlon[npoint] = lon 
						+ headingy * mtodeglon * bathacrosstrack[iport]
						+ headingx * mtodeglon * bathalongtrack[iport];
					navportlat[npoint] = lat 
						- headingx * mtodeglat * bathacrosstrack[iport]
						+ headingy * mtodeglat * bathalongtrack[iport];
					navstbdlon[npoint] = lon 
						+ headingy * mtodeglon * bathacrosstrack[istbd]
						+ headingx * mtodeglon * bathalongtrack[istbd];
					navstbdlat[npoint] = lat 
						- headingx * mtodeglat * bathacrosstrack[istbd]
						+ headingy * mtodeglat * bathalongtrack[istbd];
					}
				else
					{
					navportlon[npoint] = lon;
					navportlat[npoint] = lat;
					navstbdlon[npoint] = lon;
					navstbdlat[npoint] = lat;
					}
				
				
				navcdp[npoint] = 0;
				navshot[npoint] = 0;
				
				/* increment npoint */
				npoint++;
				}
			}
	
		/* close the swath file */
		status = mb_close(verbose,&mbio_ptr,error);
		
		/* insert nav data to mbview */
		if (npoint > 0)
		status = mbview_addnav(verbose, instance,
				npoint,
				navtime_d,
				navlon,
				navlat,
				navz,
				navheading,
				navspeed,
				navportlon,
				navportlat,
				navstbdlon,
				navstbdlat,
				navcdp,
				navshot,
				color,
				size,
				name,
				swathbounds,
				shot,
				cdp,
				error);

		/* deallocate memory used for data arrays */
		mb_free(verbose,&beamflag,error);
		mb_free(verbose,&bath,error);
		mb_free(verbose,&bathacrosstrack,error);
		mb_free(verbose,&bathalongtrack,error);
		mb_free(verbose,&amp,error);
		mb_free(verbose,&ss,error);
		mb_free(verbose,&ssacrosstrack,error);
		mb_free(verbose,&ssalongtrack,error);

		mb_free(verbose,&navtime_d,error);
		mb_free(verbose,&navlon,error);
		mb_free(verbose,&navlat,error);
		mb_free(verbose,&navz,error);
		mb_free(verbose,&navheading,error);
		mb_free(verbose,&navspeed,error);
		mb_free(verbose,&navportlon,error);
		mb_free(verbose,&navportlat,error);
		mb_free(verbose,&navstbdlon,error);
		mb_free(verbose,&navstbdlat,error);
		mb_free(verbose,&navcdp,error);
		mb_free(verbose,&navshot,error);
		}
			
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_readgrd(int instance, char *grdfile,
			int	*grid_projection_mode,
			char	*grid_projection_id,
			float	*nodatavalue,
			int	*nxy,
			int	*nx,
			int	*ny,
			double	*min,
			double	*max,
			double	*xmin,
			double	*xmax,
			double	*ymin,
			double	*ymax,
			double	*dx,
			double	*dy,
			float	**data)
{
	char function_name[] = "do_mbgrdviz_readgrd";
	int	status = MB_SUCCESS;
	struct GRD_HEADER header;
	int	modeltype;
	int	projectionid;
        char    projectionname[MB_PATH_MAXLINE];
	int	off;
	int	pad[4];
	int	nscan;
	int	utmzone;
        float   NaN;
	char	*projection = "-Jx1.0";
	float	*rawdata;
	float	*usedata;
	int	i,j,k,kk;
	
#ifdef GMT3_0
	gmt_begin (pargc, pargv);
#else
	GMT_begin (pargc, pargv);
	GMT_put_history(pargc, pargv);
#endif

#ifdef GMT3_0
	get_common_args (projection, xmin, xmax, ymin, ymax);
#else
	GMT_get_common_args (projection, xmin, xmax, ymin, ymax);
#endif
 	
#ifdef GMT3_0
	grd_init (&header, pargc, pargv, FALSE);
#else
	GMT_grd_init (&header, pargc, pargv, FALSE);
#endif
#ifndef GMT3_0
	GMT_make_fnan (GMT_f_NaN);
	GMT_make_dnan (GMT_d_NaN);
	GMT_grd_in_nan_value = GMT_grd_out_nan_value = GMT_d_NaN;
#endif
	
	/* read input grd file header */
#ifdef GMT3_0
	if (read_grd_info (grdfile, &header)) 
#else
fprintf(stderr,"calling GMT_read_grd_info: %s header:%d\n",grdfile, header.nx);
	if (GMT_read_grd_info (grdfile, &header)) 
#endif
	    {
	    error = MB_ERROR_OPEN_FAIL;
	    fprintf(stderr,"\nUnable to open grd file: %s\n",
		    grdfile);
	    fprintf(stderr,"\nProgram <%s> Terminated\n",
	    		program_name);
	    exit(error);
	    }
fprintf(stderr,"done calling GMT_read_grd_info: %s header:%d\n",grdfile, header.nx);

	/* set up internal arrays */
    	*nodatavalue = MIN(MBV_DEFAULT_NODATA, header.z_min - 10 * (header.z_max - header.z_min));
    	*nxy = header.nx * header.ny;
    	*nx = header.nx;
    	*ny = header.ny;
    	*xmin = header.x_min; 
    	*xmax = header.x_max; 
    	*ymin = header.y_min; 
    	*ymax = header.y_max; 
    	*dx = header.x_inc;
    	*dy = header.y_inc;
    	*min = header.z_min; 
    	*max = header.z_max; 

    	status = mb_malloc(verbose, sizeof(float) * (*nxy), 
    				&rawdata,
				&error);
    	if (status == MB_SUCCESS)
	status = mb_malloc(verbose, sizeof(float) * (*nxy), 
    				&usedata,
				&error);
	*data = usedata;
	if (status != MB_SUCCESS)
	    {
	    fprintf(stderr,"\nUnable to allocate memory to store data from grd file: %s\n",
		    grdfile);
	    fprintf(stderr,"\nProgram <%s> Terminated\n",
		    program_name);
	    exit(error);
	    }

	/* Determine the wesn to be used to read the grdfile */
	off = (header.node_offset) ? 0 : 1;
#ifdef GMT3_0
	map_setup (*xmin, *xmax, *ymin, *ymax);
	grd_setregion (&header, xmin,  xmax, ymin, ymax);
#else
	GMT_map_setup (*xmin, *xmax, *ymin, *ymax);
	GMT_grd_setregion (&header, xmin,  xmax, ymin, ymax);
#endif	

	/* read the grid */
	pad[0] = 0;
	pad[1] = 0;
	pad[2] = 0;
	pad[3] = 0;
#ifdef GMT3_0
	if (read_grd (grdfile, &header, rawdata, 
			    *xmin, *xmax, *ymin, *ymax, 
			    pad, FALSE))
#else
	if (GMT_read_grd (grdfile, &header, rawdata, 
			    *xmin, *xmax, *ymin, *ymax, 
			    pad, FALSE))
#endif
	    {
	    error = MB_ERROR_OPEN_FAIL;
	    fprintf(stderr,"\nUnable to read grd file: %s\n",
		    grdfile);
	    fprintf(stderr,"\nProgram <%s> Terminated\n",
		    program_name);
	    exit(error);
	    }
	    
	/* reorder grid to internal convention */
	for (i=0;i<*nx;i++)
	for (j=0;j<*ny;j++)
		{
		k = i * *ny + j;
		kk = (*ny - 1 - j) * *nx + i;
		if (check_fnan(rawdata[kk]))
			usedata[k] = *nodatavalue;
		else
			usedata[k] = rawdata[kk];
		}
	mb_free(verbose, &rawdata, &error);
	    
	/* try to get projection from the grd file remark */
	if (strncmp(&(header.remark[2]), "Projection: ", 12) == 0)
		{
		if ((nscan = sscanf(&(header.remark[2]), "Projection: UTM%dN", &utmzone)) == 1)
			{
			sprintf(projectionname, "UTM%dN", utmzone);
			modeltype = ModelTypeProjected;
			projectionid = 32600 + utmzone;
			*grid_projection_mode = MBV_PROJECTION_PROJECTED;
			sprintf(grid_projection_id, "epsg%d", projectionid);
			}
		else if ((nscan = sscanf(&(header.remark[2]), "Projection: UTM%dS", &utmzone)) == 1)
			{
			sprintf(projectionname, "UTM%dS", utmzone);
			modeltype = ModelTypeProjected;
			projectionid = 32700 + utmzone;
			*grid_projection_mode = MBV_PROJECTION_PROJECTED;
			sprintf(grid_projection_id, "epsg%d", projectionid);
			}
		else if ((nscan = sscanf(&(header.remark[2]), "Projection: epsg%d", &projectionid)) == 1)
			{
			sprintf(projectionname, "epsg%d", projectionid);
			modeltype = ModelTypeProjected;
			*grid_projection_mode = MBV_PROJECTION_PROJECTED;
			sprintf(grid_projection_id, "epsg%d", projectionid);
			}
		else
			{
			strcpy(projectionname, "Geographic WGS84");
			modeltype = ModelTypeGeographic;
			projectionid = GCS_WGS_84;
			*grid_projection_mode = MBV_PROJECTION_GEOGRAPHIC;
			sprintf(grid_projection_id, "epsg%d", projectionid);
			}
		}
	else
		{
		strcpy(projectionname, "Geographic WGS84");
		modeltype = ModelTypeGeographic;
		projectionid = GCS_WGS_84;
		*grid_projection_mode = MBV_PROJECTION_GEOGRAPHIC;
		sprintf(grid_projection_id, "epsg%d", projectionid);
		}	

	/* print debug info */
	if (verbose >= 0)
	    {
	    fprintf(stderr,"Grid read:\n");
	    fprintf(stderr,"  Dimensions: %d %d\n", header.nx, header.ny);
	    if (modeltype == ModelTypeProjected)
	    	{
		fprintf(stderr,"  Projected Coordinate System Name: %s\n", projectionname);
		fprintf(stderr,"  Projected Coordinate System ID:   %d\n", projectionid);
	    	fprintf(stderr,"  Easting:    %f %f  %f\n",
		  	header.x_min, header.x_max, header.x_inc);
	    	fprintf(stderr,"  Northing:   %f %f  %f\n",
		  	header.y_min, header.y_max, header.y_inc);
		}
	    else
		{
		fprintf(stderr,"  Geographic Coordinate System Name: %s\n", projectionname);
		fprintf(stderr,"  Geographic Coordinate System ID:   %d\n", projectionid);
	    	fprintf(stderr,"  Longitude:  %f %f  %f\n",
		  	header.x_min, header.x_max, header.x_inc);
	    	fprintf(stderr,"  Latitude:   %f %f  %f\n",
		  	header.y_min, header.y_max, header.y_inc);
		}
	    fprintf(stderr,"  Internal Grid Projection Mode:         %d\n", 
	    			*grid_projection_mode);
	    fprintf(stderr,"  Internal Grid Projection ID:           %s\n", 
	    			grid_projection_id);

	    fprintf(stderr,"Data Read:\n");
	    fprintf(stderr,"  grid_projection_mode:     %d\n", *grid_projection_mode);
	    fprintf(stderr,"  grid_projection_id:       %s\n", grid_projection_id);
	    fprintf(stderr,"  nodatavalue:              %f\n", *nodatavalue);
	    fprintf(stderr,"  nx:                       %d\n", *nx);
	    fprintf(stderr,"  ny:                       %d\n", *ny);
	    fprintf(stderr,"  min:                      %f\n", *min);
	    fprintf(stderr,"  max:                      %f\n", *max);
	    fprintf(stderr,"  xmin:                     %f\n", *xmin);
	    fprintf(stderr,"  xmax:                     %f\n", *xmax);
	    fprintf(stderr,"  ymin:                     %f\n", *ymin);
	    fprintf(stderr,"  ymax:                     %f\n", *ymax);
	    fprintf(stderr,"  dx:                       %f\n", *dx);
	    fprintf(stderr,"  dy:                       %f\n", *dy);
	    fprintf(stderr,"  data:                     %d\n", *data);
	    }

	return(status);
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_opentest(int instance, 
			double	factor1, 
			double	factor2, 
			double	factor3, 
			int	*grid_projection_mode,
			char	*grid_projection_id,
			float	*nodatavalue,
			int	*nxy,
			int	*nx,
			int	*ny,
			double	*min,
			double	*max,
			double	*xmin,
			double	*xmax,
			double	*ymin,
			double	*ymax,
			double	*dx,
			double	*dy,
			float	**data)
{
	char function_name[] = "do_mbgrdviz_opentest";
	int	status = MB_SUCCESS;
	double	xx, yy;
	float	*usedata;
	int	i, j, k;

	*grid_projection_mode = MBV_PROJECTION_GEOGRAPHIC;
	sprintf(grid_projection_id, "epsg%d", GCS_WGS_84);
    	*nodatavalue = MBV_DEFAULT_NODATA;
    	*nx = 501;
    	*ny = 501;
    	*nxy = *nx * *ny;
    	*xmin = -1.0;
    	*xmax = 1.0;
    	*ymin = -1.0;
    	*ymax = 1.0;
    	*dx = (*xmax - *xmin) / (*nx -1);
    	*dy = (*ymax - *ymin) / (*ny -1);
    	*min = 0.0;
    	*max = 1000.0;
    	*min = 0.0;
    	*max = 0.0;

    	if (status == MB_SUCCESS)
    	status = mb_malloc(verbose, sizeof(float) * *nxy, 
    				data,
				&error);
	usedata = *data;
	if (status != MB_SUCCESS)
	    {
	    fprintf(stderr,"\nUnable to allocate memory to store test data...\n");
	    fprintf(stderr,"\nProgram <%s> Terminated\n",
		    program_name);
	    exit(error);
	    }

	for (i=0;i<*nx;i++)
		for (j=0;j<*ny;j++)
			{
			k = i * *ny + j;
			xx = *xmin + i * *dx;
			yy = *ymin + j * *dy;
			usedata[k] = factor1 * sin(factor2 * M_PI * xx) 
							* sin(factor2 * M_PI * yy)
							* exp(-factor3 * xx * yy);
    			*min = MIN(*min, usedata[k]);
    			*max = MAX(*max, usedata[k]);
			}
	
	return(status);
}
/*---------------------------------------------------------------------------------------*/

void do_mbgrdviz_open_region( Widget w, XtPointer client_data, XtPointer call_data)
{
	char function_name[] = "do_mbgrdviz_open_region";
	int	status = MB_SUCCESS;
	int	projectionid, utmzone;
	double	reference_lon;
        Cardinal ac = 0;
        Arg      args[256];
        Cardinal cdc = 0;
        Boolean  argok = False;
        XmString    tmp0;
	int	actionid;
	double	xx, yy;
	int	ixmin, ixmax, jymin, jymax;
	int	i, j, k, ksource;
	
	/* existing mbview instance */
	int	instance_source;
	struct mbview_struct *data_source;
	char	button_name_source[MB_PATH_MAXLINE];
	
	/* new mbview instance */
	int	instance;
	char	button_name[MB_PATH_MAXLINE];
	
	/* mbview parameters */
	int 	(*mbview_dismiss_notify)(int id);
	char	mbv_title[MB_PATH_MAXLINE];
	int	mbv_xo;
	int	mbv_yo;
	int	mbv_width;
	int	mbv_height;
	int	mbv_lorez_dimension;
	int	mbv_hirez_dimension;
	int	mbv_primary_nxy;
	int	mbv_primary_nx;
	int	mbv_primary_ny;
	double	mbv_primary_min;
	double	mbv_primary_max;
	double	mbv_primary_xmin;
	double	mbv_primary_xmax;
	double	mbv_primary_ymin;
	double	mbv_primary_ymax;
	double	mbv_primary_dx;
	double	mbv_primary_dy;
	float	*mbv_primary_data;
   
    	/* get source mbview instance */
	instance_source = (int) client_data;
fprintf(stderr,"Called do_mbgrdviz_open_region instance:%d\n", instance_source);

	/* get new instance number */
	if (instance_source >= 0 && instance_source < MBV_MAX_WINDOWS)
		{
		status = mbview_init(verbose, &instance, &error);
		if (instance < 0)
			{
			fprintf(stderr, "Unable to create mbview - %d mbview windows already created\n", 
			MBV_MAX_WINDOWS);
			status = MB_FAILURE;
			}
		}
	else
		{
		status = MB_FAILURE;
		}
	    
    	/* check data source for region to extract */
	if (status == MB_SUCCESS)
		{
		/* get source data */
		mbview_getdataptr(verbose, instance_source, &data_source, &error);
					
		/* extract the grid from the source */
		if (data_source->region_type != MBV_REGION_QUAD)
			status = MB_FAILURE;
		}
	    
    	/* extract data from source and create new mbview instance */
	if (status == MB_SUCCESS)
		{
		/* get source data */
		mbview_getdataptr(verbose, instance_source, &data_source, &error);

		/* get button name */
		sscanf(data_source->title,"MBgrdviz: %s", button_name_source);
		sprintf(button_name,"Region from %s", button_name_source);

		/* set parameters */
		sprintf(mbv_title, "MBgrdviz: %s\n", button_name);
		mbv_xo = 200;
		mbv_yo = 200;
		mbv_width = 560;
		mbv_height = 500;
		mbv_lorez_dimension = data_source->lorez_dimension;
		mbv_hirez_dimension = data_source->hirez_dimension;

		/* set basic mbview window parameters */
		status = mbview_setwindowparms(verbose, instance,
					&do_mbgrdviz_dismiss_notify,
					mbv_title,
					mbv_xo,
					mbv_yo,
					mbv_width,
					mbv_height,
					mbv_lorez_dimension,
					mbv_hirez_dimension,
					&error);
					
		/* extract the grid from the source */
		mbv_primary_dx = data_source->primary_dx;
		mbv_primary_dy = data_source->primary_dy;
		mbv_primary_xmin = MIN(data_source->region.cornerpoints[0].xgrid,
					data_source->region.cornerpoints[3].xgrid);
		mbv_primary_xmax = MAX(data_source->region.cornerpoints[0].xgrid,
					data_source->region.cornerpoints[3].xgrid);
		mbv_primary_ymin = MIN(data_source->region.cornerpoints[0].ygrid,
					data_source->region.cornerpoints[3].ygrid);
		mbv_primary_ymax = MAX(data_source->region.cornerpoints[0].ygrid,
					data_source->region.cornerpoints[3].ygrid);
		ixmin = (mbv_primary_xmin
				- data_source->primary_xmin) 
				/ mbv_primary_dx;
		ixmax = ((mbv_primary_xmax
				- data_source->primary_xmin) 
				/ mbv_primary_dx) + 1;
		jymin = (mbv_primary_ymin
				- data_source->primary_ymin) 
				/ mbv_primary_dy;
		jymax = ((mbv_primary_ymax
				- data_source->primary_ymin) 
				/ mbv_primary_dy) + 1;
		ixmin = MAX(ixmin, 0);
		ixmax = MIN(ixmax, data_source->primary_nx - 1);
		jymin = MAX(jymin, 0);
		jymax = MIN(jymax, data_source->primary_ny - 1);
		mbv_primary_xmin = data_source->primary_xmin + mbv_primary_dx * ixmin;
		mbv_primary_xmax = data_source->primary_xmin + mbv_primary_dx * ixmax;
		mbv_primary_ymin = data_source->primary_ymin + mbv_primary_dy * jymin;
		mbv_primary_ymax = data_source->primary_ymin + mbv_primary_dy * jymax;
		mbv_primary_nx = ixmax - ixmin + 1;
		mbv_primary_ny = jymax - jymin + 1;
		mbv_primary_nxy = mbv_primary_nx * mbv_primary_ny;
		status = mb_malloc(verbose, sizeof(float) * mbv_primary_nxy, 
    				&mbv_primary_data,
				&error);
		mbv_primary_min = data_source->primary_nodatavalue;
		mbv_primary_max = data_source->primary_nodatavalue;
		for (i=0;i<mbv_primary_nx;i++)
			{
			for (j=0;j<mbv_primary_ny;j++)
				{
				k = i * mbv_primary_ny + j;
				ksource = (i + ixmin) * data_source->primary_ny + (j + jymin);
				mbv_primary_data[k] = data_source->primary_data[ksource];
				if (mbv_primary_data[k] != data_source->primary_nodatavalue)
					{
					if (mbv_primary_min == data_source->primary_nodatavalue
						|| mbv_primary_data[k] < mbv_primary_min)
						{
						mbv_primary_min = mbv_primary_data[k];
						}
					if (mbv_primary_max == data_source->primary_nodatavalue
						|| mbv_primary_data[k] > mbv_primary_max)
						{
						mbv_primary_max = mbv_primary_data[k];
						}
					}
				}
			}

		/* set basic mbview view controls */
		if (status == MB_SUCCESS)
		status = mbview_setviewcontrols(verbose, instance,
					data_source->display_mode,
					data_source->mouse_mode,
					data_source->grid_mode,
					data_source->primary_shade_mode,
					data_source->slope_shade_mode,
					data_source->secondary_shade_mode,
					data_source->grid_contour_mode,
					data_source->site_view_mode,
					data_source->route_view_mode,
					data_source->nav_view_mode,
					data_source->navdrape_view_mode,
					data_source->exageration,
					data_source->modelelevation3d,
					data_source->modelazimuth3d,
					data_source->viewelevation3d,
					data_source->viewazimuth3d,
					data_source->illuminate_magnitude,
					data_source->illuminate_elevation,
					data_source->illuminate_azimuth,
					data_source->slope_magnitude,
					data_source->overlay_shade_magnitude,
					data_source->overlay_shade_center,
					data_source->overlay_shade_mode,
					data_source->contour_interval,
					data_source->display_projection_mode,
					data_source->display_projection_id,
					&error);

		/* set more mbview control values */
		if (status == MB_SUCCESS)
		status = mbview_setprimarygrid(verbose, instance,
					data_source->primary_grid_projection_mode,
					data_source->primary_grid_projection_id,
					data_source->primary_nodatavalue,
					mbv_primary_nx,
					mbv_primary_ny,
					mbv_primary_min,
					mbv_primary_max,
					mbv_primary_xmin,
					mbv_primary_xmax,
					mbv_primary_ymin,
					mbv_primary_ymax,
					mbv_primary_dx,
					mbv_primary_dy,
					mbv_primary_data,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_setprimarycolortable(verbose, instance,
					data_source->primary_colortable,
					data_source->primary_colortable_mode,
					data_source->primary_colortable_min,
					data_source->primary_colortable_max,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_setslopecolortable(verbose, instance,
					data_source->slope_colortable,
					data_source->slope_colortable_mode,
					data_source->slope_colortable_min,
					data_source->slope_colortable_max,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_enableeditsites(verbose, instance,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_enableeditroutes(verbose, instance,
					&error);

		/* open up mbview window */
		if (status == MB_SUCCESS)
			{
fprintf(stderr,"about to open mbview instance:%d\n",instance);
			status = mbview_open(verbose, instance, &error);
			if (status == MB_SUCCESS)
				mbview_id[instance] = MB_YES;
			else
				mbview_id[instance] = MB_NO;
fprintf(stderr,"done opening mbview instance:%d\n",instance);

			/* add action button */
			if (status == MB_SUCCESS)
				{
				mbview_addaction(verbose, instance,
					do_mbgrdviz_open_region,
					"Open Region as New View", 
					MBV_PICKMASK_REGION, &error);
				}
			}

		}
}
/*---------------------------------------------------------------------------------------*/
