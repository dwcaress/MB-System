/*--------------------------------------------------------------------
 *    The MB-system:	mbwedge_callbacks.c	4/8/93
 *    $Id$
 *
 *    Copyright (c) 1993-2010 by
 *    David W. Caress (caress@mbari.org)
 *      Monterey Bay Aquarium Research Institute
 *      Moss Landing, CA 95039
 *    and Dale N. Chayes (dale@ldeo.columbia.edu)
 *      Lamont-Doherty Earth Observatory
 *      Palisades, NY 10964
 *
 *    See README file for copying and redistribution conditions.
 *--------------------------------------------------------------------*/
/*
 * MBwedge is an interactive sonar display tool for use with the
 * watercolumn data from multibeam sonars.
 *
 * Author:	D. W. Caress
 * Date:	June 15, 2010
 *
 */

/* Begin user code block <abstract> */
/* End user code block <abstract> */

/**
 * README: This file is appended to at file generation time.
 * Edits can be made throughout the file
 */
/*
 * Generated by the ICS Builder Xcessory (BX).
 *
 * BuilderXcessory Version 6.1.3
 * Code Generator Xcessory 6.1.3 (08/19/04) CGX Scripts 6.1 Motif 2.1 
 *
 */
#include <Xm/Xm.h>


/*
 * Standard includes for builtins.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sys/stat.h>

/* X11 includes */
#include <X11/cursorfont.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Intrinsic.h>
#include <X11/keysym.h>
#include <X11/keysymdef.h>
#include <Xm/FileSB.h>
#include <Xm/Text.h>
#include <Xm/TextF.h>
#include <Xm/ToggleB.h>

/* mbwedge widget includes */
#include "mbwedge_creation.h"
#include "../../include/mb_define.h"
#include "../../include/mb_status.h"
#include "../../include/mb_xgraphics.h"
#include "mbwedge.h"

/*
 * Macros to make code look nicer between ANSI and K&R.
 */
#ifndef ARGLIST
#if (NeedFunctionPrototypes == 0)
#define PROTOTYPE(p)	()
#define ARGLIST(p)	p
#define ARG(a, b)	a b;
#define GRA(a, b)	a b;
#define UARG(a, b)      a b;
#define GRAU(a, b)      a b;
#else
#define PROTOTYPE(p)	p
#define ARGLIST(p)	(
#define ARG(a, b)	a b,
#define GRA(a, b)	a b)
#ifdef __cplusplus
#define UARG(a, b)      a,
#define GRAU(a, b)      a)
#else
#define UARG(a, b)      a b,
#define GRAU(a, b)      a b)
#endif
#endif
#endif

Widget		BxFindTopShell PROTOTYPE((Widget));
WidgetList	BxWidgetIdsFromNames PROTOTYPE((Widget, char*, char*));

/*--------------------------------------------------------------------*/

/* additional widgets */
Widget	fileSelectionList;
Widget	fileSelectionText;

/* global defines and variables */
#define EV_MASK (ButtonPressMask | KeyPressMask | KeyReleaseMask | ExposureMask )
#define xgfont "-misc-fixed-bold-r-normal-*-13-*-75-75-c-70-iso8859-1"

/* Mode value defines */
#define	MODE_TOGGLE	0
#define	MODE_PICK	1
#define	MODE_ERASE	2
#define	MODE_RESTORE	3
#define	MODE_GRAB	4
#define	MODE_INFO	5
#define	VIEW_WATERFALL		0
#define	VIEW_ALONGTRACK		1
#define	VIEW_ACROSSTRACK	2
#define	BEAM_MODE_FLAG		0
#define	BEAM_MODE_DETECT	1
#define	BEAM_MODE_PULSE		2
#define	OUTPUT_MODE_OUTPUT	0
#define	OUTPUT_MODE_EDIT	1
#define	OUTPUT_MODE_BROWSE	2
#define GRAB_START		0
#define GRAB_MOVE		1
#define GRAB_END		2

/* global variables */
XtAppContext app_context;
Display *display, *theDisplay;
Screen *screen, *can_screen;
Window can_xid;
Window root_return, child_return;
Colormap theColormap, colormap;
GC gc;
unsigned int theCursorShape;
Cursor theCursor;
XGCValues xgcv;

XFontStruct *fontStruct;

/* Global mbwedge definitions */
int	expose_plot_ok = False;
int	status;

/* file opening parameters */
int	startup_file = 0;
int	use_save_file = False;

int selected = 0; /* indicates an input file is selected */

Cursor myCursor;
XColor closest[2];
XColor exact[2];

int key_g_down = 0;
int key_z_down = 0;
int key_s_down = 0;
int key_a_down = 0;
int key_d_down = 0;

/* Set the colors used for this program here. */
#define NCOLORS 7
XColor colors[NCOLORS];
unsigned int mpixel_values[NCOLORS];
XColor db_color;

/* Set these to the dimensions of your canvas drawing */
/* area, minus 1, located in mbwedge.uil.              */
static int mb_borders[4] =
	{ 0, 1016, 0, 525 };


/*--------------------------------------------------------------------*/
/*      Function Name: 	BxManageCB
 *
 *      Description:   	Given a string of the form:
 *		       	"(WL)[widgetName, widgetName, ...]"
 *			BxManageCB attempts to convert the name to a Widget
 *			ID and manage the widget.
 *
 *      Arguments:     	Widget	    w:      the widget activating the callback.
 *		       	XtPointer   client: the list of widget names to attempt
 *					    to find and manage.
 *		       	XtPointer   call:   the call data (unused).
 *
 *      Notes:        *	This function expects that there is an application
 *		       	shell from which all other widgets are descended.
 */

/* ARGSUSED */
void
BxManageCB ARGLIST((w, client, call))
ARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
    WidgetList		widgets;
    int			i;

    /*
     * This function returns a NULL terminated WidgetList.  The memory for
     * the list needs to be freed when it is no longer needed.
     */
    widgets = BxWidgetIdsFromNames(w, "BxManageCB", (String)client);

    i = 0;
    while( widgets && widgets[i] != NULL )
    {
	XtManageChild(widgets[i]);
	i++;
    }
    XtFree((char *)widgets);
}

/*--------------------------------------------------------------------*/
/*      Function Name: 	BxUnmanageCB
 *
 *      Description:   	Given a string of the form:
 *		       	"(WL)[widgetName, widgetName, ...]"
 *			BxUnmanageCB attempts to convert the name to a Widget
 *			ID and unmanage the widget.
 *
 *      Arguments:     	Widget	    w:      the widget activating the callback.
 *		       	XtPointer   client: the list of widget names to attempt
 *					    to find and unmanage.
 *		       	XtPointer   call:   the call data (unused).
 *
 *      Notes:        *	This function expects that there is an application
 *		       	shell from which all other widgets are descended.
 */

/* ARGSUSED */
void
BxUnmanageCB ARGLIST((w, client, call))
ARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
    WidgetList		widgets;
    int			i;

    /*
     * This function returns a NULL terminated WidgetList.  The memory for
     * the list needs to be freed when it is no longer needed.
     */
    widgets = BxWidgetIdsFromNames(w, "BxUnmanageCB", (String)client);

    i = 0;
    while( widgets && widgets[i] != NULL )
    {
	XtUnmanageChild(widgets[i]);
	i++;
    }
    XtFree((char *)widgets);
}
/*--------------------------------------------------------------------*/

void
do_mbwedge_init(int argc, char **argv)
{
    int	    i;
    char	value_text[10];
fprintf(stderr,"Called do_mbwedge_init...\n");
    
    /* make sure expose plots are off */
    expose_plot_ok = False;
    
    /* get additional widgets */
    fileSelectionList = (Widget) 
	XmFileSelectionBoxGetChild(fileSelectionBox, 
				    XmDIALOG_LIST);
    fileSelectionText = (Widget) 
	XmFileSelectionBoxGetChild(fileSelectionBox, 
				    XmDIALOG_TEXT);
    XtAddCallback(fileSelectionList, 
	    XmNbrowseSelectionCallback, 
	    do_fileselection_list, NULL);
    XtUnmanageChild((Widget) XmFileSelectionBoxGetChild(
				    fileSelectionBox, 
				    XmDIALOG_HELP_BUTTON));
    sprintf(value_text,"%d",format);
    XmTextFieldSetString(textfield_format,value_text);

    /* Setup the entire screen. */
    display = XtDisplay(window_mbwedge);
    colormap = DefaultColormap(display, XDefaultScreen(display));
    
    /* Setup just the "canvas" part of the screen. */
    theDisplay = XtDisplay(canvas_mbwedge);
    can_screen = DefaultScreenOfDisplay(theDisplay);
    can_xid = XtWindow(canvas_mbwedge);
    theColormap = DefaultColormap(display, XDefaultScreen(theDisplay));
    
    /* Setup the "graphics Context" for just the "canvas" */
    xgcv.background = WhitePixelOfScreen(can_screen);
    xgcv.foreground = BlackPixelOfScreen(can_screen);
    xgcv.line_width = 2;
    gc = XCreateGC(theDisplay,can_xid,GCBackground | GCForeground 
	     | GCLineWidth, &xgcv);
    
    /* Setup the font for just the "canvas" screen. */
    fontStruct = XLoadQueryFont(theDisplay, 
	     "-misc-fixed-bold-r-normal-*-13-*-75-75-c-70-iso8859-1");
    XSetFont(theDisplay,gc,fontStruct->fid);
    
    XSelectInput(theDisplay, can_xid, EV_MASK );
    
    /* Load the colors that will be used in this program. */
    status = XLookupColor(display,colormap, "white",&db_color,&colors[0]);
    if ((status = XAllocColor(display,colormap,&colors[0])) == 0)
	    fprintf(stderr,"Failure to allocate color: white\n");
    status = XLookupColor(display,colormap, "black",&db_color,&colors[1]);
    if ((status = XAllocColor(display,colormap,&colors[1])) == 0)
	    fprintf(stderr,"Failure to allocate color: black\n");
#ifdef USE_ORANGE
    status = XLookupColor(display,colormap, "orange",&db_color,&colors[2]);
    if ((status = XAllocColor(display,colormap,&colors[2])) == 0)
	    fprintf(stderr,"Failure to allocate color: orange\n");
#else
    status = XLookupColor(display,colormap, "red",&db_color,&colors[2]);
    if ((status = XAllocColor(display,colormap,&colors[2])) == 0)
	    fprintf(stderr,"Failure to allocate color: red\n");
#endif
    status = XLookupColor(display,colormap, "green",&db_color,&colors[3]);
    if ((status = XAllocColor(display,colormap,&colors[3])) == 0)
	    fprintf(stderr,"Failure to allocate color: green\n");
    status = XLookupColor(display,colormap, "blue",&db_color,&colors[4]);
    if ((status = XAllocColor(display,colormap,&colors[4])) == 0)
	    fprintf(stderr,"Failure to allocate color: blue\n");
    status = XLookupColor(display,colormap, "coral",&db_color,&colors[5]);
    if ((status = XAllocColor(display,colormap,&colors[5])) == 0)
	    fprintf(stderr,"Failure to allocate color: coral\n");
    status = XLookupColor(display,colormap, "lightgrey",&db_color,&colors[6]);
    if ((status = XAllocColor(display,colormap,&colors[6])) == 0)
	    fprintf(stderr,"Failure to allocate color: lightgrey\n");
    ncolors = NCOLORS;
    for (i=0;i<ncolors;i++)
	    {
	    pixel_values[i] = colors[i].pixel;
	    }
    
    /* Setup initial cursor. This will be changed when changing "MODE". */
    myCursor = XCreateFontCursor(theDisplay, XC_target);
    XAllocNamedColor(theDisplay,colormap,"red",&closest[0],&exact[0]);
    XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
    XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
    XDefineCursor(theDisplay,can_xid,myCursor);
    
    /* initialize graphics */
    xg_init(theDisplay, can_xid, mb_borders, xgfont, &mbwedge_xgid);
    
    /* initialize mbwedge proper */
    status = mbwedge_init(argc,argv, &startup_file);
    
    /* if startup indicated try to open it */
    if (startup_file == MB_YES)
	{
	/* get format if required */
	if (format == 0)
		mb_get_format(5,input_file,NULL,&format,&error);

	/* load the data */
	do_load();
	}
    
    /* finally allow expose plots */
    expose_plot_ok = False;
}
/*--------------------------------------------------------------------*/

void
do_fileselection_list( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
fprintf(stderr,"Called do_fileselection_list...\n");

    static char selection_text[MB_PATH_MAXLINE];
    int	form;
    char	value_text[10];

    /* get selected text */
    get_text_string(fileSelectionText, selection_text);

    /* get output file */
    if((int)strlen(selection_text) > 0)
	    {
	    /* look for MB suffix convention */
	    form = format;
	    if ((status = mb_get_format(5,selection_text,NULL,&form,&error)) 
	    	== MB_SUCCESS)
		{
		format = form;
		sprintf(value_text,"%d",format);
		XmTextFieldSetString(
		    textfield_format, 
		    value_text);
		}
	    }
}


/*--------------------------------------------------------------------*/

void
do_mode_toggle( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_mode_erase( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_scale_y( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_scale_x( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_end( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_output_browse( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_show_detects( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_x_interval( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_y_interval( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_flag_view( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_load_check( Widget w, XtPointer client_data, XtPointer call_data)
{
    static  char format_text[40];
    char    *input_file_ptr;
    XmFileSelectionBoxCallbackStruct *acs;
    acs = (XmFileSelectionBoxCallbackStruct*)call_data;
fprintf(stderr,"Called do_load_check...\n");

    /* read the input file name */
    if(!XmStringGetLtoR(acs->value,
	    XmSTRING_DEFAULT_CHARSET, 
	    &input_file_ptr))
	    {
	    selected = 0;
	    }
    else
	    {
	    selected = 1;
	    strncpy(input_file, input_file_ptr, 128);
	    XtFree(input_file_ptr);
	    }

    /* if file selected in dialog open it */
    if (selected > 0)
	    {
	    /* read the mbio format number from the screen */
	    get_text_string(textfield_format, format_text);
	    sscanf(format_text, "%d", &format);
	    
	    /* load the data */
	    do_load();
	    }

    else
	    {
	    fprintf(stderr,"\nNo input multibeam file selected\n");
	    }
}
/*--------------------------------------------------------------------*/

void
do_load()
{    
fprintf(stderr,"Called do_load...\n");

    /* turn off expose plots */
    expose_plot_ok = False;

    /* get format, if needed */
    if (format == 0)
	mb_get_format(5,input_file,NULL,&format,&error);

    /* process input file name */
    status = mbwedge_action_open();
    if (status == 0) XBell(theDisplay,100);
    
    /* display data from chosen file */
    status = mbwedge_action_plot();
    if (status == 0) XBell(theDisplay,100);

    /* set widget values */
    /* do_setup_data(); */
    
    /* turn on expose plots */
    expose_plot_ok = True;

}

/*--------------------------------------------------------------------*/

void
do_mode_info( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_unflag_view( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_mode_pick( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_event( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmDrawingAreaCallbackStruct *acs;
    XEvent  *event;
    static Position x_loc, y_loc;

    KeySym keysym;
    char buffer[1];
    int actual;

    acs = (XmDrawingAreaCallbackStruct*)call_data;
    event = acs->event;

    /* check for data file loaded at startup */
    if (startup_file)
	    {
	    startup_file = 0;
	    status = mbwedge_action_plot();
	    if (status == 0) XBell(theDisplay,100);
	    } /* end startup file */

    /* If there is input in the drawing area */
    if (acs->reason == XmCR_INPUT)
    {
      /* deal with expose events by replotting the mbwedge view */
      if (event->xany.type == Expose || event->xany.type == GraphicsExpose)
		status = mbwedge_action_plot();
    
      /* Deal with KeyPress events */
      if(event->xany.type == KeyPress)
      {
      /* Get key pressed - buffer[0] */
      actual = XLookupString((XKeyEvent *)event, 
		    buffer, 1, &keysym, NULL);

      /* process events */
      switch (buffer[0])
	    {
	    case 'G':
	    case 'g':
		    key_g_down = 1;
		    break;
	    case 'M':
	    case 'm':
	    case 'Z':
	    case 'z':
		    key_z_down = 1;
		    key_s_down = 0;
		    key_a_down = 0;
		    key_d_down = 0;
		    break;
	    case 'K':
	    case 'k':
	    case 'S':
	    case 's':
		    key_z_down = 0;
		    key_s_down = 1;
		    key_a_down = 0;
		    key_d_down = 0;
		    break;
	    case 'J':
	    case 'j':
	    case 'A':
	    case 'a':
		    key_z_down = 0;
		    key_s_down = 0;
		    key_a_down = 1;
		    key_d_down = 0;
		    break;
	    case 'L':
	    case 'l':
	    case 'D':
	    case 'd':
		    key_z_down = 0;
		    key_s_down = 0;
		    key_a_down = 0;
		    key_d_down = 1;
		    break;
	    default:
		    break;
	    } /* end of key switch */
       } /* end of key press events */

      /* Deal with KeyRelease events */
      if(event->xany.type == KeyRelease)
      {
      /* Get key pressed - buffer[0] */
      actual = XLookupString((XKeyEvent *)event, 
		    buffer, 1, &keysym, NULL);

      /* process events */
      switch (buffer[0])
	    {
	    case 'G':
	    case 'g':
		    key_g_down = 0;
		    break;
	    case 'M':
	    case 'm':
	    case 'Z':
	    case 'z':
		    key_z_down = 0;
		    break;
	    case 'K':
	    case 'k':
	    case 'S':
	    case 's':
		    key_s_down = 0;
		    break;
	    case 'J':
	    case 'j':
	    case 'A':
	    case 'a':
		    key_a_down = 0;
		    break;
	    case 'L':
	    case 'l':
	    case 'D':
	    case 'd':
		    key_d_down = 0;
		    break;
	    default:
		    break;
	    } /* end of key switch */
       } /* end of key release events */

      /* Check for mouse pressed and not pressed and released. */
      if(event->xany.type == ButtonPress)
      {
	  /* If left mouse button is pushed then toggle, pick, erase, restore, grab, or info. */
	  if (event->xbutton.button == 1)
	    {
	    x_loc = event->xbutton.x;
	    y_loc = event->xbutton.y;
	    } /* end of left button events */

	  /* If middle mouse button is pushed then scroll in reverse. */
	  if(event->xbutton.button == 2)
	    {
	    } /* end of middle button events */

	    /* If right mouse button is pushed then scroll forward. */
	  if (event->xbutton.button == 3)
	    {
	    } /* end of right button events */	
      } /* end of button pressed events */
    } /* end of inputs from window */
} /* end do_event function */

/*--------------------------------------------------------------------*/

void
do_forward( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_output_edit( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_quit( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
    
    /* clean up and then exit the program */   
    status = mbwedge_action_quit();
    if (status == 0) XBell(theDisplay,100);
    
    exit(0);

    
}

/*--------------------------------------------------------------------*/

void
do_start( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_show_time( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_view_mode( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_reset_filters( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_expose( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
    
fprintf(stderr,"do_expose called...\n");
}

/*--------------------------------------------------------------------*/

void
do_next_buffer( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_number_step( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_mode_grab( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_show_flagged( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_mode_restore( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_buffer_hold( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_buffer_size( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_done( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_reverse_mouse( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_unflag_all( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_check_median_ltrack( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_reverse( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_check_median_xtrack( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_set_filters( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_goto_apply( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_number_pings( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_reverse_keys( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_scale_playbackspeed( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_stop( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_play( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs;
    acs = (XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/
/* Utility functions */
/*--------------------------------------------------------------------*/

int
do_wait_until_viewed(XtAppContext app)
{
    Widget  topshell;
    Window  topwindow;
    XWindowAttributes	xwa;
    XEvent  event;
    
    /* set app_context */
    app_context = app;
    
    /* find the top level shell */
    for (topshell = window_mbwedge; 
	    !XtIsTopLevelShell(topshell);
	    topshell = XtParent(topshell))
	;
	
    /* keep processing events until it is viewed */
    if (XtIsRealized(topshell))
	{
	topwindow = XtWindow(topshell);
	
	/* wait for the window to be mapped */
	while (XGetWindowAttributes(
			XtDisplay(window_mbwedge), 
			topwindow, &xwa)
		&& xwa.map_state != IsViewable)
	    {
	    XtAppNextEvent(app_context, &event);
	    XtDispatchEvent(&event);
	    }
	}
	
    XmUpdateDisplay(topshell);
	
    return(1);
    
}

/*--------------------------------------------------------------------*/

int
do_message_on(char *message)
{
    Widget  diashell, topshell;
    Window  diawindow, topwindow;
    XWindowAttributes	xwa;
    XEvent  event;
    
    set_label_string(label_message, message);
    XtManageChild(bulletinBoard_message);
    
    /* force the label to be visible */
    for (diashell = label_message; 
	    !XtIsShell(diashell); 
	    diashell = XtParent(diashell))
	;
    for (topshell = diashell; 
	    !XtIsTopLevelShell(topshell);
	    topshell = XtParent(topshell))
	;
    if (XtIsRealized(diashell) && XtIsRealized(topshell))
	{
	diawindow = XtWindow(diashell);
	topwindow = XtWindow(topshell);
	
	/* wait for the dialog to be mapped */
	while (XGetWindowAttributes(display, diawindow, &xwa)
		&& xwa.map_state != IsViewable)
	    {
	    if (XGetWindowAttributes(display, topwindow, &xwa)
		    && xwa.map_state != IsViewable)
		break;
		
	    XtAppNextEvent(app_context, &event);
	    XtDispatchEvent(&event);
	    }
	}
	
    XmUpdateDisplay(topshell);
	
    return(1);
}

/*--------------------------------------------------------------------*/

int
do_message_off()
{
    XtUnmanageChild(bulletinBoard_message);
    XSync(XtDisplay(bulletinBoard_message), 0);
    XmUpdateDisplay(window_mbwedge);
	
    return(1);
}

/*--------------------------------------------------------------------*/

int
do_error_dialog(char *s1, char *s2, char *s3)
{
    set_label_string(label_error_one, s1);
    set_label_string(label_error_two, s2);
    set_label_string(label_error_three, s3);
    XtManageChild(bulletinBoard_error);
    XBell(theDisplay,100);
	
    return(1);
}

/*--------------------------------------------------------------------*/
/* Change label string cleanly, no memory leak */
/*--------------------------------------------------------------------*/

void set_label_string(Widget w, String str)
{
    XmString xstr;
    
    xstr = XmStringCreateLocalized( str );
    if ( xstr != NULL ) 
	XtVaSetValues(w, 
	    XmNlabelString, xstr, 
	    NULL);
    else 
	XtWarning("Failed to update labelString");

    XmStringFree( xstr );
}
/*--------------------------------------------------------------------*/
/* Change multiline label string cleanly, no memory leak */
/*--------------------------------------------------------------------*/

void set_label_multiline_string(Widget w, String str)
{
    XmString xstr;
    Boolean      argok;

    xstr = (XtPointer)BX_CONVERT(w, str, XmRXmString, 0, &argok);
    if ( xstr != NULL && argok)
        XtVaSetValues(w,
            XmNlabelString, xstr,
            NULL);
    else
        XtWarning("Failed to update labelString");

    XmStringFree( xstr );
}
/*--------------------------------------------------------------------*/
/* Get text item string cleanly, no memory leak */
/*--------------------------------------------------------------------*/

void get_text_string(Widget w, String str)
{
    char	*str_tmp;
    
    str_tmp = (char *) XmTextGetString(w);
    strcpy(str, str_tmp);
    XtFree(str_tmp);
}

/*--------------------------------------------------------------------*/
