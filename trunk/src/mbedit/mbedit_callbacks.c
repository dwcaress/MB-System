/*--------------------------------------------------------------------
 *    The MB-system:	mbedit_callbacks.c	3/28/97
 *    $Id: mbedit_callbacks.c,v 4.7 2000-01-25 01:46:20 caress Exp $
 *
 *    Copyright (c) 1993, 1994, 1995, 1997 by 
 *    D. W. Caress (caress@lamont.ldgo.columbia.edu)
 *    and D. N. Chayes (dale@lamont.ldgo.columbia.edu)
 *    Lamont-Doherty Earth Observatory
 *    Palisades, NY  10964
 *
 *    See README file for copying and redistribution conditions.
 *--------------------------------------------------------------------*/
/*
 * MBEDIT is an interactive beam editor for multibeam bathymetry data.
 * It can work with any data format supported by the MBIO library.
 * This version uses the MOTIF toolkit and has been developed using
 * the Builder Xsessory package by ICS.  This file contains
 * the callbacks generated by BX. 
 *
 * Author:	D. W. Caress
 * Date:	April 8, 1993
 * Date:	March 28, 1997  GUI recast
 *
 * $Log: not supported by cvs2svn $
 * Revision 4.6  2000/01/20  00:05:38  caress
 * Added pick mode and two unflag buttons.
 *
 * Revision 4.5  1999/09/15  21:02:07  caress
 * Version label now set from mb_format.h
 *
 * Revision 4.4  1999/07/16  19:21:16  caress
 * Smaller window with new dialogs for Linux.
 *
 * Revision 4.3  1998/10/05 17:45:32  caress
 * MB-System version 4.6beta
 *
 * Revision 4.2  1997/09/15  19:06:10  caress
 * Real Version 4.5
 *
 * Revision 4.1  1997/04/22  19:26:36  caress
 * Fixed startup mode.
 *
 * Revision 4.0  1997/04/21  16:57:14  caress
 * MB-System 4.5 Beta Release.
 *
 * Revision 4.0  1997/04/16  21:31:04  caress
 * Complete rewrite without uid file.
 *
 *
 */
/*
 * README: This file is appended to at file generation time.
 * Edits can be made throughout the file
 */
/*
 * Generated by the ICS Builder Xcessory (BX).
 *
 * Builder Xcessory 4.0
 * Code Generator Xcessory 2.0 (09/09/96)
 *
 */
#include <Xm/Xm.h>


/*
 * Standard includes for builtins.
 */
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <sys/stat.h>

/* X11 includes */
#include <X11/cursorfont.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Intrinsic.h>
#include <X11/keysym.h>
#include <X11/keysymdef.h>

/* mbedit widget includes */
#include "mbedit_creation.h"
#include "mb_status.h"

/*
 * Macros to make code look nicer between ANSI and K&R.
 */
#ifndef ARGLIST
#if (NeedFunctionPrototypes == 0)
#define PROTOTYPE(p)	()
#define ARGLIST(p)	p
#define ARG(a, b)	a b;
#define GRA(a, b)	a b;
#define UARG(a, b)      a b;
#define GRAU(a, b)      a b;
#else
#define PROTOTYPE(p)	p
#define ARGLIST(p)	(
#define ARG(a, b)	a b,
#define GRA(a, b)	a b)
#ifdef __cplusplus
#define UARG(a, b)      a,
#define GRAU(a, b)      a)
#else
#define UARG(a, b)      a b,
#define GRAU(a, b)      a b)
#endif
#endif
#endif

Widget		BxFindTopShell PROTOTYPE((Widget));
WidgetList	BxWidgetIdsFromNames PROTOTYPE((Widget, char*, char*));

void do_fileselection_list();

/*--------------------------------------------------------------------*/

/* additional widgets */
Widget	fileSelectionList;
Widget	fileSelectionText;

/* global defines and variables */
#define EV_MASK (ButtonPressMask | KeyPressMask | KeyReleaseMask | ExposureMask )
#define xgfont "-misc-fixed-bold-r-normal-*-13-*-75-75-c-70-iso8859-1"

/* Mode value defines */
#define	MODE_TOGGLE	0
#define	MODE_PICK	1
#define	MODE_ERASE	2
#define	MODE_RESTORE	3
#define	SHOW_FLAGGED_OFF	0
#define	SHOW_FLAGGED_ON		1
#define	OUTPUT_MODE_OUTPUT	0
#define	OUTPUT_MODE_BROWSE	1

/* global variables */
XtAppContext app_context;
Display *display, *theDisplay;
Screen *screen, *can_screen;
Window can_xid;
Window root_return, child_return;
Colormap theColormap, colormap;
GC gc;
unsigned int theCursorShape;
Cursor theCursor;
XGCValues xgcv;

XFontStruct *fontStruct;

/* Global mbedit definitions */
int	expose_plot_ok = False;
int	plot_size_max;
int	mplot_size;
int	buffer_size_max;
int	buffer_size;
int	hold_size;
int	mformat;
int	step = 5;
int	nloaded;
int	ndumped;
int	nbuffer;
int	ngood;
int	icurrent;
int	mnplot;
int	mexager;
int	mplot_width;
int	mx_interval;
int	my_interval;
int	mode_pick = MODE_TOGGLE;
int	mshow_flagged = SHOW_FLAGGED_OFF;
int	mode_output = OUTPUT_MODE_OUTPUT;
int	ttime_i[7];
int	status;

/* file opening parameters */
int	startup_file = 0;
int	use_save_file = False;

static char	input_file[128];
static char	output_file[128];
int selected = 0; /* indicates an input file is selected */

int	can_xgid;		/* XG graphics id */
Cursor myCursor;
XColor closest[2];
XColor exact[2];

int key_z_down = 0;
int key_s_down = 0;
int key_a_down = 0;
int key_d_down = 0;

/* Set the colors used for this program here. */
#define NCOLORS 6
XColor colors[NCOLORS];
unsigned int mpixel_values[NCOLORS];
XColor db_color;

/* Set these to the dimensions of your canvas drawing */
/* area, minus 1, located in mbedit.uil.              */
static int mb_borders[4] =
	{ 0, 1016, 0, 525 };

void do_filebutton_on();
void do_filebutton_off();
void set_label_string(Widget, String);
void set_label_multiline_string(Widget, String);
void get_text_string(Widget, String);

/*--------------------------------------------------------------------*/

/*      Function Name: 	BxUnmanageCB
 *
 *      Description:   	Given a string of the form:
 *		       	"(WL)[widgetName, widgetName, ...]"
 *			BxUnmanageCB attempts to convert the name to a Widget
 *			ID and unmanage the widget.
 *
 *      Arguments:     	Widget	    w:      the widget activating the callback.
 *		       	XtPointer   client: the list of widget names to attempt
 *					    to find and unmanage.
 *		       	XtPointer   call:   the call data (unused).
 *
 *      Notes:        *	This function expects that there is an application
 *		       	shell from which all other widgets are descended.
 */

/* ARGSUSED */
void
BxUnmanageCB ARGLIST((w, client, call))
ARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
    WidgetList		widgets;
    int			i;

    /*
     * This function returns a NULL terminated WidgetList.  The memory for
     * the list needs to be freed when it is no longer needed.
     */
    widgets = BxWidgetIdsFromNames(w, "BxUnmanageCB", (String)client);

    i = 0;
    while( widgets && widgets[i] != NULL )
    {
	XtUnmanageChild(widgets[i]);
	i++;
    }
    XtFree((char *)widgets);
}

/*--------------------------------------------------------------------*/

/*      Function Name: 	BxManageCB
 *
 *      Description:   	Given a string of the form:
 *		       	"(WL)[widgetName, widgetName, ...]"
 *			BxManageCB attempts to convert the name to a Widget
 *			ID and manage the widget.
 *
 *      Arguments:     	Widget	    w:      the widget activating the callback.
 *		       	XtPointer   client: the list of widget names to attempt
 *					    to find and manage.
 *		       	XtPointer   call:   the call data (unused).
 *
 *      Notes:        *	This function expects that there is an application
 *		       	shell from which all other widgets are descended.
 */

/* ARGSUSED */
void
BxManageCB ARGLIST((w, client, call))
ARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
    WidgetList		widgets;
    int			i;

    /*
     * This function returns a NULL terminated WidgetList.  The memory for
     * the list needs to be freed when it is no longer needed.
     */
    widgets = BxWidgetIdsFromNames(w, "BxManageCB", (String)client);

    i = 0;
    while( widgets && widgets[i] != NULL )
    {
	XtManageChild(widgets[i]);
	i++;
    }
    XtFree((char *)widgets);
}

/*--------------------------------------------------------------------*/

void
do_mbedit_init(argc, argv)
 int argc;
 char **argv;
{
    int	    i;
    
    /* make sure expose plots are off */
    expose_plot_ok = False;
    
    /* get additional widgets */
    fileSelectionList = (Widget) 
	XmFileSelectionBoxGetChild(fileSelectionBox, 
				    XmDIALOG_LIST);
    fileSelectionText = (Widget) 
	XmFileSelectionBoxGetChild(fileSelectionBox, 
				    XmDIALOG_TEXT);
    XtAddCallback(fileSelectionList, 
	    XmNbrowseSelectionCallback, 
	    do_fileselection_list, NULL);
	    
    XtUnmanageChild(
	    (Widget) XmFileSelectionBoxGetChild(
				    fileSelectionBox, 
				    XmDIALOG_HELP_BUTTON));

    /* Setup the entire screen. */
    display = XtDisplay(window_mbedit);
    colormap = DefaultColormap(display, XDefaultScreen(display));
    
    /* Setup just the "canvas" part of the screen. */
    theDisplay = XtDisplay(canvas_mbedit);
    can_screen = DefaultScreenOfDisplay(theDisplay);
    can_xid = XtWindow(canvas_mbedit);
    theColormap = DefaultColormap(display, XDefaultScreen(theDisplay));
    
    /* Setup the "graphics Context" for just the "canvas" */
    xgcv.background = WhitePixelOfScreen(can_screen);
    xgcv.foreground = BlackPixelOfScreen(can_screen);
    xgcv.line_width = 2;
    gc = XCreateGC(theDisplay,can_xid,GCBackground | GCForeground 
	     | GCLineWidth, &xgcv);
    
    /* Setup the font for just the "canvas" screen. */
    fontStruct = XLoadQueryFont(theDisplay, 
	     "-misc-fixed-bold-r-normal-*-13-*-75-75-c-70-iso8859-1");
    XSetFont(theDisplay,gc,fontStruct->fid);
    
    XSelectInput(theDisplay, can_xid, EV_MASK );
    
    /* Load the colors that will be used in this program. */
    status = XLookupColor(theDisplay,colormap,
	    "white",&db_color,&colors[0]);
    if(status != 0)
	    status = XAllocColor(theDisplay,colormap,&colors[0]);
    if (status == 0)
	    {
	    fprintf(stderr,"Failure to allocate color: white\n");
	    exit(-1);
	    }
    status = XLookupColor(theDisplay,colormap,
	    "black",&db_color,&colors[1]);
    if(status != 0)
	    status = XAllocColor(theDisplay,colormap,&colors[1]);
    if (status == 0)
	    {
	    fprintf(stderr,"Failure to allocate color: black\n");
	    exit(-1);
	    }
    status = XLookupColor(theDisplay,colormap,
	    "red",&db_color,&colors[2]);
    if(status != 0)
	    status = XAllocColor(theDisplay,colormap,&colors[2]);
    if (status == 0)
	    {
	    fprintf(stderr,"Failure to allocate color: red\n");
	    exit(-1);
	    }
    status = XLookupColor(theDisplay,colormap,
	    "green",&db_color,&colors[3]);
    if(status != 0)
	    status = XAllocColor(theDisplay,colormap,&colors[3]);
    if (status == 0)
	    {
	    fprintf(stderr,"Failure to allocate color: green\n");
	    exit(-1);
	    }
    status = XLookupColor(theDisplay,colormap,
	    "blue",&db_color,&colors[4]);
    if(status != 0)
	    status = XAllocColor(theDisplay,colormap,&colors[4]);
    if (status == 0)
	    {
	    fprintf(stderr,"Failure to allocate color: blue\n");
	    exit(-1);
	    }
    status = XLookupColor(theDisplay,colormap,
	    "coral",&db_color,&colors[5]);
    if(status != 0)
	    status = XAllocColor(theDisplay,colormap,&colors[5]);
    if (status == 0)
	    {
	    fprintf(stderr,"Failure to allocate color: coral\n");
	    exit(-1);
	    }
    for (i=0;i<NCOLORS;i++)
	    {
	    mpixel_values[i] = colors[i].pixel;
	    }
    
    /* Setup initial cursor. This will be changed when changing "MODE". */
    myCursor = XCreateFontCursor(theDisplay, XC_target);
    XAllocNamedColor(theDisplay,colormap,"red",&closest[0],&exact[0]);
    XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
    XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
    XDefineCursor(theDisplay,can_xid,myCursor);
    
    /* initialize graphics */
    can_xgid = xg_init(theDisplay, can_xid, mb_borders, xgfont );
    
    status = mbedit_set_graphics(can_xgid, mb_borders, 
		    NCOLORS, mpixel_values);
    
    /* initialize mbedit proper */
    status = mbedit_init(argc,argv,&startup_file);
    
    /* set up the widgets */
    do_setup_data();
    
    /* if a startup file has been specified open it */
    if (startup_file)
	    mbedit_startup_file();
    
    /* finally allow expose plots */
    expose_plot_ok = False;
}

/*--------------------------------------------------------------------*/

int do_setup_data()
{
	char value_text[128];

	/* get some default values from mbedit */
	status = mbedit_get_defaults(&plot_size_max,
			&mplot_size,&mshow_flagged,
			&buffer_size_max,&buffer_size,
			&hold_size,&mformat,
			&mplot_width,&mexager,
			&mx_interval,&my_interval,
			ttime_i,&mode_output);
			
	/* set about version label */
	sprintf(value_text, ":::t\"MB-System Release %s\":t\"%s\"", 
		MB_VERSION, MB_BUILD_DATE);
	set_label_multiline_string(label_about_version, value_text);

	/* set values of number of pings slider */
	XtVaSetValues(slider_number_pings, 
			XmNminimum, 1, 
			XmNvalue, mplot_size, 
			NULL);

	/* set values of number of pings to step slider */
	XtVaSetValues(slider_number_step, 
			XmNminimum, 1, 
			XmNvalue, step, 
			NULL);

	/* set values of buffer size slider */
	XtVaSetValues(slider_buffer_size, 
			XmNminimum, 1, 
			XmNmaximum, buffer_size_max, 
			XmNvalue, buffer_size, 
			NULL);

	/* set values of buffer size label */
	sprintf(value_text,"%d",buffer_size_max);
	set_label_string(slider_buffer_size_max_label, 
			value_text);

	/* set values of buffer hold size slider */
	XtVaSetValues(slider_buffer_hold, 
			XmNminimum, 1, 
			XmNmaximum, buffer_size_max, 
			XmNvalue, hold_size, 
			NULL);

	/* set values of buffer hold size label */
	sprintf(value_text,"%d",buffer_size_max);
	set_label_string(slider_buffer_hold_max_label, 
			value_text);

	/* set values of plot width slider */
	XtVaSetValues(slider_scale_x, 
			XmNminimum, 1, 
			XmNvalue, mplot_width, 
			NULL);

	/* set values of vertical exageration slider */
	XtVaSetValues(slider_scale_y, 
			XmNdecimalPoints, 2, 
			XmNvalue, mexager, 
			NULL);

	/* set values of x interval slider */
	XtVaSetValues(slider_x_interval, 
			XmNvalue, mx_interval, 
			NULL);

	/* set values of y interval slider */
	XtVaSetValues(slider_y_interval, 
			XmNvalue, my_interval, 
			NULL);

	/* set starting values in go to time widgets */
	sprintf(value_text,"%4.4d",ttime_i[0]);
	XmTextFieldSetString(textfield_year, value_text);

	sprintf(value_text,"%2.2d",ttime_i[1]);
	XmTextFieldSetString(textfield_month, value_text);

	sprintf(value_text,"%2.2d",ttime_i[2]);
	XmTextFieldSetString(textfield_day, value_text);

	sprintf(value_text,"%2.2d",ttime_i[3]);
	XmTextFieldSetString(textfield_hour, value_text);

	sprintf(value_text,"%2.2d",ttime_i[4]);
	XmTextFieldSetString(textfield_minute, value_text);

	sprintf(value_text,"%2.2d",ttime_i[5]);
	XmTextFieldSetString(textfield_second, value_text);

	/* set value of format text item */
	sprintf(value_text,"%2.2d",mformat);
	XmTextFieldSetString(textfield_format, value_text);
	
	/* set the output file text */
	XmTextFieldSetString(output_file_text, "");

	/* set the output mode */
	if (mode_output == OUTPUT_MODE_OUTPUT)
	    {
	    XmToggleButtonSetState(setting_output_toggle_output, 
			TRUE, TRUE);
	    XtManageChild(output_file_text);
	    XtManageChild(output_file_label);
	    }
	else
	    {
	    XmToggleButtonSetState(setting_output_toggle_browse,  
			TRUE, TRUE);
	    XtUnmanageChild(output_file_text);
	    XtUnmanageChild(output_file_label);
	    }
	    
	/* set the mode toggles */
	XmToggleButtonSetState(setting_mode_toggle_toggle, 0, FALSE);
	XmToggleButtonSetState(setting_mode_toggle_pick, 0, FALSE);
	XmToggleButtonSetState(setting_mode_toggle_erase, 0, FALSE);
	XmToggleButtonSetState(setting_mode_toggle_restore, 0, FALSE);
	if (mode_pick == MODE_TOGGLE)
	    XmToggleButtonSetState(setting_mode_toggle_toggle, 1, FALSE);
	else if (mode_pick == MODE_PICK)
	    XmToggleButtonSetState(setting_mode_toggle_pick, 1, FALSE);
	else if (mode_pick == MODE_ERASE)
	    XmToggleButtonSetState(setting_mode_toggle_erase, 1, FALSE);
	else if (mode_pick == MODE_RESTORE)
	    XmToggleButtonSetState(setting_mode_toggle_restore, 1, FALSE);
	    
	/* set the show flagged toggles */
	if (mshow_flagged == SHOW_FLAGGED_ON)
	    {
	    XmToggleButtonSetState(toggleButton_show_flagged_on, 1, FALSE);
	    XmToggleButtonSetState(toggleButton_show_flagged_off, 0, FALSE);
	    }
	else
	    {
	    XmToggleButtonSetState(toggleButton_show_flagged_on, 0, FALSE);
	    XmToggleButtonSetState(toggleButton_show_flagged_off, 1, FALSE);
	    }
	
	return(1);
}

/*--------------------------------------------------------------------*/

void
do_file_selection_cancel(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

    /* replot the data */
    status = mbedit_action_plot(mplot_width, mexager,
	    mx_interval, my_interval, 
	    mplot_size, mshow_flagged, 
	    &nbuffer, &ngood, &icurrent, &mnplot);
}

/*--------------------------------------------------------------------*/

void
do_expose(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

    /* replot the data */
    if (expose_plot_ok == True)
	    status = mbedit_action_plot(mplot_width, mexager,
		    mx_interval, my_interval, 
		    mplot_size, mshow_flagged, 
		    &nbuffer, &ngood, &icurrent, &mnplot);
}

/*--------------------------------------------------------------------*/

void
do_mode_toggle(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

    mode_pick = MODE_TOGGLE;

    myCursor = XCreateFontCursor(theDisplay, XC_target);
    XAllocNamedColor(theDisplay,colormap,"red",&closest[0],&exact[0]);
    XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
    XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
    XDefineCursor(theDisplay,can_xid,myCursor);
}

/*--------------------------------------------------------------------*/

void
do_mode_pick(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

    mode_pick = MODE_PICK;

    myCursor = XCreateFontCursor(theDisplay, XC_target);
    XAllocNamedColor(theDisplay,colormap,"red",&closest[0],&exact[0]);
    XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
    XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
    XDefineCursor(theDisplay,can_xid,myCursor);
}

/*--------------------------------------------------------------------*/

void
do_mode_erase(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

    mode_pick = MODE_ERASE;

    myCursor = XCreateFontCursor(theDisplay, XC_exchange);
    XAllocNamedColor(theDisplay,colormap,"red",&closest[0],&exact[0]);
    XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
    XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
    XDefineCursor(theDisplay,can_xid,myCursor);
}

/*--------------------------------------------------------------------*/

void
do_mode_restore(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

    mode_pick = MODE_RESTORE;

    myCursor = XCreateFontCursor(theDisplay, XC_exchange);
    XAllocNamedColor(theDisplay,colormap,"green",&closest[0],&exact[0]);
    XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
    XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
    XDefineCursor(theDisplay,can_xid,myCursor);
}

/*--------------------------------------------------------------------*/

void
do_scale_y(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmScaleCallbackStruct *acs=(XmScaleCallbackStruct*)call_data;

    int	maxx;
    char	label[10];

    mexager = acs->value;

    /* if slider set to minimum value, half the value range;
	    if slider set to maximum value,  double the range */
    XtVaGetValues(slider_scale_y, 
		    XmNmaximum, &maxx, 
		    NULL);
    if (mexager == 1 || mexager == maxx)
	    {
	    if (mexager == 1)
		    maxx = maxx/2;
	    else
		    maxx = 2*maxx;
	    if (maxx < 2)
		    maxx = 2;
	    XtVaSetValues(slider_scale_y, 
		    XmNmaximum, maxx, 
		    NULL);
	    sprintf(label, "%.2f", (double)(maxx/100.));
	    set_label_string(slider_scale_y_max_label, 
			    label);
	    }

    /* replot the data */
    status = mbedit_action_plot(mplot_width, mexager,
	    mx_interval, my_interval, 
	    mplot_size, mshow_flagged, 
	    &nbuffer, &ngood, &icurrent, &mnplot);
    if (status == 0) XBell(theDisplay,100);
	
}

/*--------------------------------------------------------------------*/

void
do_fileselection_init(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
}

/*--------------------------------------------------------------------*/

void
do_fileselection_list(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

    static char selection_text[128];
    int	form;
    char	value_text[10];

    /* get selected text */
    get_text_string(fileSelectionText, selection_text);

    /* get output file */
    if((int)strlen(selection_text) > 0)
	    {
	    /* look for MB suffix convention */
	    form = mformat;
	    if ((status = mbedit_get_output_file(selection_text, 
			    output_file, &form)) == MB_SUCCESS)
		{
		mformat = form;
		sprintf(value_text,"%d",mformat);
		XmTextFieldSetString(
		    textfield_format, 
		    value_text);
		
		/* now set the output filename text widget */
		XmTextFieldSetString(output_file_text, 
			output_file);
		XmTextFieldSetCursorPosition(output_file_text, 
			strlen(output_file));
		}
	    }
}

/*--------------------------------------------------------------------*/

void
do_scale_x(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmScaleCallbackStruct *acs=(XmScaleCallbackStruct*)call_data;

    int	maxx;
    char	label[10];

    mplot_width = acs->value;

    /* if slider set to minimum value, half the value range;
	    if slider set to maximum value,  double the range */
    XtVaGetValues(slider_scale_x, 
		    XmNmaximum, &maxx, 
		    NULL);
    if (mplot_width == 1 || mplot_width == maxx)
	    {
	    if (mplot_width == 1)
		    maxx = maxx/2;
	    else
		    maxx = 2*maxx;
	    if (maxx < 2)
		    maxx = 2;
	    XtVaSetValues(slider_scale_x, 
		    XmNmaximum, maxx, 
		    NULL);
	    sprintf(label, "%d", maxx);
	    set_label_string(slider_scale_x_max_label, 
			    label);
	    }

    /* replot the data */
    status = mbedit_action_plot(mplot_width, mexager,
	    mx_interval, my_interval, 
	    mplot_size, mshow_flagged, 
	    &nbuffer, &ngood, &icurrent, &mnplot);
    if (status == 0) XBell(theDisplay,100);
	
}

/*--------------------------------------------------------------------*/

int do_reset_scale_x(pwidth, maxx)
	int pwidth;
	int maxx;
{
	char	label[10];

	mplot_width = pwidth;
	
	/* check max value */
	if (pwidth > maxx - 1)
		{
		maxx = 2 * pwidth;
		if (maxx < 2)
			maxx = 2;
		}
	
	/* reset the widget */
	XtVaSetValues(slider_scale_x, 
			XmNvalue, mplot_width, 
			XmNmaximum, maxx, 
			NULL);
	sprintf(label, "%d", maxx);
	set_label_string(slider_scale_x_max_label, 
			label);	

	return(1);
	
}

/*--------------------------------------------------------------------*/

void
do_output_browse(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmToggleButtonCallbackStruct *acs=(XmToggleButtonCallbackStruct*)call_data;

    /* set values if needed */
    if (acs->reason == XmCR_VALUE_CHANGED && acs->set)
	    {
	    mode_output = OUTPUT_MODE_BROWSE;
	    XtUnmanageChild(output_file_text);
	    XtUnmanageChild(output_file_label);
	    }
}

/*--------------------------------------------------------------------*/

void
do_x_interval(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmScaleCallbackStruct *acs=(XmScaleCallbackStruct*)call_data;

    int	maxx;
    char	label[10];

    mx_interval = acs->value;

    /* if slider set to minimum value, half the value range;
	    if slider set to maximum value,  double the range */
    XtVaGetValues(slider_x_interval, 
		    XmNmaximum, &maxx, 
		    NULL);
    if (mx_interval == 1 || mx_interval == maxx)
	    {
	    if (mx_interval == 1)
		    maxx = maxx/2;
	    else
		    maxx = 2*maxx;
	    if (maxx < 2)
		    maxx = 2;
	    XtVaSetValues(slider_x_interval, 
		    XmNmaximum, maxx, 
		    NULL);
	    sprintf(label, "%d", maxx);
	    set_label_string(slider_x_max_interval_label, 
			    label);
	    }

    /* replot the data */
    status = mbedit_action_plot(mplot_width, mexager,
	    mx_interval, my_interval, 
	    mplot_size, mshow_flagged, 
	    &nbuffer, &ngood, &icurrent, &mnplot);
    if (status == 0) XBell(theDisplay,100);
}

/*--------------------------------------------------------------------*/

void
do_y_interval(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmScaleCallbackStruct *acs=(XmScaleCallbackStruct*)call_data;

    int	maxx;
    char	label[10];

    my_interval = acs->value;

    /* if slider set to minimum value, half the value range;
	    if slider set to maximum value,  double the range */
    XtVaGetValues(slider_y_interval, 
		    XmNmaximum, &maxx, 
		    NULL);
    if (my_interval == 1 || my_interval == maxx)
	    {
	    if (my_interval == 1)
		    maxx = maxx/2;
	    else
		    maxx = 2*maxx;
	    if (maxx < 2)
		    maxx = 2;
	    XtVaSetValues(slider_y_interval, 
		    XmNmaximum, maxx, 
		    NULL);
	    sprintf(label, "%d", maxx);
	    set_label_string(slider_y_max_interval_label, 
			    label);
	    }

    /* replot the data */
    status = mbedit_action_plot(mplot_width, mexager,
	    mx_interval, my_interval, 
	    mplot_size, mshow_flagged, 
	    &nbuffer, &ngood, &icurrent, &mnplot);
    if (status == 0) XBell(theDisplay,100);
}

/*--------------------------------------------------------------------*/

void
do_load_ok(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmFileSelectionBoxCallbackStruct *acs=(XmFileSelectionBoxCallbackStruct*)call_data;

    static  char format_text[40];

    if (selected > 0)
	    {
	    /* read the mbio format number from the screen */
	    get_text_string(textfield_format, format_text);
	    sscanf(format_text, "%d", &mformat);

	    /* read the output file name */
	    get_text_string(output_file_text, output_file);

	    /* process the output file name */
	    status = mbedit_set_output_file(output_file);
	    
	    /* turn off expose plots */
	    expose_plot_ok = False;

	    /* process input file name */
	    status = mbedit_action_open(input_file, mformat,
			    use_save_file, 
			    mode_output,
			    mplot_width, mexager, mx_interval,
			    my_interval, mplot_size, mshow_flagged, 
			    &buffer_size, &buffer_size_max, 
			    &hold_size,
			    &ndumped, &nloaded, &nbuffer,
			    &ngood, &icurrent, &mnplot);
	    if (status == 0) XBell(theDisplay,100);
	    
	    /* display data from chosen file */
	    status = mbedit_action_plot(mplot_width, mexager,
		    mx_interval, my_interval, 
		    mplot_size, mshow_flagged, 
		    &nbuffer, &ngood, &icurrent, &mnplot);
	    if (status == 0) XBell(theDisplay,100);

	    /* set widget values */
	    do_setup_data();
	    
	    /* turn on expose plots */
	    expose_plot_ok = True;

	    }
    else
	    {
	    fprintf(stderr,"\nno input multibeam file selected\n");
	    }
}

/*--------------------------------------------------------------------*/

void
do_load_check(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmFileSelectionBoxCallbackStruct *acs=(XmFileSelectionBoxCallbackStruct*)call_data;

    struct stat file_status;
    int	fstat;
    char    *input_file_ptr;
    char    save_file[128];
    
    /* set use save file flag to False */
    use_save_file = False;

    /* read the input file name */
    if(!XmStringGetLtoR(acs->value,
	    XmSTRING_DEFAULT_CHARSET, 
	    &input_file_ptr))
	    {
	    selected = 0;
	    }
    else
	    {
	    selected = 1;
	    strncpy(input_file, input_file_ptr, 128);
	    XtFree(input_file_ptr);
	    }

    if (selected > 0)
	    {
	    /* check for edit save file */
	    sprintf(save_file, "%s.mbesf", input_file);
	    fstat = stat(save_file, &file_status);
	    
	    /* if save file exists bring up dialog asking
		if it should be used */
	    if (fstat == 0 
		&& (file_status.st_mode & S_IFMT) != S_IFDIR)
		{
		XtManageChild(bulletinBoard_editsave);
		}
		
	    /* else just try to load the data */
	    else
		{
		(void) do_load_ok(w, client_data, call_data);
		}
	    }
    else
	    {
	    fprintf(stderr,"\nno input multibeam file selected\n");
	    }
}

/*--------------------------------------------------------------------*/

void
do_load_ok_with_save(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmFileSelectionBoxCallbackStruct *acs=(XmFileSelectionBoxCallbackStruct*)call_data;

    /* set the use save file flag to True */
    use_save_file = True;
    
    /* load the file */
    (void) do_load_ok(w, client_data, call_data);
}

/*--------------------------------------------------------------------*/

void
do_filebutton_on()
{
		XtVaSetValues(pushButton_file, 
			XmNsensitive, True, 
			NULL);
}

/*--------------------------------------------------------------------*/

void
do_filebutton_off()
{
		XtVaSetValues(pushButton_file, 
			XmNsensitive, False, 
			NULL);
}

/*--------------------------------------------------------------------*/

void
do_forward(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

    status = mbedit_action_step(step,mplot_width,mexager,mx_interval,
				my_interval,mplot_size,mshow_flagged,
				&nbuffer,&ngood,&icurrent,&mnplot);
    if (status == 0) XBell(theDisplay,100);

}

/*--------------------------------------------------------------------*/

void
do_quit(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
    
    status = mbedit_action_quit(buffer_size,&ndumped,&nloaded,
		    &nbuffer,&ngood,&icurrent);
    if (status == 0) XBell(theDisplay,100);
    
    exit(0);

}

/*--------------------------------------------------------------------*/

void
do_event(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmDrawingAreaCallbackStruct *acs=(XmDrawingAreaCallbackStruct*)call_data;
    static Position x_loc, y_loc;

    XEvent  *event = acs->event;

    KeySym keysym;
    int key_num;
    char buffer[1];
    int actual;
    static char *pings_to_first_step_text;
    int *x, *y;
    int root_x_return, root_y_return,win_x,win_y;
    unsigned int mask_return;
    int doit;

    /* check for data file loaded at startup */
    if (startup_file)
	    {
	    startup_file = 0;
	    status = mbedit_action_plot(mplot_width, mexager,
		    mx_interval, my_interval, 
		    mplot_size, mshow_flagged, 
		    &nbuffer, &ngood, &icurrent, &mnplot);
	    if (status == 0) XBell(theDisplay,100);
	    } /* end startup file */

    /* If there is input in the drawing area */
    if (acs->reason == XmCR_INPUT)
    {
      /* Deal with KeyPress events */
      if(event->xany.type == KeyPress)
      {
      /* Get key pressed - buffer[0] */
      actual = XLookupString((XKeyEvent *)event, 
		    buffer, 1, &keysym, NULL);

      /* process events */
      switch (buffer[0])
	    {
	    case 'M':
	    case 'm':
	    case 'Z':
	    case 'z':
		    status = mbedit_action_mouse_pick(
			    x_loc, y_loc,
			    mplot_width,mexager,
			    mx_interval,my_interval,
			    mplot_size,mshow_flagged,
			    &nbuffer,&ngood,&icurrent,&mnplot);
		    status = mbedit_action_bad_ping(
			    mplot_width,mexager,
			    mx_interval,my_interval,
			    mplot_size,mshow_flagged,
			    &nbuffer,&ngood,&icurrent,&mnplot);
		    key_z_down = 1;
		    key_s_down = 0;
		    key_a_down = 0;
		    key_d_down = 0;
		    break;
	    case 'K':
	    case 'k':
	    case 'S':
	    case 's':
		    status = mbedit_action_good_ping(
			    mplot_width,mexager,
			    mx_interval,my_interval,
			    mplot_size,mshow_flagged,
			    &nbuffer,&ngood,&icurrent,&mnplot);
		    key_z_down = 0;
		    key_s_down = 1;
		    key_a_down = 0;
		    key_d_down = 0;
		    break;
	    case 'J':
	    case 'j':
	    case 'A':
	    case 'a':
		    status = mbedit_action_left_ping(
			    mplot_width,mexager,
			    mx_interval,my_interval,
			    mplot_size,mshow_flagged,
			    &nbuffer,&ngood,&icurrent,&mnplot);
		    key_z_down = 0;
		    key_s_down = 0;
		    key_a_down = 1;
		    key_d_down = 0;
		    break;
	    case 'L':
	    case 'l':
	    case 'D':
	    case 'd':
		    status = mbedit_action_right_ping(
			    mplot_width,mexager,
			    mx_interval,my_interval,
			    mplot_size,mshow_flagged,
			    &nbuffer,&ngood,&icurrent,&mnplot);
		    key_z_down = 0;
		    key_s_down = 0;
		    key_a_down = 0;
		    key_d_down = 1;
		    break;
	    case '!':
		    status = mbedit_action_zero_ping(
			    mplot_width,mexager,
			    mx_interval,my_interval,
			    mplot_size,mshow_flagged,
			    &nbuffer,&ngood,&icurrent,&mnplot);
		    break;
	    case 'U':
	    case 'u':
	    case 'Q':
	    case 'q':
			    {
			    mode_pick = MODE_TOGGLE;
			    XmToggleButtonSetState(setting_mode_toggle_toggle, 1, FALSE);
			    XmToggleButtonSetState(setting_mode_toggle_pick, 0, FALSE);
			    XmToggleButtonSetState(setting_mode_toggle_erase, 0, FALSE);
			    XmToggleButtonSetState(setting_mode_toggle_restore, 0, FALSE);

			    myCursor = XCreateFontCursor(theDisplay, XC_target);
			    XAllocNamedColor(theDisplay,colormap,"red",&closest[0],&exact[0]);
			    XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
			    XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
			    XDefineCursor(theDisplay,can_xid,myCursor);
			    }
		    break;
	    case 'I':
	    case 'i':
	    case 'W':
	    case 'w':
			    {
			    mode_pick = MODE_PICK;
			    XmToggleButtonSetState(setting_mode_toggle_toggle, 0, FALSE);
			    XmToggleButtonSetState(setting_mode_toggle_pick, 1, FALSE);
			    XmToggleButtonSetState(setting_mode_toggle_erase, 0, FALSE);
			    XmToggleButtonSetState(setting_mode_toggle_restore, 0, FALSE);

			    myCursor = XCreateFontCursor(theDisplay, XC_target);
			    XAllocNamedColor(theDisplay,colormap,"red",&closest[0],&exact[0]);
			    XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
			    XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
			    XDefineCursor(theDisplay,can_xid,myCursor);
			    }
		    break;
	    case 'O':
	    case 'o':
	    case 'E':
	    case 'e':
			    {
			    mode_pick = MODE_ERASE;
			    XmToggleButtonSetState(setting_mode_toggle_toggle, 0, FALSE);
			    XmToggleButtonSetState(setting_mode_toggle_pick, 0, FALSE);
			    XmToggleButtonSetState(setting_mode_toggle_erase, 1, FALSE);
			    XmToggleButtonSetState(setting_mode_toggle_restore, 0, FALSE);

			    myCursor = XCreateFontCursor(theDisplay, XC_exchange);
			    XAllocNamedColor(theDisplay,colormap,"red",&closest[0],&exact[0]);
			    XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
			    XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
			    XDefineCursor(theDisplay,can_xid,myCursor);
			    }
		    break;
	    case 'P':
	    case 'p':
	    case 'R':
	    case 'r':
			    {
			    mode_pick = MODE_RESTORE;
			    XmToggleButtonSetState(setting_mode_toggle_toggle, 0, FALSE);
			    XmToggleButtonSetState(setting_mode_toggle_pick, 0, FALSE);
			    XmToggleButtonSetState(setting_mode_toggle_erase, 0, FALSE);
			    XmToggleButtonSetState(setting_mode_toggle_restore, 1, FALSE);

			    myCursor = XCreateFontCursor(theDisplay, XC_exchange);
			    XAllocNamedColor(theDisplay,colormap,"green",&closest[0],&exact[0]);
			    XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
			    XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
			    XDefineCursor(theDisplay,can_xid,myCursor);
			    }
		    break;
	    default:
		    break;
	  } /* end of key switch */

       } /* end of key press events */

      /* Deal with KeyRelease events */
      if(event->xany.type == KeyRelease)
      {
      /* Get key pressed - buffer[0] */
      actual = XLookupString((XKeyEvent *)event, 
		    buffer, 1, &keysym, NULL);

      /* process events */
      switch (buffer[0])
	    {
	    case 'M':
	    case 'm':
	    case 'Z':
	    case 'z':
		    key_z_down = 0;
		    break;
	    case 'K':
	    case 'k':
	    case 'S':
	    case 's':
		    key_s_down = 0;
		    break;
	    case 'J':
	    case 'j':
	    case 'A':
	    case 'a':
		    key_a_down = 0;
		    break;
	    case 'L':
	    case 'l':
	    case 'D':
	    case 'd':
		    key_d_down = 0;
		    break;
	    default:
		    break;
	  } /* end of key switch */

       } /* end of key release events */

      /* Check for mouse pressed and not pressed and released. */
      if(event->xany.type == ButtonPress)
      {
	  /* If left mouse button is pushed then pick, erase or restore. */
	  if(event->xbutton.button == 1)
	  {
	    x_loc = event->xbutton.x;
	    y_loc = event->xbutton.y;

	    doit = 1;
	    while (doit)
		{

		if(mode_pick == MODE_TOGGLE)
		    status = mbedit_action_mouse_toggle(
			    x_loc, y_loc,
			    mplot_width,mexager,
			    mx_interval,my_interval,
			    mplot_size,mshow_flagged,
			    &nbuffer,&ngood,&icurrent,&mnplot);
		else if(mode_pick == MODE_PICK)
		    status = mbedit_action_mouse_pick(
			    x_loc, y_loc,
			    mplot_width,mexager,
			    mx_interval,my_interval,
			    mplot_size,mshow_flagged,
			    &nbuffer,&ngood,&icurrent,&mnplot);
		else if (mode_pick == MODE_ERASE) 
		    status = mbedit_action_mouse_erase(
			    x_loc, y_loc,
			    mplot_width,mexager,
			    mx_interval,my_interval,
			    mplot_size,mshow_flagged,
			    &nbuffer,&ngood,&icurrent,&mnplot);
		else if (mode_pick == MODE_RESTORE) 
		    status = mbedit_action_mouse_restore(
			    x_loc, y_loc,
			    mplot_width,mexager,
			    mx_interval,my_interval,
			    mplot_size,mshow_flagged,
			    &nbuffer,&ngood,&icurrent,&mnplot);
		if (status == 0) 
			XBell(theDisplay,100);
		else if (key_z_down)
		    {
		    status = mbedit_action_bad_ping(
			    mplot_width,mexager,
			    mx_interval,my_interval,
			    mplot_size,mshow_flagged,
			    &nbuffer,&ngood,&icurrent,&mnplot);
		    }
		else if (key_s_down)
		    {
		    status = mbedit_action_good_ping(
			    mplot_width,mexager,
			    mx_interval,my_interval,
			    mplot_size,mshow_flagged,
			    &nbuffer,&ngood,&icurrent,&mnplot);
		    }
		else if (key_a_down)
		    {
		    status = mbedit_action_left_ping(
			    mplot_width,mexager,
			    mx_interval,my_interval,
			    mplot_size,mshow_flagged,
			    &nbuffer,&ngood,&icurrent,&mnplot);
		    }
		else if (key_d_down)
		    {
		    status = mbedit_action_right_ping(
			    mplot_width,mexager,
			    mx_interval,my_interval,
			    mplot_size,mshow_flagged,
			    &nbuffer,&ngood,&icurrent,&mnplot);
		    }

		    status = XQueryPointer(theDisplay,can_xid,
			    &root_return,&child_return,&root_x_return,
			    &root_y_return, &win_x, &win_y, &mask_return);

		    x_loc = win_x;
		    y_loc = win_y;

		    /* If the button is still pressed then read the location */
		    /* of the pointer and run the action mouse function again */
		    if(mask_return == 256 
			&& mode_pick != MODE_TOGGLE 
			&& mode_pick != MODE_PICK)
		       doit = 1;
		    else
		       doit = 0;
		}

	    } /* end of left button events */

	    /* If middle mouse button is pushed then scroll in reverse. */
	    if(event->xbutton.button == 2)
	    {
		    status = mbedit_action_step(-step,mplot_width,mexager,
				    mx_interval,my_interval,
				    mplot_size,mshow_flagged,
				    &nbuffer,&ngood,&icurrent,&mnplot);
		    if (status == 0) XBell(theDisplay,100);
	    } /* end of middle button events */

	    /* If right mouse button is pushed then scroll forward. */
	    if(event->xbutton.button == 3)
	    {
		    status = mbedit_action_step(step,mplot_width,mexager,
				    mx_interval,my_interval,
				    mplot_size,mshow_flagged,
				    &nbuffer,&ngood,&icurrent,&mnplot);
		    if (status == 0) XBell(theDisplay,100);
	    } /* end of right button events */	
      } /* end of button pressed events */
    } /* end of inputs from window */
} /* end do_event function */

/*--------------------------------------------------------------------*/

void
do_unflag_view( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;

    status = mbedit_action_unflag_view(
	    mplot_width,mexager,
	    mx_interval,my_interval,
	    mplot_size,mshow_flagged,
	    &nbuffer,&ngood,&icurrent,&mnplot);
}

/*--------------------------------------------------------------------*/

void
do_unflag_all( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;

    status = mbedit_action_unflag_all(
	    mplot_width,mexager,
	    mx_interval,my_interval,
	    mplot_size,mshow_flagged,
	    &nbuffer,&ngood,&icurrent,&mnplot);
}

/*--------------------------------------------------------------------*/

void
do_next_buffer(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
    
    int	    quit;
	    
    /* turn off expose plots */
    expose_plot_ok = False;

    /* get next buffer */
    status = mbedit_action_next_buffer(hold_size,buffer_size,
		    mplot_width,mexager,
		    mx_interval,my_interval,
		    mplot_size,mshow_flagged,
		    &ndumped,&nloaded,&nbuffer,
		    &ngood,&icurrent,&mnplot,&quit);
    if (status == 0) XBell(theDisplay,100);

    /* set widget values */
    do_setup_data();
	    
    /* turn on expose plots */
    expose_plot_ok = True;
    
    /* quit if in GUI mode */
    if (quit)
	    exit(0);

}

/*--------------------------------------------------------------------*/

void
do_number_step(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmScaleCallbackStruct *acs=(XmScaleCallbackStruct*)call_data;

    int	maxx;
    char	label[10];

    step = acs->value;

    /* if slider set to minimum value, half the value range;
	    if slider set to maximum value,  double the range */
    XtVaGetValues(slider_number_step, 
		    XmNmaximum, &maxx, 
		    NULL);
    if (step == 1 || step == maxx)
	    {
	    if (step == 1)
		    maxx = maxx/2;
	    else
		    maxx = 2*maxx;
	    if (maxx < 2)
		    maxx = 2;
	    XtVaSetValues(slider_number_step, 
		    XmNmaximum, maxx, 
		    NULL);
	    sprintf(label, "%d", maxx);
	    set_label_string(slider_number_max_step_label, 
			    label);
	    }
}

/*--------------------------------------------------------------------*/

void
do_show_flagged_off(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
    
    mshow_flagged = SHOW_FLAGGED_OFF;

    /* replot the data */
    status = mbedit_action_plot(mplot_width, mexager,
	    mx_interval, my_interval, 
	    mplot_size, mshow_flagged, 
	    &nbuffer, &ngood, &icurrent, &mnplot);
}

/*--------------------------------------------------------------------*/

void
do_show_flagged_on(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;
    
    mshow_flagged = SHOW_FLAGGED_ON;

    /* replot the data */
    status = mbedit_action_plot(mplot_width, mexager,
	    mx_interval, my_interval, 
	    mplot_size, mshow_flagged, 
	    &nbuffer, &ngood, &icurrent, &mnplot);
}
/*--------------------------------------------------------------------*/

void
do_buffer_hold(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmScaleCallbackStruct *acs=(XmScaleCallbackStruct*)call_data;

    hold_size = acs->value;	
}

/*--------------------------------------------------------------------*/

void
do_buffer_size(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmScaleCallbackStruct *acs=(XmScaleCallbackStruct*)call_data;

    buffer_size = acs->value;	
	
}

/*--------------------------------------------------------------------*/

void
do_done(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

    int	quit;
	    
    /* turn off expose plots */
    expose_plot_ok = False;
    
    status = mbedit_action_done(buffer_size,&ndumped,&nloaded,
		    &nbuffer,&ngood,&icurrent,&quit);
    if (status == 0) XBell(theDisplay,100);
	    
    /* turn on expose plots */
    expose_plot_ok = True;
    
    if (quit)
	    exit(0);
}

/*--------------------------------------------------------------------*/

void
do_reverse(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

    status = mbedit_action_step(-step,mplot_width,mexager,
	    mx_interval,my_interval,mplot_size,mshow_flagged,&nbuffer,
	    &ngood,&icurrent,&mnplot);
    if (status == 0) XBell(theDisplay,100);

}

/*--------------------------------------------------------------------*/

void
do_output_output(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmToggleButtonCallbackStruct *acs=(XmToggleButtonCallbackStruct*)call_data;

    /* set values if needed */
    if (acs->reason == XmCR_VALUE_CHANGED && acs->set)
	    {
	    mode_output = OUTPUT_MODE_OUTPUT;
	    XtManageChild(output_file_text);
	    XtManageChild(output_file_label);
	    }
}

/*--------------------------------------------------------------------*/

void
do_number_pings(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmScaleCallbackStruct *acs=(XmScaleCallbackStruct*)call_data;

    int	maxx;
    char	label[10];

    /* Read the value of the slider bar for number of pings displayed */
    mplot_size = acs->value;

    /* if slider set to minimum value, half the value range;
	    if slider set to maximum value,  double the range */
    XtVaGetValues(slider_number_pings, 
		    XmNmaximum, &maxx, 
		    NULL);
    if (mplot_size == 1 || mplot_size == maxx)
	    {
	    if (mplot_size == 1)
		    maxx = maxx/2;
	    else
		    maxx = 2*maxx;
	    if (maxx > plot_size_max)
		    maxx = plot_size_max;
	    if (maxx < 2)
		    maxx = 2;
	    XtVaSetValues(slider_number_pings, 
		    XmNmaximum, maxx, 
		    NULL);
	    sprintf(label, "%d", maxx);
	    set_label_string(slider_num_pings_max_label, 
			    label);
	    }

    /* replot the data */
    status = mbedit_action_plot(mplot_width, mexager,
	    mx_interval, my_interval, 
	    mplot_size, mshow_flagged, 
	    &nbuffer, &ngood, &icurrent, &mnplot);
    if (status == 0) XBell(theDisplay,100);
}

/*--------------------------------------------------------------------*/

void
do_goto_apply(w, client_data, call_data)
 Widget w;
 XtPointer client_data;
 XtPointer call_data;
{
    XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call_data;

    char    value_text[128];

    get_text_string(textfield_year, value_text);
    sscanf(value_text, "%d", &ttime_i[0]);

    get_text_string(textfield_month, value_text);
    sscanf(value_text, "%d", &ttime_i[1]);

    get_text_string(textfield_day, value_text);
    sscanf(value_text, "%d", &ttime_i[2]);

    get_text_string(textfield_hour, value_text);
    sscanf(value_text, "%d", &ttime_i[3]);

    get_text_string(textfield_minute, value_text);
    sscanf(value_text, "%d", &ttime_i[4]);

    get_text_string(textfield_second, value_text);
    sscanf(value_text, "%d", &ttime_i[5]);

    ttime_i[6] = 0;
	    
    /* turn off expose plots */
    expose_plot_ok = False;

    status = mbedit_action_goto(ttime_i,hold_size,buffer_size,
		    mplot_width,mexager,
		    mx_interval,my_interval,
		    mplot_size,mshow_flagged,
		    &ndumped,&nloaded,&nbuffer,
		    &ngood,&icurrent,&mnplot);
    if (status == 0) XBell(theDisplay,100);
	    
    /* turn on expose plots */
    expose_plot_ok = True;
}

/*--------------------------------------------------------------------*/

int
do_wait_until_viewed(app)
XtAppContext app;
{
    Widget  topshell;
    Window  topwindow;
    XWindowAttributes	xwa;
    XEvent  event;
    
    /* set app_context */
    app_context = app;
    
    /* find the top level shell */
    for (topshell = window_mbedit; 
	    !XtIsTopLevelShell(topshell);
	    topshell = XtParent(topshell))
	;
	
    /* keep processing events until it is viewed */
    if (XtIsRealized(topshell))
	{
	topwindow = XtWindow(topshell);
	
	/* wait for the window to be mapped */
	while (XGetWindowAttributes(
			XtDisplay(window_mbedit), 
			topwindow, &xwa)
		&& xwa.map_state != IsViewable)
	    {
	    XtAppNextEvent(app_context, &event);
	    XtDispatchEvent(&event);
	    }
	}
	
    XmUpdateDisplay(topshell);
	
    return(1);
    
}

/*--------------------------------------------------------------------*/

int
do_message_on(message)
char	*message;
{
    Widget  diashell, topshell;
    Window  diawindow, topwindow;
    XWindowAttributes	xwa;
    XEvent  event;
    
    set_label_string(label_message, message);
    XtManageChild(bulletinBoard_message);
    
    /* force the label to be visible */
    for (diashell = label_message; 
	    !XtIsShell(diashell); 
	    diashell = XtParent(diashell))
	;
    for (topshell = diashell; 
	    !XtIsTopLevelShell(topshell);
	    topshell = XtParent(topshell))
	;
    if (XtIsRealized(diashell) && XtIsRealized(topshell))
	{
	diawindow = XtWindow(diashell);
	topwindow = XtWindow(topshell);
	
	/* wait for the dialog to be mapped */
	while (XGetWindowAttributes(display, diawindow, &xwa)
		&& xwa.map_state != IsViewable)
	    {
	    if (XGetWindowAttributes(display, topwindow, &xwa)
		    && xwa.map_state != IsViewable)
		break;
		
	    XtAppNextEvent(app_context, &event);
	    XtDispatchEvent(&event);
	    }
	}
	
    XmUpdateDisplay(topshell);
	
    return(1);
}

/*--------------------------------------------------------------------*/

int
do_message_off()
{
    XtUnmanageChild(bulletinBoard_message);
    XSync(XtDisplay(bulletinBoard_message), 0);
    XmUpdateDisplay(window_mbedit);
	
    return(1);
}

/*--------------------------------------------------------------------*/

int
do_error_dialog(s1, s2, s3)
char	*s1;
char	*s2;
char	*s3;
{
    set_label_string(label_error_one, s1);
    set_label_string(label_error_two, s2);
    set_label_string(label_error_three, s3);
    XtManageChild(bulletinBoard_error);
    XBell(theDisplay,100);
	
    return(1);
}

/*--------------------------------------------------------------------*/
/* Change label string cleanly, no memory leak */
/*--------------------------------------------------------------------*/

void set_label_string(Widget w, String str)
{
    XmString xstr;
    
    xstr = XmStringCreateLocalized( str );
    if ( xstr != NULL ) 
	XtVaSetValues(w, 
	    XmNlabelString, xstr, 
	    NULL);
    else 
	XtWarning("Failed to update labelString");

    XmStringFree( xstr );
}
/*--------------------------------------------------------------------*/
/* Change multiline label string cleanly, no memory leak */
/*--------------------------------------------------------------------*/

void set_label_multiline_string(Widget w, String str)
{
    XmString xstr;
    int      argok;

    xstr = (XtPointer)BX_CONVERT(w, str, XmRXmString, 0, &argok);
    if ( xstr != NULL && argok)
        XtVaSetValues(w,
            XmNlabelString, xstr,
            NULL);
    else
        XtWarning("Failed to update labelString");

    XmStringFree( xstr );
}
/*--------------------------------------------------------------------*/
/* Get text item string cleanly, no memory leak */
/*--------------------------------------------------------------------*/

void get_text_string(Widget w, String str)
{
    char	*str_tmp;
    
    str_tmp = (char *) XmTextGetString(w);
    strcpy(str, str_tmp);
    XtFree(str_tmp);
}
/*--------------------------------------------------------------------*/
/*      Function Name:	BxPopupCB
 *
 *      Description:   	This function accepts a string of the form:
 *			"(WL)[widgetName, widgetName, ...]"
 *			It attempts to convert the widget names to Widget IDs
 *			and then popup the widgets WITHOUT any grab.
 *
 *      Arguments:      Widget		w:	the activating widget.
 *			XtPointer	client:	the string of widget names to
 *						popup.
 *			XtPointer	call:	the call data (unused).
 *
 *      Notes:        * This function expects that there is an application
 *                      shell from which all other widgets are descended.
 *		      * BxPopupCB can only work on Shell widgets.  It will not
 *			work on other object types.  This is because popping up
 *			can only be done to a shell.  A check is made using
 *			XtIsShell() and an appropriate error is output if the
 *			passed object is not a Shell.
 */

/* ARGSUSED */
void
BxPopupCB ARGLIST((w, client, call))
ARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
    WidgetList		widgets;
    int			i;

    /*
     * This function returns a NULL terminated WidgetList.  The memory for
     * the list needs to be freed when it is no longer needed.
     */
    widgets = BxWidgetIdsFromNames(w, "BxPopupCB", (String)client);

    i = 0;
    while( widgets && widgets[i] != NULL )
    {
	if ( XtIsShell(widgets[i]) )
	{
	    XtPopup(widgets[i], XtGrabNone);
	}
	else
	{
	    printf("Callback Error (BxPopupCB):\n\t\
Object %s is not a Shell\n", XtName(widgets[i]));
	}
	i++;
    }
    XtFree((char *)widgets);
}
