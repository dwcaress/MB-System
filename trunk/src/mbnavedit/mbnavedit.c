/*
 * Generated by the ICS builderXcessory (BX).
 *
 *
 * Builder Xcessory 3.0.
 *
 */
/*
 * Standard include files
 */
#include <stdio.h>
/*
 * MOTIF and X include files needed for widget
 * creation and toolkit initialization.
 */
#include <Xm/Xm.h>
#include <X11/cursorfont.h>
#include "mbnavedit_creation.h"

#define MBNAVEDIT_DECLARE_GLOBALS
#include "mbnavedit_extrawidgets.h"
#include "mbnavedit.h"
/*
 * Application name and class definition.
 */
#define BX_APP_NAME "mbnavedit"
#define BX_APP_CLASS "MB-System Product"

/*
 * Font, character, and event defines
 */
#define font1 "-adobe-helvetica-bold-r-normal--14-140-75-75-p-82-iso8859-1"
#define font2 "-misc-fixed-bold-r-normal-*-13-*-75-75-c-70-iso8859-1"
#define font3 "-adobe-courier-medium-r-normal--18-180-75-75-m-100-iso8859-1"
#define charset XmSTRING_DEFAULT_CHARSET
#define EV_MASK (ButtonPressMask | KeyPressMask | KeyReleaseMask | ExposureMask )

/*
 * Shell callback procedure declarations
 */
extern void BxManageCB();
extern void BxUnmanageCB();
extern void BxSetValuesCB();
extern void BxExitCB();
extern void do_openmb();
extern void do_opennav();
extern void do_nextbuffer();
extern void do_done();
extern void do_forward();
extern void do_reverse();
extern void do_quit();
extern void do_timespan();
extern void do_timestep();
extern void do_expose();
extern void do_event();
extern void do_resize();
extern void do_toggle_lon();
extern void do_toggle_lat();
extern void do_toggle_heading();
extern void do_toggle_speed();
extern void do_toggle_org_lon();
extern void do_toggle_org_lat();
extern void do_toggle_org_speed();
extern void do_toggle_show_smg();
extern void do_toggle_org_heading();
extern void do_toggle_show_cmg();
extern void do_button_use_smg();
extern void do_button_use_cmg();
extern void do_toggle_output_on();
extern void do_toggle_output_off();
extern void do_fileselection_cancel();
extern void do_fileselection_ok();
extern void do_fileselection_filter();
extern void do_fileselection_list();
extern void do_fileselection_nomatch();
extern void do_toggle_pick();
extern void do_toggle_select();
extern void do_toggle_deselect();
extern void do_toggle_selectall();
extern void do_interpolation();
extern void do_scroll();

/*
 * Forward declaration of widget create routines,
 * usually located in the creation file.
 */
Widget CreatemainWindow();

/*
 * Function prototypes for routines
 * located in utilities file.
 */
extern XtPointer CONVERT();
extern void MENU_POST();
extern void RegisterBxConverters();

/*
 * Widget variable declarations.
 */
Widget AppShell; /* The Main Application Shell */
Widget Shell000;
Widget MainWindow;

/* XG variable declarations */
Display *display, *dpy, *theDisplay;
Screen *screen, *can_screen;
Window window, frm_xid, can_xid;
Colormap theColormap, colormap;
GC gc, main_gc;
unsigned int theCursorShape;
Cursor theCursor;
XGCValues xgcv;
Pixmap theIconPixmap, crosshairPix;
int screen_num, can_screen_num;
XFontStruct *fontStruct;

/* file opening parameters */
int	startup_file = 0;

static char	*input_file;
static char	output_file[128];
int selected = 0; /* indicates an input file is selected */

int	can_xgid;		/* XG graphics id */
Cursor myCursor;
XColor closest[2];
XColor exact[2];

int key_z_down = 0;
int key_s_down = 0;
int key_a_down = 0;
int key_d_down = 0;

/* Set the colors used for this program here. */
#define NCOLORS 6
XColor colors[NCOLORS];
unsigned long mpixel_values[NCOLORS];
XColor db_color;

/* Set these to the dimensions of your canvas drawing */
/* area, minus 1, located in mbedit.uil.              */
static int mb_borders[4] =
	{ 0, 1016, 0, 552 };

/*
 * Main Program.
 */
main(argc, argv)
int argc;
char **argv;
{
  Display *display;
  Arg args[256];
  Cardinal argcnt;
  /*SUPPRESS 591*/
  Boolean argok;
  XtAppContext context;
  
  int	i, j, k;
  char value_text[10];
  char	label[10];
  int	status;

    XtToolkitInitialize();
    context = XtCreateApplicationContext();
    display = XtOpenDisplay(context, 0, BX_APP_NAME, BX_APP_CLASS, 
#ifndef XtSpecificationRelease
        0, 0, (Cardinal*)&argc, argv);
#else
#if XtSpecificationRelease == 4
        0, 0, (Cardinal*)&argc, argv);
#else
        0, 0, &argc, argv);
#endif
#endif
    if(display == NULL)
    {
	XtWarning("cannot open display");
	exit(1);
    }
    /*
     * So converters work.
     */
    XtInitializeWidgetClass(applicationShellWidgetClass);
    /*
     * Install the tearOffModel resource converter.
     */
#if (XmVersion >= 1002)
    XmRepTypeInstallTearOffModelConverter();
#endif

    /*
     * Register special BuilderXcessory converters.
     */
    RegisterBxConverters(context);

    /*
     * The applicationShell is created as an unrealized
     * parent for multiple topLevelShells.  The topLevelShells
     * are created as popup children of the applicationShell.
     * This is a recommendation of Paul Asente & Ralph Swick in
     * _X_Window_System_Toolkit_ p. 677.
     */
    argcnt = 0;
    AppShell = XtAppCreateShell( BX_APP_NAME, BX_APP_CLASS,
            applicationShellWidgetClass, display, args, argcnt);

    XtInitializeWidgetClass(topLevelShellWidgetClass);
    argcnt = 0;
    XtSetArg(args[argcnt], XmNtitle, "MBNAVEDIT"); argcnt++;
    XtSetArg(args[argcnt], XmNx, 851); argcnt++;
    XtSetArg(args[argcnt], XmNy, 284); argcnt++;
    Shell000 = XtCreatePopupShell( "topLevelShell", 
        topLevelShellWidgetClass, AppShell, args, argcnt);
    XtAddCallback(Shell000, XmNdestroyCallback, BxExitCB, (XtPointer)0);

    MainWindow = CreatemainWindow(Shell000);

    XtManageChild(MainWindow);
    XtPopup(XtParent(MainWindow), XtGrabNone);
    
    fileSelectionBox_list = (Widget)
	    XmFileSelectionBoxGetChild(fileSelectionBox, 
					XmDIALOG_LIST);
    fileSelectionBox_text = (Widget)
	    XmFileSelectionBoxGetChild(fileSelectionBox, 
					XmDIALOG_TEXT);
    XtAddCallback(fileSelectionBox_list, 
		XmNbrowseSelectionCallback, 
		do_fileselection_list, NULL);

    XtVaGetValues(scrolledWindow, 
			XmNhorizontalScrollBar, 
			&scrolledWindow_hscrollbar, 
			NULL);
    XtVaGetValues(scrolledWindow, 
			XmNverticalScrollBar, 
			&scrolledWindow_vscrollbar, 
			NULL);
    XtVaSetValues(scrolledWindow_hscrollbar, 
		XmCIncrement, 5, NULL);
    XtVaSetValues(scrolledWindow_vscrollbar, 
		XmCIncrement, 5, NULL);
    XtAddCallback(scrolledWindow_hscrollbar, 
		XmNvalueChangedCallback, 
		do_scroll, NULL);
    XtAddCallback(scrolledWindow_vscrollbar, 
		XmNvalueChangedCallback, 
		do_scroll, NULL);
    XtAddCallback(scrolledWindow_hscrollbar, 
		XmNdragCallback, 
		do_scroll, NULL);
    XtAddCallback(scrolledWindow_vscrollbar, 
		XmNdragCallback, 
		do_scroll, NULL);


    /* Now initialize xg stuff */

	/* Setup the entire screen. */
	display = XtDisplay(MainWindow);
	screen = DefaultScreenOfDisplay(display);
	screen_num = XDefaultScreen(display);
	frm_xid = XtWindow(MainWindow);
	colormap = DefaultColormap(display,screen_num);

	/* Setup just the "canvas" part of the screen. */
	theDisplay = XtDisplay(drawingArea);
	can_screen = DefaultScreenOfDisplay(theDisplay);
	can_xid = XtWindow(drawingArea);
	can_screen_num = XDefaultScreen(theDisplay);
	theColormap = DefaultColormap(display,can_screen_num);

	/* Setup the "graphics Context" for just the "canvas" */
	xgcv.background = WhitePixelOfScreen(can_screen);
	xgcv.foreground = BlackPixelOfScreen(can_screen);
	xgcv.line_width = 2;
	gc = XCreateGC(theDisplay,can_xid,GCBackground | GCForeground 
		 | GCLineWidth, &xgcv);

	/* Setup the font for just the "canvas" screen. */
	fontStruct = XLoadQueryFont(theDisplay, 
		 "-misc-fixed-bold-r-normal-*-13-*-75-75-c-70-iso8859-1");
	XSetFont(theDisplay,gc,fontStruct->fid);

	XSelectInput(theDisplay, can_xid, EV_MASK );

	/* Load the colors that will be used in this program. */
	status = XLookupColor(theDisplay,colormap,
		"white",&db_color,&colors[0]);
	if(status != 0)
		status = XAllocColor(theDisplay,colormap,&colors[0]);
	if (status == 0)
		{
		fprintf(stderr,"Failure to allocate color: white\n");
		exit(-1);
		}
	status = XLookupColor(theDisplay,colormap,
		"black",&db_color,&colors[1]);
	if(status != 0)
		status = XAllocColor(theDisplay,colormap,&colors[1]);
	if (status == 0)
		{
		fprintf(stderr,"Failure to allocate color: black\n");
		exit(-1);
		}
	status = XLookupColor(theDisplay,colormap,
		"red",&db_color,&colors[2]);
	if(status != 0)
		status = XAllocColor(theDisplay,colormap,&colors[2]);
	if (status == 0)
		{
		fprintf(stderr,"Failure to allocate color: red\n");
		exit(-1);
		}
	status = XLookupColor(theDisplay,colormap,
		"green",&db_color,&colors[3]);
	if(status != 0)
		status = XAllocColor(theDisplay,colormap,&colors[3]);
	if (status == 0)
		{
		fprintf(stderr,"Failure to allocate color: green\n");
		exit(-1);
		}
	status = XLookupColor(theDisplay,colormap,
		"blue",&db_color,&colors[4]);
	if(status != 0)
		status = XAllocColor(theDisplay,colormap,&colors[4]);
	if (status == 0)
		{
		fprintf(stderr,"Failure to allocate color: blue\n");
		exit(-1);
		}
	status = XLookupColor(theDisplay,colormap,
		"coral",&db_color,&colors[5]);
	if(status != 0)
		status = XAllocColor(theDisplay,colormap,&colors[5]);
	if (status == 0)
		{
		fprintf(stderr,"Failure to allocate color: coral\n");
		exit(-1);
		}
	for (i=0;i<NCOLORS;i++)
		{
		mpixel_values[i] = colors[i].pixel;
		}

	/* Setup initial cursor. This will be changed when changing "MODE". */
	myCursor = XCreateFontCursor(theDisplay, XC_target);
	XAllocNamedColor(theDisplay,colormap,"red",&closest[0],&exact[0]);
	XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
	XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
	XDefineCursor(theDisplay,can_xid,myCursor);

	/* initialize graphics */
	status = mbnavedit_init_globals();
	mb_borders[0] = 0;
	mb_borders[1] = plot_width;
	mb_borders[2] = 0;
	mb_borders[3] = number_plots*plot_height;
	can_xgid = xg_init(theDisplay, can_xid, mb_borders, font2);
	status = mbnavedit_set_graphics(can_xgid, 
			NCOLORS, mpixel_values);

	/* initialize mbedit proper */
	status = mbnavedit_init(argc,argv,&startup_file);

	/* set value of format text item */
	sprintf(value_text,"%2.2d",format);
	XmTextFieldSetString(textField_format, value_text);

	/* set the output mode */
	if (output_mode == OUTPUT_MODE_OUTPUT)
	    {
	    XmToggleButtonSetState(toggleButton_output_on, 
			TRUE, TRUE);
	    XtManageChild(label_filename);
	    XtManageChild(textField_output_file);
	    }
	else
	    {
	    XmToggleButtonSetState(toggleButton_output_off,  
			TRUE, TRUE);
	    XtUnmanageChild(label_filename);
	    XtUnmanageChild(textField_output_file);
	    }

	/* set values of number of data shown slider */
	XtVaSetValues(scale_timespan, 
			XmNminimum, 1, 
			XmNmaximum, data_show_max, 
			XmNvalue, data_show_size, 
			NULL);
	sprintf(label, "%d", data_show_max);
	XtVaSetValues(label_timespan_2, 
			XtVaTypedArg, XmNlabelString, 
			    XmRString, label, (strlen(label) + 1), 
			NULL);	

	/* set values of number of data to step slider */
	XtVaSetValues(scale_timestep, 
			XmNminimum, 1, 
			XmNmaximum, data_step_max, 
			XmNvalue, data_step_size, 
			NULL);
	sprintf(label, "%d", data_step_max);
	XtVaSetValues(label_timestep_2, 
			XtVaTypedArg, XmNlabelString, 
			    XmRString, label, (strlen(label) + 1), 
			NULL);	

	/* set the pick mode */
	if (mode_pick == PICK_MODE_PICK)
	    XmToggleButtonSetState(toggleButton_pick, 
			TRUE, TRUE);
	else if (mode_pick == PICK_MODE_SELECT)
	    XmToggleButtonSetState(toggleButton_select, 
			TRUE, TRUE);
	else if (mode_pick == PICK_MODE_DESELECT)
	    XmToggleButtonSetState(toggleButton_deselect, 
			TRUE, TRUE);
	else if (mode_pick == PICK_MODE_SELECTALL)
	    XmToggleButtonSetState(toggleButton_selectall, 
			TRUE, TRUE);
	else if (mode_pick == PICK_MODE_DESELECTALL)
	    XmToggleButtonSetState(toggleButton_deselectall, 
			TRUE, TRUE);
			
	/* set the lon, lat, speed and heading plot toggles */
	XmToggleButtonSetState(toggleButton_lon, 
			plot_lon, TRUE);
	XmToggleButtonSetState(toggleButton_org_lon, 
			plot_lon_org, TRUE);
	XmToggleButtonSetState(toggleButton_lat, 
			plot_lat, TRUE);
	XmToggleButtonSetState(toggleButton_org_lat, 
			plot_lat_org, TRUE);
	XmToggleButtonSetState(toggleButton_speed, 
			plot_speed, TRUE);
	XmToggleButtonSetState(toggleButton_org_speed, 
			plot_speed_org, TRUE);
	XmToggleButtonSetState(toggleButton_show_smg, 
			plot_smg, TRUE);
	XmToggleButtonSetState(toggleButton_heading, 
			plot_heading, TRUE);
	XmToggleButtonSetState(toggleButton_org_heading, 
			plot_heading_org, TRUE);
	XmToggleButtonSetState(toggleButton_show_cmg, 
			plot_cmg, TRUE);

	/* hide or display items according to toggle states */
	if (plot_lon == MB_YES)
		XtManageChild(toggleButton_org_lon);
	else
		XtUnmanageChild(toggleButton_org_lon);
	if (plot_lat == MB_YES)
		XtManageChild(toggleButton_org_lat);
	else
		XtUnmanageChild(toggleButton_org_lat);
	if (plot_speed == MB_YES)
		{
		XtManageChild(toggleButton_org_speed);
		XtManageChild(toggleButton_show_smg);
		XtManageChild(pushButton_speed_smg);
		}
	else
		{
		XtUnmanageChild(toggleButton_org_speed);
		XtUnmanageChild(toggleButton_show_smg);
		XtUnmanageChild(pushButton_speed_smg);
		}
	if (plot_heading == MB_YES)
		{
		XtManageChild(toggleButton_org_heading);
		XtManageChild(toggleButton_show_cmg);
		XtManageChild(pushButton_heading_cmg);
		}
	else
		{
		XtUnmanageChild(toggleButton_org_heading);
		XtUnmanageChild(toggleButton_show_cmg);
		XtUnmanageChild(pushButton_heading_cmg);
		}

	/* get and set size of canvas */
	number_plots = 0;
	if (plot_lon == MB_YES)
		number_plots++;
	if (plot_lat == MB_YES)
		number_plots++;
	if (plot_speed == MB_YES)
		number_plots++;
	if (plot_heading == MB_YES)
		number_plots++;
	XtVaSetValues(drawingArea, 
			XmNwidth, plot_width, 
			XmNheight, number_plots*plot_height, 
			NULL);	

    XtAppMainLoop(context);
}

/*--------------------------------------------------------------------*/
void
mbnavedit_bell(length)
int	length;
{
	XBell(theDisplay,length);
}
/*--------------------------------------------------------------------*/
void
mbnavedit_get_position(win_x, win_y, mask_return)
int	*win_x;
int	*win_y;
unsigned int *mask_return;
{
	Window	root_return, child_return;
	int	root_x_return, root_y_return;
	int	status;

	status = XQueryPointer(theDisplay, can_xid,
		&root_return, &child_return,
		&root_x_return, &root_y_return, 
		win_x, win_y, mask_return);
}
/*--------------------------------------------------------------------*/
void
mbnavedit_pickcursor()
{
	myCursor = XCreateFontCursor(theDisplay, XC_target);
	XAllocNamedColor(theDisplay,colormap,"red",&closest[0],&exact[0]);
	XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
	XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
	XDefineCursor(theDisplay,can_xid,myCursor);
}
/*--------------------------------------------------------------------*/
void
mbnavedit_selectcursor()
{
	myCursor = XCreateFontCursor(theDisplay, XC_exchange);
	XAllocNamedColor(theDisplay,colormap,"red",&closest[0],&exact[0]);
	XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
	XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
	XDefineCursor(theDisplay,can_xid,myCursor);
}
/*--------------------------------------------------------------------*/
void
mbnavedit_deselectcursor()
{
	myCursor = XCreateFontCursor(theDisplay, XC_exchange);
	XAllocNamedColor(theDisplay,colormap,"green",&closest[0],&exact[0]);
	XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
	XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
	XDefineCursor(theDisplay,can_xid,myCursor);
}
/*--------------------------------------------------------------------*/
void
mbnavedit_selectallcursor()
{
	myCursor = XCreateFontCursor(theDisplay, XC_cross);
	XAllocNamedColor(theDisplay,colormap,"red",&closest[0],&exact[0]);
	XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
	XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
	XDefineCursor(theDisplay,can_xid,myCursor);
}
/*--------------------------------------------------------------------*/
void
mbnavedit_deselectallcursor()
{
	myCursor = XCreateFontCursor(theDisplay, XC_cross);
	XAllocNamedColor(theDisplay,colormap,"green",&closest[0],&exact[0]);
	XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
	XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
	XDefineCursor(theDisplay,can_xid,myCursor);
}
/*--------------------------------------------------------------------*/
void
mbnavedit_setintervalcursor()
{
	myCursor = XCreateFontCursor(theDisplay, XC_crosshair);
	XAllocNamedColor(theDisplay,colormap,"red",&closest[0],&exact[0]);
	XAllocNamedColor(theDisplay,colormap,"coral",&closest[1],&exact[1]);
	XRecolorCursor(theDisplay,myCursor,&closest[0],&closest[1]);
	XDefineCursor(theDisplay,can_xid,myCursor);
}
/*--------------------------------------------------------------------*/

