/*
 * README: This file is appended to at file generation time.
 * Edits can be made throughout the file
 */
/*
 * Generated by the ICS Builder Xcessory (BX).
 *
 * Builder Xcessory Version 5.0.3
 * Code Generator Xcessory 5.0.1 (09/29/98) 
 *
 */
#include <Xm/Xm.h>


/*
 * Standard includes for builtins.
 */
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

/* MBIO include files */
#include "../../include/mb_status.h"
#include "../../include/mb_define.h"

/* GMT include files */
#include "gmt.h"

/* get NaN detector */
#if defined(isnanf)
#define check_fnan(x) isnanf((x))
#elif defined(isnan)
#define check_fnan(x) isnan((double)(x))
#elif HAVE_ISNANF == 1
#define check_fnan(x) isnanf(x)
extern int isnanf(float x);
#elif HAVE_ISNAN == 1
#define check_fnan(x) isnan((double)(x))
#elif HAVE_ISNAND == 1
#define check_fnan(x) isnand((double)(x))
#else
#define check_fnan(x) ((x) != (x))
#endif

/* mbview include file */
#include "mbview.h"

/* fileSelectionBox modes */
#define MBGRDVIZ_OPENGRID	0
#define MBGRDVIZ_OPENOVERLAY	1
#define MBGRDVIZ_OPENROUTE	2
#define MBGRDVIZ_OPENSITE	3
#define MBGRDVIZ_SAVEROUTE	4
#define MBGRDVIZ_SAVESITE	5

/* Projection defines */
#define ModelTypeProjected	     1
#define ModelTypeGeographic	     2
#define GCS_WGS_84		  4326

/* Site and route file versions */
#define MBGRDVIZ_SITE_VERSION "1.00"
#define MBGRDVIZ_ROUTE_VERSION "1.00"

/* id variables */
static char rcs_id[] = "$Id: mbgrdviz_callbacks.c,v 1.1 2003-09-23 21:25:43 caress Exp $";
static char program_name[] = "MBgrdviz";
static char help_message[] = "MBgrdviz is an interactive 2D/3D visualization tool for GMT grid files.";
static char usage_message[] = "mbgrdviz [-H -T -V]";

/* status variables */
int	verbose;
int	error;
int	pargc;
char	**pargv;

/* widgets */
int	mbview_id[MBV_MAX_WINDOWS];
extern 	Widget mainWindow;
Widget	pushButton_openoverlay[MBV_MAX_WINDOWS];
Widget	pushButton_openroute[MBV_MAX_WINDOWS];
Widget	pushButton_opensite[MBV_MAX_WINDOWS];
Widget	pushButton_saveroute[MBV_MAX_WINDOWS];
Widget	pushButton_savesite[MBV_MAX_WINDOWS];
Widget	fileSelectionList;
Widget	fileSelectionText;

/* function prototypes */
int do_mbgrdviz_dismiss_notify(int id);
void do_mbgrdviz_fileSelectionBox( Widget w, XtPointer client_data, XtPointer call_data);

/*
 * Motif required Headers
 */
#include <X11/StringDefs.h>
#include <Xm/Xm.h>
#include <Xm/DialogS.h>
#if (XmVersion >= 1002)
#include <Xm/RepType.h>
#endif
#include <Xm/MwmUtil.h>
#include "mbgrdviz_creation.h"

/*
 * Macros to make code look nicer between ANSI and K&R.
 */
#ifndef ARGLIST
#if (NeedFunctionPrototypes == 0)
#define PROTOTYPE(p)	()
#define ARGLIST(p)	p
#define ARG(a, b)	a b;
#define GRA(a, b)	a b;
#define UARG(a, b)      a b;
#define GRAU(a, b)      a b;
#else
#define PROTOTYPE(p)	p
#define ARGLIST(p)	(
#define ARG(a, b)	a b,
#define GRA(a, b)	a b)
#ifdef __cplusplus
#define UARG(a, b)      a,
#define GRAU(a, b)      a)
#else
#define UARG(a, b)      a b,
#define GRAU(a, b)      a b)
#endif
#endif
#endif

Widget		BxFindTopShell PROTOTYPE((Widget));
WidgetList	BxWidgetIdsFromNames PROTOTYPE((Widget, char*, char*));


/*      Function Name:	BxExitCB
 *
 *      Description:   	This functions expects an integer to be passed in
 *		       	client data.  It calls the exit() system call with
 *			the integer value as the argument to the function.
 *
 *      Arguments:      Widget		w: 	the activating widget.
 *			XtPointer	client:	the integer exit value.
 *			XtPointer	call:	the call data (unused).
 */

#ifdef VMS
#include <stdlib.h>
#endif

/* ARGSUSED */
void
BxExitCB ARGLIST((w, client, call))
UARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
    long	exitValue = (long)client;
    exit(exitValue);
}

/*      Function Name: 	BxManageCB
 *
 *      Description:   	Given a string of the form:
 *		       	"(WL)[widgetName, widgetName, ...]"
 *			BxManageCB attempts to convert the name to a Widget
 *			ID and manage the widget.
 *
 *      Arguments:     	Widget	    w:      the widget activating the callback.
 *		       	XtPointer   client: the list of widget names to attempt
 *					    to find and manage.
 *		       	XtPointer   call:   the call data (unused).
 *
 *      Notes:        *	This function expects that there is an application
 *		       	shell from which all other widgets are descended.
 */

/* ARGSUSED */
void
BxManageCB ARGLIST((w, client, call))
ARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
    WidgetList		widgets;
    int			i;

    /*
     * This function returns a NULL terminated WidgetList.  The memory for
     * the list needs to be freed when it is no longer needed.
     */
    widgets = BxWidgetIdsFromNames(w, "BxManageCB", (String)client);

    i = 0;
    while( widgets && widgets[i] != NULL )
    {
	XtManageChild(widgets[i]);
	i++;
    }
    XtFree((char *)widgets);
}

/*      Function Name: 	BxUnmanageCB
 *
 *      Description:   	Given a string of the form:
 *		       	"(WL)[widgetName, widgetName, ...]"
 *			BxUnmanageCB attempts to convert the name to a Widget
 *			ID and unmanage the widget.
 *
 *      Arguments:     	Widget	    w:      the widget activating the callback.
 *		       	XtPointer   client: the list of widget names to attempt
 *					    to find and unmanage.
 *		       	XtPointer   call:   the call data (unused).
 *
 *      Notes:        *	This function expects that there is an application
 *		       	shell from which all other widgets are descended.
 */

/* ARGSUSED */
void
BxUnmanageCB ARGLIST((w, client, call))
ARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
    WidgetList		widgets;
    int			i;

    /*
     * This function returns a NULL terminated WidgetList.  The memory for
     * the list needs to be freed when it is no longer needed.
     */
    widgets = BxWidgetIdsFromNames(w, "BxUnmanageCB", (String)client);

    i = 0;
    while( widgets && widgets[i] != NULL )
    {
	XtUnmanageChild(widgets[i]);
	i++;
    }
    XtFree((char *)widgets);
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_init(int argc, char **argv, int verbosity)
{
	char function_name[] = "do_mbgrdviz_init";
	int	status = MB_SUCCESS;
	int	instance;
	char	value_text[MB_PATH_MAXLINE];
	int	i, j;

	pargc = argc;
	pargv = argv;
	verbose = verbosity;
	error = MB_ERROR_NO_ERROR;
			
	/* set about version label */
	sprintf(value_text, "::#TimesMedium14:t\"MB-System Release %s\"#TimesMedium14\"%s\"", 
		MB_VERSION, MB_BUILD_DATE);
	set_mbview_label_multiline_string(label_about_version, value_text);
   
	/* get additional widgets */
	fileSelectionList = (Widget) 
	    XmFileSelectionBoxGetChild(fileSelectionBox, 
					XmDIALOG_LIST);
	fileSelectionText = (Widget) 
	    XmFileSelectionBoxGetChild(fileSelectionBox, 
					XmDIALOG_TEXT);
	XtUnmanageChild(
		(Widget) XmFileSelectionBoxGetChild(
					fileSelectionBox, 
					XmDIALOG_HELP_BUTTON));
	
	/* initialize mbview_id list */
	for (i=0;i<MBV_MAX_WINDOWS;i++)
	    {
	    mbview_id[i] == -1;
	    }
	
	return(0);
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox( Widget w, XtPointer client_data, XtPointer call_data)
{
 	int	actionid;
	int	mode;
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* figure out what kind of file is to be opened */
	actionid = (int) client_data;
	mode = actionid / MBV_MAX_WINDOWS;
	if (mode > 0)
		instance = actionid - mode * MBV_MAX_WINDOWS;
	
	/* set title to open primary grid */
	ac = 0;
	if (mode <= MBGRDVIZ_OPENGRID)
		{
		XtSetArg(args[ac], XmNtitle, "Open GMT Grid File"); ac++;
		}
	
	/* else set title to open overlay grid */
	else if (mode == MBGRDVIZ_OPENOVERLAY)
		{
		XtSetArg(args[ac], XmNtitle, "Open Overlay GMT Grid File"); ac++;
		}
	
	/* else set title to open route data */
	else if (mode == MBGRDVIZ_OPENROUTE)
		{
		XtSetArg(args[ac], XmNtitle, "Open Route File"); ac++;
		}
	
	/* else set title to open site data */
	else if (mode == MBGRDVIZ_OPENSITE)
		{
		XtSetArg(args[ac], XmNtitle, "Open Site File"); ac++;
		}
	
	/* else set title to save route data */
	else if (mode == MBGRDVIZ_SAVEROUTE)
		{
		XtSetArg(args[ac], XmNtitle, "Save Route File"); ac++;
		}
	
	/* else set title to save site data */
	else if (mode == MBGRDVIZ_SAVESITE)
		{
		XtSetArg(args[ac], XmNtitle, "Save Site File"); ac++;
		}
		
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	
	/* open primary grid */
	ac = 0;
	if (mode <= MBGRDVIZ_OPENGRID)
		{
        	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*.grd", 
                				XmRXmString, 0, &argok);
        	XtSetArg(args[ac], XmNpattern, tmp0); ac++;
		}
	
	/* else open overlay grid */
	else if (mode == MBGRDVIZ_OPENOVERLAY)
		{
        	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*.grd", 
                				XmRXmString, 0, &argok);
        	XtSetArg(args[ac], XmNpattern, tmp0); ac++;
		}
	
	/* else open route data */
	else if (mode == MBGRDVIZ_OPENROUTE)
		{
        	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*", 
                				XmRXmString, 0, &argok);
        	XtSetArg(args[ac], XmNpattern, tmp0); ac++;
		}
	
	/* else open site data */
	else if (mode == MBGRDVIZ_OPENSITE)
		{
        	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*", 
                				XmRXmString, 0, &argok);
        	XtSetArg(args[ac], XmNpattern, tmp0); ac++;
		}
	
	/* else save route data */
	else if (mode == MBGRDVIZ_SAVEROUTE)
		{
        	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*", 
                				XmRXmString, 0, &argok);
        	XtSetArg(args[ac], XmNpattern, tmp0); ac++;
		}
	
	/* else save site data */
	else if (mode == MBGRDVIZ_SAVESITE)
		{
        	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*", 
                				XmRXmString, 0, &argok);
        	XtSetArg(args[ac], XmNpattern, tmp0); ac++;
		}

	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_close( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
}
/*---------------------------------------------------------------------------------------*/

void
do_mbgrdviz_quit( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_dismiss_notify(int id)
{
	char function_name[] = "do_mbgrdviz_dismiss_notify";
	int	status = MB_SUCCESS;
	int	verbose = 0;
	int	instance;
	int	i, j, k;
	
	/* set mbview window <id> to inactive */
	instance = -1;
	for (i=0;i<MBV_MAX_WINDOWS;i++)
	    {
	    if (mbview_id[i] == id)
	    	{
		mbview_id[i] = -1;
		instance = i;
		}
	    }
	if (instance < 0)
	    {
	    fprintf(stderr, "Unable to free mbview - mbview window %d not found in loal list...\n", id);
	    }
	
	return(status);
}
/*---------------------------------------------------------------------------------------*/

void
do_mbgrdviz_openfile( Widget w, XtPointer client_data, XtPointer call_data)
{
	char function_name[] = "do_mbgrdviz_openfile";
	int	status = MB_SUCCESS;
	int	actionid;
	int	mode;
	int	instance;
	char    *file_ptr;
        Cardinal ac = 0;
        Arg      args[256];
    XmFileSelectionBoxCallbackStruct *acs=(XmFileSelectionBoxCallbackStruct*)call_data;

fprintf(stderr,"do_mbgrdviz_openfile\n");

    	/* figure out what kind of file is to be opened */

	ac = 0;
	XtSetArg(args[ac], XmNuserData, (XtPointer) &actionid); ac++;
	XtGetValues(fileSelectionBox, args, ac);

	mode = actionid / MBV_MAX_WINDOWS;
	if (mode > 0)
		instance = actionid - mode * MBV_MAX_WINDOWS;

	/* read the input file name */
	XmStringGetLtoR(acs->value, XmSTRING_DEFAULT_CHARSET, 
			&file_ptr);
	if (strlen(file_ptr) <= 0 && file_ptr != NULL)
		{
		XtFree(file_ptr);
		file_ptr = NULL;
		}
	
	/* open primary grid */
	if (mode <= MBGRDVIZ_OPENGRID)
		{
		/* read the grid and open mbview window */
		fprintf(stderr, "call do_mbgrdviz_openprimary\n");
		status = do_mbgrdviz_openprimary(file_ptr);
		}
	
	/* else open overlay grid */
	else if (mode == MBGRDVIZ_OPENOVERLAY)
		{
		/* read the grid and update mbview window */
		fprintf(stderr, "call do_mbgrdviz_openoverlay\n");
		status = do_mbgrdviz_openoverlay(instance, file_ptr);
		}
	
	/* else open site data */
	else if (mode == MBGRDVIZ_OPENSITE)
		{
		/* read site file and update mbview window */
		fprintf(stderr, "call do_mbgrdviz_opensite\n");
		status = do_mbgrdviz_opensite(instance, file_ptr);
		}
	
	/* else open route data */
	else if (mode == MBGRDVIZ_OPENROUTE)
		{
		/* read route file and update mbview window */
		fprintf(stderr, "call do_mbgrdviz_openroute\n");
		status = do_mbgrdviz_openroute(instance, file_ptr);
		}
	
	/* else write site data */
	else if (mode == MBGRDVIZ_SAVESITE)
		{
		/* write site file */
		fprintf(stderr, "call do_mbgrdviz_savesite\n");
		status = do_mbgrdviz_savesite(instance, file_ptr);
		}
	
	/* else write route data */
	else if (mode == MBGRDVIZ_SAVEROUTE)
		{
		/* write route file */
		fprintf(stderr, "call do_mbgrdviz_saveroute\n");
		status = do_mbgrdviz_saveroute(instance, file_ptr);
		}

	/* free the string */
	if (file_ptr != NULL)
		{
		XtFree(file_ptr);
		file_ptr = NULL;
		}

}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_openprimary(char *input_file_ptr)
{
	char function_name[] = "do_mbgrdviz_openprimary";
	int	status = MB_SUCCESS;
	char    *button_name_ptr;
	double	xx, yy;
	int	instance;
	int	i, j, k;
        Cardinal ac = 0;
        Arg      args[256];
        Cardinal cdc = 0;
        Boolean  argok = False;
        XmString    tmp0;
	int	actionid;
	char	*testname = "Internal Test Grid";
	int	projectionid, utmzone;
	double	reference_lon;
	
	/* mbview parameters */
	int 	(*mbview_dismiss_notify)(int id);
	char	mbv_title[MB_PATH_MAXLINE];
	int	mbv_xo;
	int	mbv_yo;
	int	mbv_width;
	int	mbv_height;
	int	mbv_lorez_dimension;
	int	mbv_hirez_dimension;
	int	mbv_display_mode;
	int	mbv_mouse_mode;
	int	mbv_grid_mode;
	int	mbv_grid_shade_mode;
	int	mbv_grid_contour_mode;
	int	mbv_site_view_mode;
	int	mbv_route_view_mode;
	int	mbv_nav_view_mode;
	int	mbv_primary_colortable;
	int	mbv_primary_colortable_mode;
	double	mbv_primary_colortable_min;
	double	mbv_primary_colortable_max;
	int	mbv_slope_colortable;
	int	mbv_slope_colortable_mode;
	double	mbv_slope_colortable_min;
	double	mbv_slope_colortable_max;
	int	mbv_secondary_colortable;
	int	mbv_secondary_colortable_mode;
	double	mbv_secondary_colortable_min;
	double	mbv_secondary_colortable_max;
	double	mbv_secondary_overlay_center;
	double	mbv_exageration;
	double	mbv_modelelevation3d;
	double	mbv_modelazimuth3d;
	double	mbv_viewelevation3d;
	double	mbv_viewazimuth3d;
	double	mbv_illuminate_magnitude;
	double	mbv_illuminate_elevation;
	double	mbv_illuminate_azimuth;
	double	mbv_slope_magnitude;
	double	mbv_overlay_magnitude;
	double	mbv_contour_interval;
	int	mbv_primary_grid_projection_mode;
	char	mbv_primary_grid_projection_id[MB_PATH_MAXLINE];
	int	mbv_secondary_grid_projection_mode;
	char	mbv_secondary_grid_projection_id[MB_PATH_MAXLINE];
	int	mbv_display_projection_mode;
	char	mbv_display_projection_id[MB_PATH_MAXLINE];
	float	mbv_primary_nodatavalue;
	int	mbv_primary_nxy;
	int	mbv_primary_nx;
	int	mbv_primary_ny;
	double	mbv_primary_min;
	double	mbv_primary_max;
	double	mbv_primary_xmin;
	double	mbv_primary_xmax;
	double	mbv_primary_ymin;
	double	mbv_primary_ymax;
	double	mbv_primary_dx;
	double	mbv_primary_dy;
	float	*mbv_primary_rawdata;
	float	*mbv_primary_data;

	/* get next instance number */
	status = mbview_init(verbose, &instance, &error);
	if (instance < 0)
		{
		fprintf(stderr, "Unable to create mbview - %d mbview windows already created\n", 
		MBV_MAX_WINDOWS);
		}
	    
	else if (instance >= 0)
		{
if (input_file_ptr != NULL)
fprintf(stderr, "opening input grid:%s\n",input_file_ptr);
else
fprintf(stderr, "using internal test grid...\n");

		/* get button name */
		if (input_file_ptr != NULL)
			{
			button_name_ptr = (char *) rindex(input_file_ptr, '/');
			if (button_name_ptr == NULL)
				button_name_ptr = input_file_ptr;
			else
				button_name_ptr++;
			}
		else
			{
			button_name_ptr = testname;
			}
				

		/* set parameters */
		sprintf(mbv_title, "MBgrdviz: %s\n", button_name_ptr);
		mbv_xo = 200;
		mbv_yo = 200;
		mbv_width = 560;
		mbv_height = 500;
		mbv_lorez_dimension = 100;
		mbv_hirez_dimension = 500;
		mbv_display_mode = MBV_DISPLAY_2D;
		mbv_mouse_mode = MBV_MOUSE_MOVE;
		mbv_grid_mode = MBV_GRID_VIEW_PRIMARY;
		mbv_grid_shade_mode = MBV_SHADE_VIEW_SLOPE;
		mbv_grid_contour_mode = MBV_VIEW_OFF;
		mbv_site_view_mode = MBV_VIEW_OFF;
		mbv_route_view_mode = MBV_VIEW_OFF;
		mbv_nav_view_mode = MBV_VIEW_OFF;
		mbv_primary_colortable = MBV_COLORTABLE_HAXBY;
		mbv_primary_colortable_mode = MBV_COLORTABLE_NORMAL;
		mbv_primary_colortable_min = 0.0;
		mbv_primary_colortable_max = 0.0;
		mbv_slope_colortable = MBV_COLORTABLE_HAXBY;
		mbv_slope_colortable_mode = MBV_COLORTABLE_REVERSED;
		mbv_slope_colortable_min = 0.0;
		mbv_slope_colortable_max = 0.5;
		mbv_secondary_colortable = MBV_COLORTABLE_HAXBY;
		mbv_secondary_colortable_mode = MBV_COLORTABLE_NORMAL;
		mbv_secondary_colortable_min = 0.0;
		mbv_secondary_colortable_max = 0.0;
		mbv_secondary_overlay_center = 0.0;
		mbv_exageration = 1.0;
		mbv_modelelevation3d = 90.0;
		mbv_modelazimuth3d = 0.0;
		mbv_viewelevation3d = 90.0;
		mbv_viewazimuth3d = 0.0;
		mbv_illuminate_magnitude = 5.0;
		mbv_illuminate_elevation = 30.0;
		mbv_illuminate_azimuth = 90.0;
		mbv_slope_magnitude = 1.0;
		mbv_overlay_magnitude = 1.0;
		mbv_contour_interval = 100.0;
		mbv_display_projection_mode = MBV_PROJECTION_GEOGRAPHIC;
		sprintf(mbv_display_projection_id, "epsg%d", GCS_WGS_84);

		/* set basic mbview window parameters */
		status = mbview_setwindowparms(verbose, instance,
					&do_mbgrdviz_dismiss_notify,
					mbv_title,
					mbv_xo,
					mbv_yo,
					mbv_width,
					mbv_height,
					mbv_lorez_dimension,
					mbv_hirez_dimension,
					&error);
		
		/* read in the grd file */
		if (status == MB_SUCCESS
			&& input_file_ptr != NULL)
		status = do_mbgrdviz_readgrd(instance, input_file_ptr,
			&mbv_primary_grid_projection_mode,
			mbv_primary_grid_projection_id,
			&mbv_primary_nodatavalue,
			&mbv_primary_nxy,
			&mbv_primary_nx,
			&mbv_primary_ny,
			&mbv_primary_min,
			&mbv_primary_max,
			&mbv_primary_xmin,
			&mbv_primary_xmax,
			&mbv_primary_ymin,
			&mbv_primary_ymax,
			&mbv_primary_dx,
			&mbv_primary_dy,
			&mbv_primary_data);
			
		else if (status == MB_SUCCESS)
		status = do_mbgrdviz_opentest(instance, 
			1000.0, 3.0, 2.0, 
			&mbv_primary_grid_projection_mode,
			mbv_primary_grid_projection_id,
			&mbv_primary_nodatavalue,
			&mbv_primary_nxy,
			&mbv_primary_nx,
			&mbv_primary_ny,
			&mbv_primary_min,
			&mbv_primary_max,
			&mbv_primary_xmin,
			&mbv_primary_xmax,
			&mbv_primary_ymin,
			&mbv_primary_ymax,
			&mbv_primary_dx,
			&mbv_primary_dy,
			&mbv_primary_data);
			
		/* set the display projection */
		/* if grid projected then use the same projected coordinate system by default */
		if (mbv_primary_grid_projection_mode == MBV_PROJECTION_PROJECTED)
			{
			mbv_display_projection_mode = mbv_primary_grid_projection_mode;
			strcpy(mbv_display_projection_id,mbv_primary_grid_projection_id);
			}
			
		/* else if grid geographic then use appropriate UTM zone for non-polar grids */
		else if (mbv_primary_ymax > -80.0
			&& mbv_primary_ymin < 84.0)
			{
			mbv_display_projection_mode = MBV_PROJECTION_PROJECTED;
			reference_lon = 0.5 * (mbv_primary_xmin + mbv_primary_xmax);
			utmzone = (int)(((reference_lon + 183.0)
					/ 6.0) + 0.5);
			if (0.5 * (mbv_primary_ymin + mbv_primary_ymax) >= 0.0)
				projectionid = 32600 + utmzone;
			else
				projectionid = 32700 + utmzone;
			sprintf(mbv_display_projection_id, "epsg%d", projectionid);
			}
			
		/* else if grid geographic and more northerly than 84 deg N then use 
			North Univeral Polar Stereographic Projection */
		else if (mbv_primary_ymin > 84.0)
			{
			mbv_display_projection_mode = MBV_PROJECTION_PROJECTED;
			projectionid = 32661;
			sprintf(mbv_display_projection_id, "epsg%d", projectionid);
			}

		/* else if grid geographic and more southerly than 80 deg S then use 
			South Univeral Polar Stereographic Projection */
		else if (mbv_primary_ymax < 80.0)
			{
			mbv_display_projection_mode = MBV_PROJECTION_PROJECTED;
			projectionid = 32761;
			sprintf(mbv_display_projection_id, "epsg%d", projectionid);
			}

		/* else just use geographic */
		else
			{
			mbv_display_projection_mode = MBV_PROJECTION_GEOGRAPHIC;
			sprintf(mbv_display_projection_id, "epsg%d", GCS_WGS_84);
			}

		/* set basic mbview view controls */
		if (status == MB_SUCCESS)
		status = mbview_setviewcontrols(verbose, instance,
					mbv_display_mode,
					mbv_mouse_mode,
					mbv_grid_mode,
					mbv_grid_shade_mode,
					mbv_grid_contour_mode,
					mbv_site_view_mode,
					mbv_route_view_mode,
					mbv_nav_view_mode,
					mbv_exageration,
					mbv_modelelevation3d,
					mbv_modelazimuth3d,
					mbv_viewelevation3d,
					mbv_viewazimuth3d,
					mbv_illuminate_magnitude,
					mbv_illuminate_elevation,
					mbv_illuminate_azimuth,
					mbv_slope_magnitude,
					mbv_overlay_magnitude,
					mbv_contour_interval,
					mbv_display_projection_mode,
					mbv_display_projection_id,
					&error);
		

		/* set more mbview control values */
		if (status == MB_SUCCESS)
		status = mbview_setprimarygrid(verbose, instance,
					mbv_primary_grid_projection_mode,
					mbv_primary_grid_projection_id,
					mbv_primary_nodatavalue,
					mbv_primary_nx,
					mbv_primary_ny,
					mbv_primary_min,
					mbv_primary_max,
					mbv_primary_xmin,
					mbv_primary_xmax,
					mbv_primary_ymin,
					mbv_primary_ymax,
					mbv_primary_dx,
					mbv_primary_dy,
					mbv_primary_data,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_setprimarycolortable(verbose, instance,
					mbv_primary_colortable,
					mbv_primary_colortable_mode,
					mbv_primary_colortable_min,
					mbv_primary_colortable_max,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_setslopecolortable(verbose, instance,
					mbv_slope_colortable,
					mbv_slope_colortable_mode,
					mbv_slope_colortable_min,
					mbv_slope_colortable_max,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_enableeditsites(verbose, instance,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_enableeditroutes(verbose, instance,
					&error);

		/* open up mbview window */
		if (status == MB_SUCCESS)
			{
fprintf(stderr,"about to open mbview instance:%d\n",instance);
			status = mbview_open(verbose, instance, &error);
fprintf(stderr,"done opening mbview instance:%d  id:%d\n",instance, mbview_id[instance]);
			}
			
		/* add menus for opening more data for this instance */
		if (status == MB_SUCCESS)
			{
			/* add pushbutton for opening overlay grid */
    			ac = 0;
        		tmp0 = (XmString) BX_CONVERT(pulldownMenu_openoverlay, button_name_ptr, 
                		XmRXmString, 0, &argok);
        		XtSetArg(args[ac], XmNlabelString, tmp0); if (argok) ac++;
        		XtSetArg(args[ac], XmNfontList, 
        		    BX_CONVERT(pulldownMenu_openoverlay, "-*-helvetica-bold-r-*-*-*-140-75-75-*-*-iso8859-1", 
        		    XmRFontList, 0, &argok)); if (argok) ac++;
        		pushButton_openoverlay[instance] = (Widget) XmCreatePushButton(pulldownMenu_openoverlay,
        		    button_name_ptr,
        		    args, 
        		    ac);
        		XmStringFree((XmString)tmp0);
        		XtManageChild(pushButton_openoverlay[instance]);
			actionid = MBGRDVIZ_OPENOVERLAY * MBV_MAX_WINDOWS + instance;
			XtAddCallback(pushButton_openoverlay[instance], XmNactivateCallback, do_mbgrdviz_fileSelectionBox, (XtPointer)actionid);

			/* add pushbutton for opening route file */
    			ac = 0;
        		tmp0 = (XmString) BX_CONVERT(pulldownMenu_openroute, button_name_ptr, 
                		XmRXmString, 0, &argok);
        		XtSetArg(args[ac], XmNlabelString, tmp0); if (argok) ac++;
        		XtSetArg(args[ac], XmNfontList, 
        		    BX_CONVERT(pulldownMenu_openroute, "-*-helvetica-bold-r-*-*-*-140-75-75-*-*-iso8859-1", 
        		    XmRFontList, 0, &argok)); if (argok) ac++;
        		pushButton_openroute[instance] = (Widget) XmCreatePushButton(pulldownMenu_openroute,
        		    button_name_ptr,
        		    args, 
        		    ac);
        		XmStringFree((XmString)tmp0);
        		XtManageChild(pushButton_openroute[instance]);
			actionid = MBGRDVIZ_OPENROUTE * MBV_MAX_WINDOWS + instance;
			XtAddCallback(pushButton_openroute[instance], XmNactivateCallback, do_mbgrdviz_fileSelectionBox, (XtPointer)actionid);

			/* add pushbutton for opening site file */
    			ac = 0;
        		tmp0 = (XmString) BX_CONVERT(pulldownMenu_opensite, button_name_ptr, 
                		XmRXmString, 0, &argok);
        		XtSetArg(args[ac], XmNlabelString, tmp0); if (argok) ac++;
        		XtSetArg(args[ac], XmNfontList, 
        		    BX_CONVERT(pulldownMenu_opensite, "-*-helvetica-bold-r-*-*-*-140-75-75-*-*-iso8859-1", 
        		    XmRFontList, 0, &argok)); if (argok) ac++;
        		pushButton_opensite[instance] = (Widget) XmCreatePushButton(pulldownMenu_opensite,
        		    button_name_ptr,
        		    args, 
        		    ac);
        		XmStringFree((XmString)tmp0);
        		XtManageChild(pushButton_opensite[instance]);
			actionid = MBGRDVIZ_OPENSITE * MBV_MAX_WINDOWS + instance;
			XtAddCallback(pushButton_opensite[instance], XmNactivateCallback, do_mbgrdviz_fileSelectionBox, (XtPointer)actionid);

			/* add pushbutton for saving route file */
    			ac = 0;
        		tmp0 = (XmString) BX_CONVERT(pulldownMenu_saveroute, button_name_ptr, 
                		XmRXmString, 0, &argok);
        		XtSetArg(args[ac], XmNlabelString, tmp0); if (argok) ac++;
        		XtSetArg(args[ac], XmNfontList, 
        		    BX_CONVERT(pulldownMenu_saveroute, "-*-helvetica-bold-r-*-*-*-140-75-75-*-*-iso8859-1", 
        		    XmRFontList, 0, &argok)); if (argok) ac++;
        		pushButton_saveroute[instance] = (Widget) XmCreatePushButton(pulldownMenu_saveroute,
        		    button_name_ptr,
        		    args, 
        		    ac);
        		XmStringFree((XmString)tmp0);
        		XtManageChild(pushButton_saveroute[instance]);
			actionid = MBGRDVIZ_SAVEROUTE * MBV_MAX_WINDOWS + instance;
			XtAddCallback(pushButton_saveroute[instance], XmNactivateCallback, do_mbgrdviz_fileSelectionBox, (XtPointer)actionid);

			/* add pushbutton for saving site file */
    			ac = 0;
        		tmp0 = (XmString) BX_CONVERT(pulldownMenu_savesite, button_name_ptr, 
                		XmRXmString, 0, &argok);
        		XtSetArg(args[ac], XmNlabelString, tmp0); if (argok) ac++;
        		XtSetArg(args[ac], XmNfontList, 
        		    BX_CONVERT(pulldownMenu_savesite, "-*-helvetica-bold-r-*-*-*-140-75-75-*-*-iso8859-1", 
        		    XmRFontList, 0, &argok)); if (argok) ac++;
        		pushButton_savesite[instance] = (Widget) XmCreatePushButton(pulldownMenu_savesite,
        		    button_name_ptr,
        		    args, 
        		    ac);
        		XmStringFree((XmString)tmp0);
        		XtManageChild(pushButton_savesite[instance]);
			actionid = MBGRDVIZ_SAVESITE * MBV_MAX_WINDOWS + instance;
			XtAddCallback(pushButton_savesite[instance], XmNactivateCallback, do_mbgrdviz_fileSelectionBox, (XtPointer)actionid);

			}

		}
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_openoverlay(int instance, char *input_file_ptr)
{
	char function_name[] = "do_mbgrdviz_openoverlay";
	int	status = MB_SUCCESS;
	char    *button_name_ptr;
	double	xx, yy;
	int	i, j, k;
        Cardinal ac = 0;
        Arg      args[256];
        Cardinal cdc = 0;
        Boolean  argok = False;
        XmString    tmp0;
	int	actionid;
	char	*testname = "Internal Test Grid";
	
	/* mbview parameters */
	int	mbv_secondary_colortable;
	int	mbv_secondary_colortable_mode;
	double	mbv_secondary_colortable_min;
	double	mbv_secondary_colortable_max;
	double	mbv_secondary_overlay_center;
	int	mbv_secondary_grid_projection_mode;
	char	mbv_secondary_grid_projection_id[MB_PATH_MAXLINE];
	float	mbv_secondary_nodatavalue;
	int	mbv_secondary_nxy;
	int	mbv_secondary_nx;
	int	mbv_secondary_ny;
	double	mbv_secondary_min;
	double	mbv_secondary_max;
	double	mbv_secondary_xmin;
	double	mbv_secondary_xmax;
	double	mbv_secondary_ymin;
	double	mbv_secondary_ymax;
	double	mbv_secondary_dx;
	double	mbv_secondary_dy;
	float	*mbv_secondary_data;

	/* read data for valid instance */
	if (instance >= 0)
		{

		/* set parameters */
		mbv_secondary_colortable = MBV_COLORTABLE_HAXBY;
		mbv_secondary_colortable_mode = MBV_COLORTABLE_NORMAL;
		mbv_secondary_colortable_min = 0.0;
		mbv_secondary_colortable_max = 0.0;
		mbv_secondary_overlay_center = 0.0;
		
		/* read in the grd file */
		if (status == MB_SUCCESS
			&& input_file_ptr != NULL)
		status = do_mbgrdviz_readgrd(instance, input_file_ptr,
			&mbv_secondary_grid_projection_mode,
			mbv_secondary_grid_projection_id,
			&mbv_secondary_nodatavalue,
			&mbv_secondary_nxy,
			&mbv_secondary_nx,
			&mbv_secondary_ny,
			&mbv_secondary_min,
			&mbv_secondary_max,
			&mbv_secondary_xmin,
			&mbv_secondary_xmax,
			&mbv_secondary_ymin,
			&mbv_secondary_ymax,
			&mbv_secondary_dx,
			&mbv_secondary_dy,
			&mbv_secondary_data);
			
		else if (status == MB_SUCCESS)
		status = do_mbgrdviz_opentest(instance, 
			1000.0, 6.0, 1.5, 
			&mbv_secondary_grid_projection_mode,
			mbv_secondary_grid_projection_id,
			&mbv_secondary_nodatavalue,
			&mbv_secondary_nxy,
			&mbv_secondary_nx,
			&mbv_secondary_ny,
			&mbv_secondary_min,
			&mbv_secondary_max,
			&mbv_secondary_xmin,
			&mbv_secondary_xmax,
			&mbv_secondary_ymin,
			&mbv_secondary_ymax,
			&mbv_secondary_dx,
			&mbv_secondary_dy,
			&mbv_secondary_data);

		/* set more mbview control values */
		if (status == MB_SUCCESS)
		status = mbview_setsecondarygrid(verbose, instance,
					mbv_secondary_grid_projection_mode,
					mbv_secondary_grid_projection_id,
					mbv_secondary_nodatavalue,
					mbv_secondary_nx,
					mbv_secondary_ny,
					mbv_secondary_min,
					mbv_secondary_max,
					mbv_secondary_xmin,
					mbv_secondary_xmax,
					mbv_secondary_ymin,
					mbv_secondary_ymax,
					mbv_secondary_dx,
					mbv_secondary_dy,
					mbv_secondary_data,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_setsecondarycolortable(verbose, instance,
					mbv_secondary_colortable,
					mbv_secondary_colortable_mode,
					mbv_secondary_colortable_min,
					mbv_secondary_colortable_max,
					mbv_secondary_overlay_center,
					&error);
					
		/* update widgets */
		if (status == MB_SUCCESS)
		status = mbview_update(verbose, instance, &error);

		}
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_opensite(int instance, char *input_file_ptr)
{
	char function_name[] = "do_mbgrdviz_opensite";
	int	status = MB_SUCCESS;
	FILE	*sfp;
	char	buffer[MB_PATH_MAXLINE];
	int	nsite;
	double	*sitelon;
	double	*sitelat;
	double	*sitetopo;
	int	*sitecolor;
	int	*sitesize;
	mb_path	*sitename;
	char	*result;
	char	*name;
	int	nget;
	int	site_ok;
	int	i;

	/* read data for valid instance */
	if (instance >= 0)
	    {

	    /* count the sites in the input file */
	    nsite = 0;
	    if ((sfp = fopen(input_file_ptr, "r")) == NULL) 
		    {
		    error = MB_ERROR_OPEN_FAIL;
		    fprintf(stderr,"\nUnable to Open Site File <%s> for reading\n",input_file_ptr);
		    XBell((Display *) XtDisplay(mainWindow),100);
		    return(MB_FAILURE);
		    }
	    while ((result = fgets(buffer,MB_PATH_MAXLINE,sfp)) == buffer)
		    {
		    if (buffer[0] != '#')
		    	nsite++;
		    }
	    fclose(sfp);
	    
	    /* allocate arrays for sites */
	    if (nsite > 0)
		{
		/* allocate the arrays */
		sitelon = NULL;
		sitelat = NULL;
		sitetopo = NULL;
		sitecolor = NULL;
		sitesize = NULL;
		sitename = NULL;
		status = mbview_allocsitearrays(verbose, 
			nsite, &sitelon, &sitelat, &sitetopo,
			&sitecolor, &sitesize, &sitename, &error);

		/* if error initializing memory then cancel dealing with sites */
		if (status == MB_FAILURE)
			{
			nsite = 0;		    
			fprintf(stderr,"\nUnable to allocate arrays for %d sites\n",nsite);
			XBell((Display *) XtDisplay(mainWindow),100);
			return(status);
			}
		}
		
	    /* read the sites from the input file */
	    if (nsite > 0)
	    	{
		nsite = 0;
		if ((sfp = fopen(input_file_ptr, "r")) == NULL) 
			{
			error = MB_ERROR_OPEN_FAIL;
			status = MB_FAILURE;
			fprintf(stderr,"\nUnable to open site file <%s> for reading\n",input_file_ptr);
			XBell((Display *) XtDisplay(mainWindow),100);
			return(status);
			}
		while ((result = fgets(buffer,MB_PATH_MAXLINE,sfp)) == buffer)
		    {
		    site_ok = MB_NO;

		    /* deal with site in form: lon lat color size name */
		    if (buffer[0] != '#')
		    	{
			nget = sscanf(buffer,"%lf %lf %lf %d %d %[^\n]",
			    &sitelon[nsite], &sitelat[nsite], &sitetopo[nsite], 
			    &sitecolor[nsite], &sitesize[nsite],
			    &sitename[nsite]);
		    	if (nget >= 2)
			    site_ok = MB_YES;
			}
		    if (site_ok == MB_YES)
			{
		    	if (nget < 6)
		    	    {
			    name = (char *) sitename[nsite];
			    name[0] = '\0';
			    }
		    	if (nget < 5)
			    sitesize[nsite] = 0;
		    	if (nget < 4)
			    sitecolor[nsite] = 0;
		    	if (nget < 3)
			    sitetopo[nsite] = MBV_DEFAULT_NODATA;
			}

		    /* output some debug values */
		    if (verbose >= 0 && site_ok == MB_YES)
			    {
			    fprintf(stderr,"\ndbg5  Site point read in program <%s>\n",program_name);
			    fprintf(stderr,"dbg5       site[%d]: %f %f %f  %d %d  %s\n",
				    nsite,sitelon[nsite],sitelat[nsite],sitetopo[nsite],
				    sitecolor[nsite],sitesize[nsite],
				    sitename[nsite]);
			    }
		    else if (verbose >= 0 && site_ok == MB_NO)
			    {
			    fprintf(stderr,"\ndbg5  Unintelligible line read from site file in program <%s>\n",program_name);
			    fprintf(stderr,"dbg5       buffer:  %s\n",
				   buffer);
			    }

		    strncpy(buffer,"\0",sizeof(buffer));
		    if (site_ok == MB_YES)
		    	nsite++;
		    }
		fclose(sfp);
		}
	    
	    /* add the sites */
	    if (nsite > 0)
	    	{
	    	status = mbview_addsites(verbose, instance,
			nsite, sitelon, sitelat, sitetopo, 
			sitecolor, sitesize, sitename,
			&error);

	    	/* update widgets */
	    	if (status == MB_SUCCESS)
	    	status = mbview_update(verbose, instance, &error);
		}
	    
	    /* deallocate memory */
	    if (nsite > 0)
	    	{
		status = mbview_freesitearrays(verbose, 
			&sitelon, &sitelat, &sitetopo,
			&sitecolor, &sitesize, &sitename, &error);
		}

	    }
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_savesite(int instance, char *output_file_ptr)
{
	char function_name[] = "do_mbgrdviz_savesite";
	int	status = MB_SUCCESS;
	FILE	*sfp;
	char	buffer[MB_PATH_MAXLINE];
	int	nsite;
	double	*sitelon;
	double	*sitelat;
	double	*sitetopo;
	int	*sitecolor;
	int	*sitesize;
	mb_path	*sitename;
	char	*result;
	char	*name;
	int	nget;
	int	site_ok;
	int	i;

	/* time, user, host variables */
	time_t	right_now;
	char	date[25], *user_ptr, host[MB_PATH_MAXLINE];
	char	*unknown = "Unknown";

	/* read data for valid instance */
	if (instance >= 0)
	    {

	    /* get the number of sites to be written to the outpuf file */
	    status = mbview_getsitecount(verbose, instance, &nsite, &error);
	    if (status == MB_SUCCESS && nsite <= 0)
	    	{
		fprintf(stderr,"Unable to write site file...\nCurrently %d sites defined for instance %d!\n",
			nsite, instance);
		XBell((Display *) XtDisplay(mainWindow),100);
		status = MB_FAILURE;
		}
	    
	    /* allocate arrays for sites */
	    if (status == MB_SUCCESS && nsite > 0)
		{
		/* allocate the arrays */
		sitelon = NULL;
		sitelat = NULL;
		sitetopo = NULL;
		sitecolor = NULL;
		sitesize = NULL;
		sitename = NULL;
		status = mbview_allocsitearrays(verbose, 
			nsite, &sitelon, &sitelat, &sitetopo,
			&sitecolor, &sitesize, &sitename, &error);

		/* if error initializing memory then cancel dealing with sites */
		if (status == MB_FAILURE)
	    		{
			nsite = 0;		    
			fprintf(stderr,"Unable to write site file...\nArray allocation for %d sites failed for instance %d!\n",
				nsite, instance);
			XBell((Display *) XtDisplay(mainWindow),100);
			}
		}
	    
	    /* get the sites */
	    if (status == MB_SUCCESS)
	    	{
	    	status = mbview_getsites(verbose, instance,
			&nsite, sitelon, sitelat, sitetopo, 
			sitecolor, sitesize, sitename,
			&error);
		}
		
	    /* write the sites to the output file */
	    if (status == MB_SUCCESS)
	    	{
		/* open the output file */
		if ((sfp = fopen(output_file_ptr, "w")) != NULL) 
			{
			/* write the site file header */
			fprintf(sfp, "## Site File Version %s\n", MBGRDVIZ_SITE_VERSION);
			fprintf(sfp, "## Output by Program %s\n",program_name); 
			fprintf(sfp, "## Program Version %s\n",rcs_id);
			fprintf(sfp, "## MB-System Version %s\n",MB_VERSION);
			strncpy(date,"\0",25);
			right_now = time((time_t *)0);
			strncpy(date,ctime(&right_now),24);
			if ((user_ptr = getenv("USER")) == NULL)
				if ((user_ptr = getenv("LOGNAME")) == NULL)
					user_ptr = unknown;
			gethostname(host,MB_PATH_MAXLINE);
			fprintf(sfp, "## Run by user <%s> on cpu <%s> at <%s>\n",
				user_ptr,host,date);
			fprintf(sfp, "## Number of sites: %d\n",nsite); 
			
			/* loop over the sites */
			for (i=0;i<nsite;i++)
				{
				fprintf(sfp,"%12.7f %12.7f %10.3f %2d %2d %s\n",
			 	   	sitelon[i], sitelat[i], sitetopo[i], 
			    		sitecolor[i], sitesize[i],
			    		sitename[i]);
				
				}

			/* close the output file */
			fclose(sfp);
			}
			
		/* output error message */
		else
			{
			error = MB_ERROR_OPEN_FAIL;
			fprintf(stderr,"\nUnable to Open Site File <%s> for writing\n",output_file_ptr);
			XBell((Display *) XtDisplay(mainWindow),100);
			status = MB_FAILURE;
			}
		}
	    
	    /* deallocate arrays for sites */
	    if (nsite > 0)
	    	{
		status = mbview_freesitearrays(verbose, 
			&sitelon, &sitelat, &sitetopo,
			&sitecolor, &sitesize, &sitename, &error);
		}

	    }
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_openroute(int instance, char *input_file_ptr)
{
	char function_name[] = "do_mbgrdviz_openroute";
	int	status = MB_SUCCESS;
	FILE	*sfp;
	char	buffer[MB_PATH_MAXLINE];
	int	npoint = 0;
	int	npointalloc = 0;
	double	*routelon = NULL;
	double	*routelat = NULL;
	double	lon, lat, topo;
	int	interpolated;
	int	routecolor;
	int	routesize;
	mb_path	routename;
	int	rawroutefile = MB_YES;
	char	*result;
	char	*name;
	int	nget;
	int	point_ok;
	int	i;

	/* read data for valid instance */
	if (instance >= 0)
	    {
	    /* initialize route values */
	    routecolor = MBV_COLOR_RED;
	    routesize = 1;
	    routename[0] = '\0';
	    rawroutefile = MB_YES;
	    npoint = 0;
	    npointalloc = 0;
	    
	    /* open the input file */
	    if ((sfp = fopen(input_file_ptr, "r")) == NULL) 
		    {
		    error = MB_ERROR_OPEN_FAIL;
		    status == MB_FAILURE;
		    fprintf(stderr,"\nUnable to open route file <%s> for reading\n",input_file_ptr);
		    XBell((Display *) XtDisplay(mainWindow),100);
		    }

	    /* loop over reading */
	    if (status == MB_SUCCESS)
	    	{
		while ((result = fgets(buffer,MB_PATH_MAXLINE,sfp)) == buffer)
		    {
		    /* deal with comments */
		    if (buffer[0] == '#')
		    	{
			if (rawroutefile == MB_YES
				&& strncmp(buffer,"## Route File Version", 21) == 0)
				rawroutefile = MB_NO;
			else if (strncmp(buffer,"## ROUTENAME", 12) == 0)
				sscanf(buffer,"## ROUTENAME %[^\n]", routename);
			else if (strncmp(buffer,"## ROUTECOLOR", 12) == 0)
				sscanf(buffer,"## ROUTENAME %d", &routecolor);
			else if (strncmp(buffer,"## ROUTESIZE", 12) == 0)
				sscanf(buffer,"## ROUTENAME %d", &routesize);
			}
		
		    /* deal with route segment marker */
		    else if (buffer[0] == '>')
		    	{
			/* if data accumulated call mbview_addroute() */
			if (npoint > 0)
			    {
			    status = mbview_addroute(2, instance,
			    				npoint, routelon, routelat,
							routecolor, routesize, routename,
							&error);
			    npoint = 0;
			    }
			}
			
		    /* deal with data */
		    else
		        {
			/* read the data from the buffer */
			nget = sscanf(buffer,"%lf %lf %lf %d",
			    &lon, &lat, &topo, &interpolated);
		    	if ((rawroutefile == MB_YES && nget >= 2)
				|| (rawroutefile == MB_NO && nget >= 3 && interpolated == MB_NO))
			    point_ok = MB_YES;
			else
			    point_ok = MB_NO;
			    
			/* if good data check for need to allocate more space */
			if (point_ok == MB_YES
				&& npoint + 1 > npointalloc)
			    {
			    npointalloc += MBV_ALLOC_NUM;
			    status = mbview_allocroutearrays(2, 
						    npointalloc,
						    &routelon,
						    &routelat,
						    NULL,
						    NULL,
						    NULL,
						    NULL,
						    NULL,
						    &error);
			    if (status != MB_SUCCESS)
				    {
				    npointalloc = 0;
				    }
			    }
			    
			/* add good point to route */
			if (point_ok == MB_YES && npointalloc > npoint + 1)
			    {
			    routelon[npoint] = lon;
			    routelat[npoint] = lat;
			    npoint++;
			    }
			}
		    }
		    
		/* free the memory */
		if (npointalloc > 0)
		status = mbview_freeroutearrays(verbose, 
						    &routelon,
						    &routelat,
						    NULL,
						    NULL,
						    NULL,
						    NULL,
						    NULL,
						    &error);

		/* close the input file */
		fclose(sfp);
		}

	    /* update widgets */
	    if (status == MB_SUCCESS)
	    status = mbview_update(verbose, instance, &error);
	    }
			
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_saveroute(int instance, char *output_file_ptr)
{
	char function_name[] = "do_mbgrdviz_saveroute";
	int	status = MB_SUCCESS;
	FILE	*sfp;
	char	buffer[MB_PATH_MAXLINE];
	int	nroute = 0;
	int	npoint = 0;
	int	nintpoint = 0;
	int	npointtotal = 0;
	int	npointalloc = 0;
	double	*routelon = NULL;
	double	*routelat = NULL;
	int	*interpolated = NULL;
	double	*routetopo = NULL;
	double	*distlateral = NULL;
	double	*distovertopo = NULL;
	double	*slope = NULL;
	int	routecolor;
	int	routesize;
	mb_path	routename;
	int	iroute, j;

	/* time, user, host variables */
	time_t	right_now;
	char	date[25], *user_ptr, host[MB_PATH_MAXLINE];
	char	*unknown = "Unknown";

	/* read data for valid instance */
	if (instance >= 0)
	    {

	    /* get the number of routes to be written to the outpuf file */
	    status = mbview_getroutecount(verbose, instance, &nroute, &error);
	    if (nroute <= 0)
	    	{
		fprintf(stderr,"Unable to write route file...\nCurrently %d routes defined for instance %d!\n",
			nroute, instance);
		XBell((Display *) XtDisplay(mainWindow),100);
		status = MB_FAILURE;
		}
		
	    /* initialize the output file */
	    if (status == MB_SUCCESS && nroute > 0)
	    	{
		/* open the output file */
		if ((sfp = fopen(output_file_ptr, "w")) != NULL) 
			{
			/* write the route file header */
			fprintf(sfp, "## Route File Version %s\n", MBGRDVIZ_ROUTE_VERSION);
			fprintf(sfp, "## Output by Program %s\n",program_name); 
			fprintf(sfp, "## Program Version %s\n",rcs_id);
			fprintf(sfp, "## MB-System Version %s\n",MB_VERSION);
			strncpy(date,"\0",25);
			right_now = time((time_t *)0);
			strncpy(date,ctime(&right_now),24);
			if ((user_ptr = getenv("USER")) == NULL)
				if ((user_ptr = getenv("LOGNAME")) == NULL)
					user_ptr = unknown;
			gethostname(host,MB_PATH_MAXLINE);
			fprintf(sfp, "## Run by user <%s> on cpu <%s> at <%s>\n",
				user_ptr,host,date);
			fprintf(sfp, "## Number of routes: %d\n",nroute); 
			fprintf(sfp, "## Route point format:\n"); 
			fprintf(sfp, "##   <longitude (deg)> <latitude (deg)> <interpolated (boolean)> <topography (m)> <lateral distance (m)> <distance along topography (m)> <slope (m/m)>\n"); 
			}
			
		/* output error message */
		else
			{
			error = MB_ERROR_OPEN_FAIL;
			status = MB_FAILURE;
			fprintf(stderr,"\nUnable to Open route file <%s> for writing\n",output_file_ptr);
			XBell((Display *) XtDisplay(mainWindow),100);
			}
		}
	    
	    /* if all ok proceed to extract and output routes */
	    if (status == MB_SUCCESS)
	    	{
	        /* loop over routes */
		for (iroute=0;iroute<nroute;iroute++)
	    	    {
		    /* get point count for current route */
		    status = mbview_getroutepointcount(verbose, instance,
			    iroute, &npoint, &nintpoint, &error);

		    /* allocate route arrays */
		    npointtotal = npoint + nintpoint;
		    if (status == MB_SUCCESS
			    && npointalloc < npointtotal)
			    {
			    status = mbview_allocroutearrays(verbose, 
						    npointtotal,
						    &routelon,
						    &routelat,
						    &interpolated,
						    &routetopo,
						    &distlateral,
						    &distovertopo,
						    &slope,
						    &error);
			    if (status == MB_SUCCESS)
				    {
				    npointalloc = npointtotal;
				    }

			    /* if error initializing memory then cancel dealing with this route */
			    else
	    			    {
				    fprintf(stderr,"Unable to write route...\nArray allocation for %d points failed for instance %d!\n",
					    npointtotal, instance);
				    XBell((Display *) XtDisplay(mainWindow),100);
				    npoint = 0;		    
				    nintpoint = 0;		    
				    npointtotal = 0;		    
				    }
			    }

		    /* extract data for route */
		    status = mbview_getroute(verbose, instance,
					    iroute,
					    &npointtotal,
					    routelon,
					    routelat,
					    interpolated,
					    routetopo,
					    distlateral,
					    distovertopo,
					    slope,
					    &routecolor,
					    &routesize,
					    routename,
					    &error);

		    /* write the route header */
		    fprintf(sfp,"## ROUTENAME %s\n", routename);
		    fprintf(sfp,"## ROUTESIZE %d\n", routesize);
		    fprintf(sfp,"## ROUTECOLOR %d\n", routecolor);
		    fprintf(sfp,"## ROUTEPOINTS %d\n", npointtotal);
		    fprintf(sfp,"> STARTROUTE\n");

		    /* write the route points */
		    for (j=0;j<npointtotal;j++)
			    {
			    fprintf(sfp,"%f %f %f %d %f %f %f\n",
				    routelon[j], routelat[j], routetopo[j],
				    interpolated[j],
				    distlateral[j], distovertopo[j], slope[j]);
			    }

		    /* write the route end */
		    fprintf(sfp,"> ENDROUTE\n");
		    }

		/* close the output file */
		fclose(sfp);

		/* deallocate arrays */
		if (npointalloc > 0)
	    	    {
		    status = mbview_freeroutearrays(verbose, 
					    &routelon,
					    &routelat,
					    &interpolated,
					    &routetopo,
					    &distlateral,
					    &distovertopo,
					    &slope,
					    &error);
		    }
		}
	    }
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_readgrd(int instance, char *grdfile,
			int	*grid_projection_mode,
			char	*grid_projection_id,
			float	*nodatavalue,
			int	*nxy,
			int	*nx,
			int	*ny,
			double	*min,
			double	*max,
			double	*xmin,
			double	*xmax,
			double	*ymin,
			double	*ymax,
			double	*dx,
			double	*dy,
			float	**data)
{
	char function_name[] = "do_mbgrdviz_readgrd";
	int	status = MB_SUCCESS;
	struct GRD_HEADER header;
	int	modeltype;
	int	projectionid;
        char    projectionname[MB_PATH_MAXLINE];
	int	off;
	int	pad[4];
	int	nscan;
	int	utmzone;
        float   NaN;
	char	*projection = "-Jx1.0";
	float	*rawdata;
	float	*usedata;
	int	i,j,k,kk;
	
#ifdef GMT3_0
	gmt_begin (pargc, pargv);
#else
	GMT_begin (pargc, pargv);
#endif
#ifdef GMT3_0
	get_common_args (projection, xmin, xmax, ymin, ymax);
#else
	GMT_get_common_args (projection, xmin, xmax, ymin, ymax);
#endif
 	
#ifdef GMT3_0
	grd_init (&header, pargc, pargv, FALSE);
#else
	GMT_grd_init (&header, pargc, pargv, FALSE);
#endif
#ifndef GMT3_0
	GMT_make_fnan (GMT_f_NaN);
	GMT_make_dnan (GMT_d_NaN);
	GMT_grd_in_nan_value = GMT_grd_out_nan_value = GMT_d_NaN;
#endif
	
	/* read input grd file header */
#ifdef GMT3_0
	if (read_grd_info (grdfile, &header)) 
#else
fprintf(stderr,"calling GMT_read_grd_info: %s header:%d\n",grdfile, header.nx);
	if (GMT_read_grd_info (grdfile, &header)) 
#endif
	    {
	    error = MB_ERROR_OPEN_FAIL;
	    fprintf(stderr,"\nUnable to open grd file: %s\n",
		    grdfile);
	    fprintf(stderr,"\nProgram <%s> Terminated\n",
	    		program_name);
	    exit(error);
	    }
fprintf(stderr,"done calling GMT_read_grd_info: %s header:%d\n",grdfile, header.nx);

	/* set up internal arrays */
    	*nodatavalue = MIN(MBV_DEFAULT_NODATA, header.z_min - 10 * (header.z_max - header.z_min));
    	*nxy = header.nx * header.ny;
    	*nx = header.nx;
    	*ny = header.ny;
    	*xmin = header.x_min; 
    	*xmax = header.x_max; 
    	*ymin = header.y_min; 
    	*ymax = header.y_max; 
    	*dx = header.x_inc;
    	*dy = header.y_inc;
    	*min = header.z_min; 
    	*max = header.z_max; 

    	status = mb_malloc(verbose, sizeof(float) * (*nxy), 
    				&rawdata,
				&error);
    	if (status == MB_SUCCESS)
	status = mb_malloc(verbose, sizeof(float) * (*nxy), 
    				&usedata,
				&error);
	*data = usedata;
	if (status != MB_SUCCESS)
	    {
	    fprintf(stderr,"\nUnable to allocate memory to store data from grd file: %s\n",
		    grdfile);
	    fprintf(stderr,"\nProgram <%s> Terminated\n",
		    program_name);
	    exit(error);
	    }

	/* Determine the wesn to be used to read the grdfile */
	off = (header.node_offset) ? 0 : 1;
#ifdef GMT3_0
	map_setup (*xmin, *xmax, *ymin, *ymax);
	grd_setregion (&header, xmin,  xmax, ymin, ymax);
#else
	GMT_map_setup (*xmin, *xmax, *ymin, *ymax);
	GMT_grd_setregion (&header, xmin,  xmax, ymin, ymax);
#endif	

	/* read the grid */
	pad[0] = 0;
	pad[1] = 0;
	pad[2] = 0;
	pad[3] = 0;
#ifdef GMT3_0
	if (read_grd (grdfile, &header, rawdata, 
			    *xmin, *xmax, *ymin, *ymax, 
			    pad, FALSE))
#else
	if (GMT_read_grd (grdfile, &header, rawdata, 
			    *xmin, *xmax, *ymin, *ymax, 
			    pad, FALSE))
#endif
	    {
	    error = MB_ERROR_OPEN_FAIL;
	    fprintf(stderr,"\nUnable to read grd file: %s\n",
		    grdfile);
	    fprintf(stderr,"\nProgram <%s> Terminated\n",
		    program_name);
	    exit(error);
	    }
	    
	/* reorder grid to internal convention */
	for (i=0;i<*nx;i++)
	for (j=0;j<*ny;j++)
		{
		k = i * *ny + j;
		kk = (*ny - 1 - j) * *nx + i;
		if (check_fnan(rawdata[kk]))
			usedata[k] = *nodatavalue;
		else
			usedata[k] = rawdata[kk];
		}
	mb_free(verbose, &rawdata, &error);
	    
	/* try to get projection from the grd file remark */
	if (strncmp(&(header.remark[2]), "Projection: ", 12) == 0)
		{
		if ((nscan = sscanf(&(header.remark[2]), "Projection: UTM%dN", &utmzone)) == 1)
			{
			sprintf(projectionname, "UTM%dN", utmzone);
			modeltype = ModelTypeProjected;
			projectionid = 32600 + utmzone;
			*grid_projection_mode = MBV_PROJECTION_PROJECTED;
			sprintf(grid_projection_id, "epsg%d", projectionid);
			}
		else if ((nscan = sscanf(&(header.remark[2]), "Projection: UTM%dS", &utmzone)) == 1)
			{
			sprintf(projectionname, "UTM%dS", utmzone);
			modeltype = ModelTypeProjected;
			projectionid = 32700 + utmzone;
			*grid_projection_mode = MBV_PROJECTION_PROJECTED;
			sprintf(grid_projection_id, "epsg%d", projectionid);
			}
		else if ((nscan = sscanf(&(header.remark[2]), "Projection: epsg%d", &projectionid)) == 1)
			{
			sprintf(projectionname, "epsg%d", projectionid);
			modeltype = ModelTypeProjected;
			*grid_projection_mode = MBV_PROJECTION_PROJECTED;
			sprintf(grid_projection_id, "epsg%d", projectionid);
			}
		else
			{
			strcpy(projectionname, "Geographic WGS84");
			modeltype = ModelTypeGeographic;
			projectionid = GCS_WGS_84;
			*grid_projection_mode = MBV_PROJECTION_GEOGRAPHIC;
			sprintf(grid_projection_id, "epsg%d", projectionid);
			}
		}
	else
		{
		strcpy(projectionname, "Geographic WGS84");
		modeltype = ModelTypeGeographic;
		projectionid = GCS_WGS_84;
		*grid_projection_mode = MBV_PROJECTION_GEOGRAPHIC;
		sprintf(grid_projection_id, "epsg%d", projectionid);
		}	

	/* print debug info */
	if (verbose >= 0)
	    {
	    fprintf(stderr,"Grid read:\n");
	    fprintf(stderr,"  Dimensions: %d %d\n", header.nx, header.ny);
	    if (modeltype == ModelTypeProjected)
	    	{
		fprintf(stderr,"  Projected Coordinate System Name: %s\n", projectionname);
		fprintf(stderr,"  Projected Coordinate System ID:   %d\n", projectionid);
	    	fprintf(stderr,"  Easting:    %f %f  %f\n",
		  	header.x_min, header.x_max, header.x_inc);
	    	fprintf(stderr,"  Northing:   %f %f  %f\n",
		  	header.y_min, header.y_max, header.y_inc);
		}
	    else
		{
		fprintf(stderr,"  Geographic Coordinate System Name: %s\n", projectionname);
		fprintf(stderr,"  Geographic Coordinate System ID:   %d\n", projectionid);
	    	fprintf(stderr,"  Longitude:  %f %f  %f\n",
		  	header.x_min, header.x_max, header.x_inc);
	    	fprintf(stderr,"  Latitude:   %f %f  %f\n",
		  	header.y_min, header.y_max, header.y_inc);
		}
	    fprintf(stderr,"  Internal Grid Projection Mode:         %d\n", 
	    			*grid_projection_mode);
	    fprintf(stderr,"  Internal Grid Projection ID:           %s\n", 
	    			grid_projection_id);

	    fprintf(stderr,"Data Read:\n");
	    fprintf(stderr,"  grid_projection_mode:     %d\n", *grid_projection_mode);
	    fprintf(stderr,"  grid_projection_id:       %s\n", grid_projection_id);
	    fprintf(stderr,"  nodatavalue:              %f\n", *nodatavalue);
	    fprintf(stderr,"  nx:                       %d\n", *nx);
	    fprintf(stderr,"  ny:                       %d\n", *ny);
	    fprintf(stderr,"  min:                      %f\n", *min);
	    fprintf(stderr,"  max:                      %f\n", *max);
	    fprintf(stderr,"  xmin:                     %f\n", *xmin);
	    fprintf(stderr,"  xmax:                     %f\n", *xmax);
	    fprintf(stderr,"  ymin:                     %f\n", *ymin);
	    fprintf(stderr,"  ymax:                     %f\n", *ymax);
	    fprintf(stderr,"  dx:                       %f\n", *dx);
	    fprintf(stderr,"  dy:                       %f\n", *dy);
	    fprintf(stderr,"  data:                     %d\n", *data);
	    }

	return(status);
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_opentest(int instance, 
			double	factor1, 
			double	factor2, 
			double	factor3, 
			int	*grid_projection_mode,
			char	*grid_projection_id,
			float	*nodatavalue,
			int	*nxy,
			int	*nx,
			int	*ny,
			double	*min,
			double	*max,
			double	*xmin,
			double	*xmax,
			double	*ymin,
			double	*ymax,
			double	*dx,
			double	*dy,
			float	**data)
{
	char function_name[] = "do_mbgrdviz_opentest";
	int	status = MB_SUCCESS;
	double	xx, yy;
	float	*usedata;
	int	i, j, k;

	*grid_projection_mode = MBV_PROJECTION_GEOGRAPHIC;
	sprintf(grid_projection_id, "epsg%d", GCS_WGS_84);
    	*nodatavalue = MBV_DEFAULT_NODATA;
    	*nx = 501;
    	*ny = 501;
    	*nxy = *nx * *ny;
    	*xmin = -1.0;
    	*xmax = 1.0;
    	*ymin = -1.0;
    	*ymax = 1.0;
    	*dx = (*xmax - *xmin) / (*nx -1);
    	*dy = (*ymax - *ymin) / (*ny -1);
    	*min = 0.0;
    	*max = 1000.0;
    	*min = 0.0;
    	*max = 0.0;

    	if (status == MB_SUCCESS)
    	status = mb_malloc(verbose, sizeof(float) * *nxy, 
    				data,
				&error);
	usedata = *data;
	if (status != MB_SUCCESS)
	    {
	    fprintf(stderr,"\nUnable to allocate memory to store test data...\n");
	    fprintf(stderr,"\nProgram <%s> Terminated\n",
		    program_name);
	    exit(error);
	    }

	for (i=0;i<*nx;i++)
		for (j=0;j<*ny;j++)
			{
			k = i * *ny + j;
			xx = *xmin + i * *dx;
			yy = *ymin + j * *dy;
			usedata[k] = factor1 * sin(factor2 * M_PI * xx) 
							* sin(factor2 * M_PI * yy)
							* exp(-factor3 * xx * yy);
    			*min = MIN(*min, usedata[k]);
    			*max = MAX(*max, usedata[k]);
			}
	
	return(status);
}
/*---------------------------------------------------------------------------------------*/
