/*
 * README: This file is appended to at file generation time.
 * Edits can be made throughout the file
 */
/*
 * Generated by the ICS Builder Xcessory (BX).
 *
 * Builder Xcessory Version 5.0.3
 * Code Generator Xcessory 5.0.1 (09/29/98) 
 *
 */
#include <Xm/Xm.h>


/*
 * Standard includes for builtins.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

/* MBIO include files */
#include "../../include/mb_status.h"
#include "../../include/mb_define.h"
#include "../../include/mb_format.h"

/* GMT include files */
#include "gmt.h"

/* get NaN detector */
#if defined(isnanf)
#define check_fnan(x) isnanf((x))
#elif defined(isnan)
#define check_fnan(x) isnan((double)(x))
#elif HAVE_ISNANF == 1
#define check_fnan(x) isnanf(x)
extern int isnanf(float x);
#elif HAVE_ISNAN == 1
#define check_fnan(x) isnan((double)(x))
#elif HAVE_ISNAND == 1
#define check_fnan(x) isnand((double)(x))
#else
#define check_fnan(x) ((x) != (x))
#endif

/* mbview include file */
#include "mbview.h"

/* fileSelectionBox modes */
#define MBGRDVIZ_OPENGRID	0
#define MBGRDVIZ_OPENOVERLAY	1
#define MBGRDVIZ_OPENROUTE	2
#define MBGRDVIZ_OPENSITE	3
#define MBGRDVIZ_OPENNAV	4
#define MBGRDVIZ_OPENSWATH	5
#define MBGRDVIZ_SAVEROUTE	6
#define MBGRDVIZ_SAVESITE	7
#define MBGRDVIZ_REALTIME	8

/* Projection defines */
#define ModelTypeProjected	     1
#define ModelTypeGeographic	     2
#define GCS_WGS_84		  4326

/* Site and route file versions */
#define MBGRDVIZ_SITE_VERSION "1.00"
#define MBGRDVIZ_ROUTE_VERSION "1.00"

/* Survey planning parameters */
#define MBGRDVIZ_SURVEY_MODE_UNIFORM			0
#define MBGRDVIZ_SURVEY_MODE_VARIABLE			1
#define MBGRDVIZ_SURVEY_PLATFORM_SURFACE		0
#define MBGRDVIZ_SURVEY_PLATFORM_SUBMERGED_DEPTH	1
#define MBGRDVIZ_SURVEY_PLATFORM_SUBMERGED_ALTITUDE	2
#define MBGRDVIZ_SURVEY_DIRECTION_SW			0
#define MBGRDVIZ_SURVEY_DIRECTION_SE			1
#define MBGRDVIZ_SURVEY_DIRECTION_NW			2
#define MBGRDVIZ_SURVEY_DIRECTION_NE			3
#define	MBGRDVIZ_REALTIME_ICON_SHIP			0
#define	MBGRDVIZ_REALTIME_ICON_ROV			1
#define	MBGRDVIZ_REALTIME_ICON_AUV			2
#define	MBGRDVIZ_REALTIME_OFF				0
#define	MBGRDVIZ_REALTIME_ON				1
#define	MBGRDVIZ_REALTIME_PAUSE				2
int	working_route = -1;
int	survey_instance = 0;
int	survey_mode = MBGRDVIZ_SURVEY_MODE_UNIFORM;
int	survey_platform = MBGRDVIZ_SURVEY_PLATFORM_SUBMERGED_ALTITUDE;
int	survey_interleaving = 1;
int	survey_direction = MBGRDVIZ_SURVEY_DIRECTION_SW;
int	survey_crosslines = 0;
int	survey_linespacing = 200;
int	survey_swathwidth = 120;
int	survey_depth = 0;
int	survey_altitude = 150;
int	survey_color = MBV_COLOR_BLACK;
char	survey_name[MB_PATH_MAXLINE];
mb_path	realtime_path;
int	realtime_status = MBGRDVIZ_REALTIME_OFF;
int	realtime_update = 5;
int	realtime_icon = MBGRDVIZ_REALTIME_ICON_SHIP;

/* id variables */
static char rcs_id[] = "$Id: mbgrdviz_callbacks.c,v 5.16 2006-01-24 19:21:32 caress Exp $";
static char program_name[] = "MBgrdviz";
static char help_message[] = "MBgrdviz is an interactive 2D/3D visualization tool for GMT grid files.";
static char usage_message[] = "mbgrdviz [-H -T -V]";

/* status variables */
int	verbose;
int	error;
int	pargc;
char	**pargv;

/* widgets */
int	mbview_id[MBV_MAX_WINDOWS];
extern 	Widget mainWindow;
Widget	fileSelectionList;
Widget	fileSelectionText;

/* function prototypes */
void do_mbgrdviz_sensitivity();
int do_mbgrdviz_dismiss_notify(int instance);
void do_mbgrdviz_fileSelectionBox( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_fileSelectionBox_openoverlay( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_fileSelectionBox_openroute( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_fileSelectionBox_opensite( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_fileSelectionBox_opennav( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_fileSelectionBox_openswath( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_fileSelectionBox_saveroute( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_fileSelectionBox_savesite( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_open_region( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_make_survey( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_arearoute_recalc(int instance);
void do_mbgrdviz_arearoute_info(int instance);
void do_mbgrdviz_realtimesetup_icon( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_realtimesetup_path_browse( Widget w, XtPointer client_data, XtPointer call_data);
void do_mbgrdviz_realtimesetup_updaterate( Widget w, XtPointer client_data, XtPointer call_data);

/*
 * Motif required Headers
 */
#include <X11/StringDefs.h>
#include <Xm/Xm.h>
#include <Xm/DialogS.h>
#include <Xm/Text.h>
#if (XmVersion >= 1002)
#include <Xm/RepType.h>
#endif
#include <Xm/MwmUtil.h>
#include "mbgrdviz_creation.h"

/*
 * Macros to make code look nicer between ANSI and K&R.
 */
#ifndef ARGLIST
#if (NeedFunctionPrototypes == 0)
#define PROTOTYPE(p)	()
#define ARGLIST(p)	p
#define ARG(a, b)	a b;
#define GRA(a, b)	a b;
#define UARG(a, b)      a b;
#define GRAU(a, b)      a b;
#else
#define PROTOTYPE(p)	p
#define ARGLIST(p)	(
#define ARG(a, b)	a b,
#define GRA(a, b)	a b)
#ifdef __cplusplus
#define UARG(a, b)      a,
#define GRAU(a, b)      a)
#else
#define UARG(a, b)      a b,
#define GRAU(a, b)      a b)
#endif
#endif
#endif

Widget		BxFindTopShell PROTOTYPE((Widget));
WidgetList	BxWidgetIdsFromNames PROTOTYPE((Widget, char*, char*));


/*      Function Name:	BxExitCB
 *
 *      Description:   	This functions expects an integer to be passed in
 *		       	client data.  It calls the exit() system call with
 *			the integer value as the argument to the function.
 *
 *      Arguments:      Widget		w: 	the activating widget.
 *			XtPointer	client:	the integer exit value.
 *			XtPointer	call:	the call data (unused).
 */

#ifdef VMS
#include <stdlib.h>
#endif

/* ARGSUSED */
void
BxExitCB ARGLIST((w, client, call))
UARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
    long	exitValue = (long)client;
    exit(exitValue);
}

/*      Function Name: 	BxManageCB
 *
 *      Description:   	Given a string of the form:
 *		       	"(WL)[widgetName, widgetName, ...]"
 *			BxManageCB attempts to convert the name to a Widget
 *			ID and manage the widget.
 *
 *      Arguments:     	Widget	    w:      the widget activating the callback.
 *		       	XtPointer   client: the list of widget names to attempt
 *					    to find and manage.
 *		       	XtPointer   call:   the call data (unused).
 *
 *      Notes:        *	This function expects that there is an application
 *		       	shell from which all other widgets are descended.
 */

/* ARGSUSED */
void
BxManageCB ARGLIST((w, client, call))
ARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
    WidgetList		widgets;
    int			i;

    /*
     * This function returns a NULL terminated WidgetList.  The memory for
     * the list needs to be freed when it is no longer needed.
     */
    widgets = BxWidgetIdsFromNames(w, "BxManageCB", (String)client);

    i = 0;
    while( widgets && widgets[i] != NULL )
    {
	XtManageChild(widgets[i]);
	i++;
    }
    XtFree((char *)widgets);
}

/*      Function Name: 	BxUnmanageCB
 *
 *      Description:   	Given a string of the form:
 *		       	"(WL)[widgetName, widgetName, ...]"
 *			BxUnmanageCB attempts to convert the name to a Widget
 *			ID and unmanage the widget.
 *
 *      Arguments:     	Widget	    w:      the widget activating the callback.
 *		       	XtPointer   client: the list of widget names to attempt
 *					    to find and unmanage.
 *		       	XtPointer   call:   the call data (unused).
 *
 *      Notes:        *	This function expects that there is an application
 *		       	shell from which all other widgets are descended.
 */

/* ARGSUSED */
void
BxUnmanageCB ARGLIST((w, client, call))
ARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
    WidgetList		widgets;
    int			i;

    /*
     * This function returns a NULL terminated WidgetList.  The memory for
     * the list needs to be freed when it is no longer needed.
     */
    widgets = BxWidgetIdsFromNames(w, "BxUnmanageCB", (String)client);

    i = 0;
    while( widgets && widgets[i] != NULL )
    {
	XtUnmanageChild(widgets[i]);
	i++;
    }
    XtFree((char *)widgets);
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_init(int argc, char **argv, int verbosity)
{
	char function_name[] = "do_mbgrdviz_init";
	int	status = MB_SUCCESS;
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	char	value_text[MB_PATH_MAXLINE];
	XmStringTable	str_list;
	int	i, j;

	pargc = argc;
	pargv = argv;
	verbose = verbosity;
	error = MB_ERROR_NO_ERROR;
			
	/* set about version label */
	sprintf(value_text, "::#TimesMedium14:t\"MB-System Release %s\"#TimesMedium14\"%s\"", 
		MB_VERSION, MB_BUILD_DATE);
	set_mbview_label_multiline_string(label_about_version, value_text);
   
	/* get additional widgets */
	fileSelectionList = (Widget) 
	    XmFileSelectionBoxGetChild(fileSelectionBox, 
					XmDIALOG_LIST);
	fileSelectionText = (Widget) 
	    XmFileSelectionBoxGetChild(fileSelectionBox, 
					XmDIALOG_TEXT);
	XtUnmanageChild(
		(Widget) XmFileSelectionBoxGetChild(
					fileSelectionBox, 
					XmDIALOG_HELP_BUTTON));

	/* set up survey planning widgets */

	/* set up line control */
	str_list = (XmStringTable) XtMalloc(2 * sizeof(XmString *));
	str_list[0] = XmStringCreateLocalized("Uniform");
	str_list[1] = XmStringCreateLocalized("Variable by Swath Width");
	ac = 0;
	XtSetArg(args[ac], XmNnumValues, 2); ac++;
	XtSetArg(args[ac], XmNvalues, str_list); ac++;
	XtSetValues(spinText_arearoute_linecontrol, args, ac);
	XmStringFree(str_list[0]);
	XmStringFree(str_list[1]);
	XtFree((XtPointer)str_list);

	/* set up platform type */
	str_list = (XmStringTable) XtMalloc(3 * sizeof(XmString *));
	str_list[0] = XmStringCreateLocalized("Surface Vessel");
	str_list[1] = XmStringCreateLocalized("Submerged - constant altitude");
	str_list[2] = XmStringCreateLocalized("Submerged - constant depth");
	ac = 0;
	XtSetArg(args[ac], XmNnumValues, 3); ac++;
	XtSetArg(args[ac], XmNvalues, str_list); ac++;
	XtSetValues(spinText_arearoute_platform, args, ac);
	XmStringFree(str_list[0]);
	XmStringFree(str_list[1]);
	XmStringFree(str_list[2]);
	XtFree((XtPointer)str_list);

	/* set up survey direction */
	str_list = (XmStringTable) XtMalloc(4 * sizeof(XmString *));
	str_list[0] = XmStringCreateLocalized("SW");
	str_list[1] = XmStringCreateLocalized("SE");
	str_list[2] = XmStringCreateLocalized("NW");
	str_list[3] = XmStringCreateLocalized("NE");
	ac = 0;
	XtSetArg(args[ac], XmNnumValues, 4); ac++;
	XtSetArg(args[ac], XmNvalues, str_list); ac++;
	XtSetValues(spinText_arearoute_direction, args, ac);
	XmStringFree(str_list[0]);
	XmStringFree(str_list[1]);
	XmStringFree(str_list[2]);
	XmStringFree(str_list[3]);
	XtFree((XtPointer)str_list);

	/* set up survey color */
	str_list = (XmStringTable) XtMalloc(6 * sizeof(XmString *));
	str_list[0] = XmStringCreateLocalized("Black");
	str_list[1] = XmStringCreateLocalized("Yellow");
	str_list[2] = XmStringCreateLocalized("Green");
	str_list[3] = XmStringCreateLocalized("Bluegreen");
	str_list[4] = XmStringCreateLocalized("Blue");
	str_list[5] = XmStringCreateLocalized("Purple");
	ac = 0;
	XtSetArg(args[ac], XmNnumValues, 6); ac++;
	XtSetArg(args[ac], XmNvalues, str_list); ac++;
	XtSetValues(spinText_arearoute_color, args, ac);
	XmStringFree(str_list[0]);
	XmStringFree(str_list[1]);
	XmStringFree(str_list[2]);
	XmStringFree(str_list[3]);
	XmStringFree(str_list[4]);
	XmStringFree(str_list[5]);
	XtFree((XtPointer)str_list);

	/* set up realtime control widgets */

	/* set up realtime display icon */
	str_list = (XmStringTable) XtMalloc(2 * sizeof(XmString *));
	str_list[0] = XmStringCreateLocalized("Ship");
	str_list[1] = XmStringCreateLocalized("ROV");
	str_list[2] = XmStringCreateLocalized("AUV");
	ac = 0;
	XtSetArg(args[ac], XmNnumValues, 3); ac++;
	XtSetArg(args[ac], XmNvalues, str_list); ac++;
	XtSetValues(spinText_realtimesetup_icon, args, ac);
	XmStringFree(str_list[0]);
	XmStringFree(str_list[1]);
	XtFree((XtPointer)str_list);

	/* initialize mbview_id list */
	for (i=0;i<MBV_MAX_WINDOWS;i++)
	    {
	    mbview_id[i] = MB_NO;
	    }
	    
	/* set sensitivity of widgets that require an mbview instance to be active */
	do_mbgrdviz_sensitivity( );

	return(0);
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_sensitivity()
{
   	int	mbview_active;
   	int	mbview_allactive;
        Cardinal ac = 0;
        Arg	args[256];
	int	i;
    
    	/* set file opening menu items only if an mbview instance is active */
	mbview_active = MB_NO;
	mbview_allactive = MB_YES;
	for (i=0;i<MBV_MAX_WINDOWS;i++)
		{
		if (mbview_id[i] == MB_YES)
			mbview_active = MB_YES;
		else
			mbview_allactive = MB_NO;
		}
    
    	/* set file opening menu item only if not all mbview instances are active */
	if (mbview_allactive != MB_YES)
		{
		ac = 0;
		XtSetArg(args[ac], XmNsensitive, True); ac++; 
		}
	else
		{
		ac = 0;
		XtSetArg(args[ac], XmNsensitive, False); ac++; 
		}
	XtSetValues(pushButton_file_openprimary, args, ac);
    
    	/* set other file opening menu items only if an mbview instance is active */
	if (mbview_active == MB_YES)
		{
		ac = 0;
		XtSetArg(args[ac], XmNsensitive, True); ac++; 
		}
	else
		{
		ac = 0;
		XtSetArg(args[ac], XmNsensitive, False); ac++; 
		}
	XtSetValues(pushButton_opensite, args, ac);
	XtSetValues(pushButton_openroute, args, ac);
	XtSetValues(pushButton_opennav, args, ac);
	XtSetValues(pushButton_openswath, args, ac);
	XtSetValues(pushButton_savesite, args, ac);
	XtSetValues(pushButton_saveroute, args, ac);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox( Widget w, XtPointer client_data, XtPointer call_data)
{
 	int	actionid;
	int	mode;
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* figure out what kind of file is to be opened */
	actionid = (int) client_data;
	mode = actionid / MBV_MAX_WINDOWS;
	if (mode > 0)
		instance = actionid - mode * MBV_MAX_WINDOWS;
	
	/* set title to open primary grid */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Open GMT Grid File"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	
	/* open primary grid */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*.grd", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;

	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox_openoverlay( Widget w, XtPointer client_data, XtPointer call_data)
{
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	int	actionid;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* get instance */
	instance = (int) client_data;
	
	/* set title to open file dialog  */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Open Overlay GMT Grid File"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	/* set fileSelectionBox parameters */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*.grd", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;
	actionid = MBGRDVIZ_OPENOVERLAY * MBV_MAX_WINDOWS + instance;
	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox_openroute( Widget w, XtPointer client_data, XtPointer call_data)
{
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	int	actionid;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* get instance */
	instance = (int) client_data;
	
	/* set title to open file dialog  */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Open Route File"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	/* set fileSelectionBox parameters */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*.rte", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;
	actionid = MBGRDVIZ_OPENROUTE * MBV_MAX_WINDOWS + instance;
	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox_opensite( Widget w, XtPointer client_data, XtPointer call_data)
{
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	int	actionid;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* get instance */
	instance = (int) client_data;
	
	/* set title to open file dialog  */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Open Site File"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	/* set fileSelectionBox parameters */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*.ste", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;
	actionid = MBGRDVIZ_OPENSITE * MBV_MAX_WINDOWS + instance;
	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox_opennav( Widget w, XtPointer client_data, XtPointer call_data)
{
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	int	actionid;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* get instance */
	instance = (int) client_data;
	
	/* set title to open file dialog  */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Open Navigation Datalist File"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	/* set fileSelectionBox parameters */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*.mb-1", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;
	actionid = MBGRDVIZ_OPENNAV * MBV_MAX_WINDOWS + instance;
	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox_openswath( Widget w, XtPointer client_data, XtPointer call_data)
{
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	int	actionid;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* get instance */
	instance = (int) client_data;
	
	/* set title to open file dialog  */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Open Swath Datalist File"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	/* set fileSelectionBox parameters */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*.mb-1", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;
	actionid = MBGRDVIZ_OPENSWATH * MBV_MAX_WINDOWS + instance;
	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox_saveroute( Widget w, XtPointer client_data, XtPointer call_data)
{
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	int	actionid;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* get instance */
	instance = (int) client_data;
	
	/* set title to open file dialog  */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Save Route File"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	/* set fileSelectionBox parameters */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;
	actionid = MBGRDVIZ_SAVEROUTE * MBV_MAX_WINDOWS + instance;
	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox_savesite( Widget w, XtPointer client_data, XtPointer call_data)
{
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	int	actionid;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* get instance */
	instance = (int) client_data;
	
	/* set title to open file dialog  */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Save Site File"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	/* set fileSelectionBox parameters */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;
	actionid = MBGRDVIZ_SAVESITE * MBV_MAX_WINDOWS + instance;
	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_fileSelectionBox_realtime( Widget w, XtPointer client_data, XtPointer call_data)
{
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	int	actionid;
        XmString	tmp0;
	int	argok;
    	XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    	/* get instance */
	instance = 0;
	
	/* set title to open file dialog  */
	ac = 0;
	XtSetArg(args[ac], XmNtitle, "Set Realtime Navigation Source"); ac++;
	XtSetValues(dialogShell_open, args, ac);
	BxManageCB(w, (XtPointer)"fileSelectionBox", call_data);

	/* set fileSelectionBox parameters */
	ac = 0;
	tmp0 = (XmString) BX_CONVERT(dialogShell_open, "*", 
                				XmRXmString, 0, &argok);
        XtSetArg(args[ac], XmNpattern, tmp0); ac++;
	actionid = MBGRDVIZ_REALTIME * MBV_MAX_WINDOWS + instance;
	XtSetArg(args[ac], XmNuserData, actionid); ac++;
	XtSetValues(fileSelectionBox, args, ac);
        XmStringFree((XmString)tmp0);
    
}
/*---------------------------------------------------------------------------------------*/
void
do_mbgrdviz_close( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
fprintf(stderr,"Called do_mbgrdviz_close\n");
}
/*---------------------------------------------------------------------------------------*/

void
do_mbgrdviz_quit( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_dismiss_notify(int instance)
{
	char function_name[] = "do_mbgrdviz_dismiss_notify";
	int	status = MB_SUCCESS;
	int	verbose = 0;
	int	i, j, k;
	
	/* set mbview window <id> to inactive */
	if (instance >= 0 && instance < MBV_MAX_WINDOWS
		&& mbview_id[instance] == MB_YES)
		{
		mbview_id[instance] = MB_NO;
	   	/* fprintf(stderr, "Freeing mbview window %d in local list...\n", 
				instance); */
		}
	else
	    	{
	   	/* fprintf(stderr, "Unable to free mbview - mbview window %d not found in local list...\n", 
				instance); */
	    	}

	/* update widgets of remaining mbview windows */
	for (i=0;i<MBV_MAX_WINDOWS;i++)
		{
		if (mbview_id[i] == MB_YES)
			status = mbview_update(verbose, i, &error);
		}
	    
	/* set sensitivity of widgets that require an mbview instance to be active */
	do_mbgrdviz_sensitivity( );
	
	return(status);
}
/*---------------------------------------------------------------------------------------*/

void
do_mbgrdviz_openfile( Widget w, XtPointer client_data, XtPointer call_data)
{
	char function_name[] = "do_mbgrdviz_openfile";
	int	status = MB_SUCCESS;
	int	actionid;
	int	mode;
	int	instance;
	char    *file_ptr;
        Cardinal ac = 0;
        Arg      args[256];
    XmFileSelectionBoxCallbackStruct *acs=(XmFileSelectionBoxCallbackStruct*)call_data;

    	/* figure out what kind of file is to be opened */

	ac = 0;
	XtSetArg(args[ac], XmNuserData, (XtPointer) &actionid); ac++;
	XtGetValues(fileSelectionBox, args, ac);

	mode = actionid / MBV_MAX_WINDOWS;
	if (mode > 0)
		instance = actionid - mode * MBV_MAX_WINDOWS;
	else
		instance = 0;

	/* read the input file name */
	XmStringGetLtoR(acs->value, XmSTRING_DEFAULT_CHARSET, 
			&file_ptr);
	if (strlen(file_ptr) <= 0 && file_ptr != NULL)
		{
		XtFree(file_ptr);
		file_ptr = NULL;
		}
	
	/* open primary grid */
	if (mode <= MBGRDVIZ_OPENGRID)
		{
		/* read the grid and open mbview window */
		status = do_mbgrdviz_openprimary(file_ptr);
		}
	
	/* else open overlay grid */
	else if (mode == MBGRDVIZ_OPENOVERLAY)
		{
		/* read the grid and update mbview window */
		do_mbview_message_on("Reading overlay grid...", instance);
		status = do_mbgrdviz_openoverlay(instance, file_ptr);
		}
	
	/* else open route data */
	else if (mode == MBGRDVIZ_OPENROUTE)
		{
		/* read route file and update mbview window */
		do_mbview_message_on("Reading route data...", instance);
		status = do_mbgrdviz_openroute(instance, file_ptr);
		}
	
	/* else open site data */
	else if (mode == MBGRDVIZ_OPENSITE)
		{
		/* read site file and update mbview window */
		do_mbview_message_on("Reading site data...", instance);
		status = do_mbgrdviz_opensite(instance, file_ptr);
		}
	
	/* else open nav data */
	else if (mode == MBGRDVIZ_OPENNAV)
		{
		/* read nav file and update mbview window */
		do_mbview_message_on("Reading navigation data...", instance);
		status = do_mbgrdviz_opennav(instance, MB_NO, file_ptr);
		}
	
	/* else open swath data */
	else if (mode == MBGRDVIZ_OPENSWATH)
		{
		/* read nav file and update mbview window */
		do_mbview_message_on("Reading swath data...", instance);
		status = do_mbgrdviz_opennav(instance, MB_YES, file_ptr);
		}
	
	/* else write site data */
	else if (mode == MBGRDVIZ_SAVESITE)
		{
		/* write site file */
		do_mbview_message_on("Saving site data...", instance);
		status = do_mbgrdviz_savesite(instance, file_ptr);
		}
	
	/* else write route data */
	else if (mode == MBGRDVIZ_SAVEROUTE)
		{
		/* write route file */
		do_mbview_message_on("Saving route data...", instance);
		status = do_mbgrdviz_saveroute(instance, file_ptr);
		}
	
	/* else set realtime data source */
	else if (mode == MBGRDVIZ_REALTIME)
		{
		/* Set realtime source path */
		XmTextSetString(textField_realtimesetup_path, file_ptr);
		
		}

	/* free the string */
	if (file_ptr != NULL)
		{
		XtFree(file_ptr);
		file_ptr = NULL;
		}

	/* close the message */
	if (mode > MBGRDVIZ_OPENGRID && mode != MBGRDVIZ_REALTIME)
		do_mbview_message_off(instance);
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_openprimary(char *input_file_ptr)
{
	char function_name[] = "do_mbgrdviz_openprimary";
	int	status = MB_SUCCESS;
	char    *button_name_ptr;
	double	xx, yy;
	int	instance;
	int	i, j, k;
        Cardinal ac = 0;
        Arg      args[256];
        Cardinal cdc = 0;
        Boolean  argok = False;
        XmString    tmp0;
	int	actionid;
	char	*testname = "Internal Test Grid";
	int	projectionid, utmzone;
	double	reference_lon;
	
	/* mbview parameters */
	int 	(*mbview_dismiss_notify)(int id);
	char	mbv_title[MB_PATH_MAXLINE];
	int	mbv_xo;
	int	mbv_yo;
	int	mbv_width;
	int	mbv_height;
	int	mbv_lorez_dimension;
	int	mbv_hirez_dimension;
	int	mbv_lorez_navdecimate;
	int	mbv_hirez_navdecimate;
	int	mbv_display_mode;
	int	mbv_mouse_mode;
	int	mbv_grid_mode;
	int	mbv_primary_shade_mode;
	int	mbv_slope_shade_mode;
	int	mbv_secondary_shade_mode;
	int	mbv_grid_contour_mode;
	int	mbv_site_view_mode;
	int	mbv_route_view_mode;
	int	mbv_nav_view_mode;
	int	mbv_navdrape_view_mode;
	int	mbv_primary_colortable;
	int	mbv_primary_colortable_mode;
	double	mbv_primary_colortable_min;
	double	mbv_primary_colortable_max;
	int	mbv_slope_colortable;
	int	mbv_slope_colortable_mode;
	double	mbv_slope_colortable_min;
	double	mbv_slope_colortable_max;
	int	mbv_secondary_colortable;
	int	mbv_secondary_colortable_mode;
	double	mbv_secondary_colortable_min;
	double	mbv_secondary_colortable_max;
	double	mbv_exageration;
	double	mbv_modelelevation3d;
	double	mbv_modelazimuth3d;
	double	mbv_viewelevation3d;
	double	mbv_viewazimuth3d;
	double	mbv_illuminate_magnitude;
	double	mbv_illuminate_elevation;
	double	mbv_illuminate_azimuth;
	double	mbv_slope_magnitude;
	double	mbv_overlay_shade_magnitude;
	double	mbv_overlay_shade_center;
	int	mbv_overlay_shade_mode;
	double	mbv_contour_interval;
	int	mbv_primary_grid_projection_mode;
	char	mbv_primary_grid_projection_id[MB_PATH_MAXLINE];
	int	mbv_secondary_grid_projection_mode;
	char	mbv_secondary_grid_projection_id[MB_PATH_MAXLINE];
	int	mbv_display_projection_mode;
	char	mbv_display_projection_id[MB_PATH_MAXLINE];
	float	mbv_primary_nodatavalue;
	int	mbv_primary_nxy;
	int	mbv_primary_nx;
	int	mbv_primary_ny;
	double	mbv_primary_min;
	double	mbv_primary_max;
	double	mbv_primary_xmin;
	double	mbv_primary_xmax;
	double	mbv_primary_ymin;
	double	mbv_primary_ymax;
	double	mbv_primary_dx;
	double	mbv_primary_dy;
	float	*mbv_primary_data;

	/* get next instance number */
	status = mbview_init(verbose, &instance, &error);
	if (instance < 0)
		{
		fprintf(stderr, "Unable to create mbview - %d mbview windows already created\n", 
		MBV_MAX_WINDOWS);
		}
	    
	else if (instance >= 0)
		{
		/* get button name */
		if (input_file_ptr != NULL)
			{
			button_name_ptr = (char *) rindex(input_file_ptr, '/');
			if (button_name_ptr == NULL)
				button_name_ptr = input_file_ptr;
			else
				button_name_ptr++;
			}
		else
			{
			button_name_ptr = testname;
			}
				

		/* set parameters */
		sprintf(mbv_title, "MBgrdviz: %s\n", button_name_ptr);
		mbv_xo = 200;
		mbv_yo = 200;
		mbv_width = 560;
		mbv_height = 500;
		mbv_lorez_dimension = 100;
		mbv_hirez_dimension = 500;
		mbv_lorez_navdecimate = 5;
		mbv_hirez_navdecimate = 1;

		/* set basic mbview window parameters */
		status = mbview_setwindowparms(verbose, instance,
					&do_mbgrdviz_dismiss_notify,
					mbv_title,
					mbv_xo,
					mbv_yo,
					mbv_width,
					mbv_height,
					mbv_lorez_dimension,
					mbv_hirez_dimension,
					mbv_lorez_navdecimate,
					mbv_hirez_navdecimate,
					&error);
		
		/* read in the grd file */
		if (status == MB_SUCCESS
			&& input_file_ptr != NULL)
		status = do_mbgrdviz_readgrd(instance, input_file_ptr,
			&mbv_primary_grid_projection_mode,
			mbv_primary_grid_projection_id,
			&mbv_primary_nodatavalue,
			&mbv_primary_nxy,
			&mbv_primary_nx,
			&mbv_primary_ny,
			&mbv_primary_min,
			&mbv_primary_max,
			&mbv_primary_xmin,
			&mbv_primary_xmax,
			&mbv_primary_ymin,
			&mbv_primary_ymax,
			&mbv_primary_dx,
			&mbv_primary_dy,
			&mbv_primary_data);
			
		else if (status == MB_SUCCESS)
		status = do_mbgrdviz_opentest(instance, 
			1000.0, 3.0, 2.0, 
			&mbv_primary_grid_projection_mode,
			mbv_primary_grid_projection_id,
			&mbv_primary_nodatavalue,
			&mbv_primary_nxy,
			&mbv_primary_nx,
			&mbv_primary_ny,
			&mbv_primary_min,
			&mbv_primary_max,
			&mbv_primary_xmin,
			&mbv_primary_xmax,
			&mbv_primary_ymin,
			&mbv_primary_ymax,
			&mbv_primary_dx,
			&mbv_primary_dy,
			&mbv_primary_data);

		/* set parameters */
		mbv_display_mode = MBV_DISPLAY_2D;
		mbv_mouse_mode = MBV_MOUSE_MOVE;
		mbv_grid_mode = MBV_GRID_VIEW_PRIMARY;
		mbv_primary_shade_mode = MBV_SHADE_VIEW_SLOPE;
		mbv_slope_shade_mode = MBV_SHADE_VIEW_NONE;
		mbv_secondary_shade_mode = MBV_SHADE_VIEW_NONE;
		mbv_grid_contour_mode = MBV_VIEW_OFF;
		mbv_site_view_mode = MBV_VIEW_OFF;
		mbv_route_view_mode = MBV_VIEW_OFF;
		mbv_nav_view_mode = MBV_VIEW_OFF;
		mbv_navdrape_view_mode = MBV_VIEW_OFF;
		mbv_primary_colortable = MBV_COLORTABLE_HAXBY;
		mbv_primary_colortable_mode = MBV_COLORTABLE_NORMAL;
		mbv_primary_colortable_min = mbv_primary_min;
		mbv_primary_colortable_max = mbv_primary_max;
		mbv_slope_colortable = MBV_COLORTABLE_HAXBY;
		mbv_slope_colortable_mode = MBV_COLORTABLE_REVERSED;
		mbv_slope_colortable_min = 0.0;
		mbv_slope_colortable_max = 0.5;
		mbv_secondary_colortable = MBV_COLORTABLE_HAXBY;
		mbv_secondary_colortable_mode = MBV_COLORTABLE_NORMAL;
		mbv_secondary_colortable_min = 0.0;
		mbv_secondary_colortable_max = 0.0;
		mbv_exageration = 1.0;
		mbv_modelelevation3d = 90.0;
		mbv_modelazimuth3d = 0.0;
		mbv_viewelevation3d = 90.0;
		mbv_viewazimuth3d = 0.0;
		mbv_illuminate_magnitude = 5.0;
		mbv_illuminate_elevation = 30.0;
		mbv_illuminate_azimuth = 90.0;
		mbv_slope_magnitude = 1.0;
		mbv_overlay_shade_magnitude = 1.0;
		mbv_overlay_shade_center = 0.0;
		mbv_overlay_shade_mode = MBV_COLORTABLE_NORMAL;
		mbv_contour_interval
			= pow(10.0, floor(log10(mbv_primary_max 
						- mbv_primary_min)) - 1.0);

		/* set the display projection */
		/* if grid projected then use the same projected coordinate system by default */
		if (mbv_primary_grid_projection_mode == MBV_PROJECTION_PROJECTED)
			{
			mbv_display_projection_mode = mbv_primary_grid_projection_mode;
			strcpy(mbv_display_projection_id,mbv_primary_grid_projection_id);
			}
			
		/* else if grid geographic and covers much of the world use spheroid */
		else if (mbv_primary_xmax - mbv_primary_xmin > 15.0
			|| mbv_primary_ymax - mbv_primary_ymin > 15.0)
			{
			mbv_display_projection_mode = MBV_PROJECTION_SPHEROID;
			sprintf(mbv_display_projection_id, "SPHEROID", projectionid);
			}
			
		/* else if grid geographic then use appropriate UTM zone for non-polar grids */
		else if (mbv_primary_ymax > -80.0
			&& mbv_primary_ymin < 84.0)
			{
			mbv_display_projection_mode = MBV_PROJECTION_PROJECTED;
			reference_lon = 0.5 * (mbv_primary_xmin + mbv_primary_xmax);
			if (reference_lon > 180.0)
				reference_lon -= 360.0;
			utmzone = (int)(((reference_lon + 183.0)
					/ 6.0) + 0.5);
			if (0.5 * (mbv_primary_ymin + mbv_primary_ymax) >= 0.0)
				projectionid = 32600 + utmzone;
			else
				projectionid = 32700 + utmzone;
			sprintf(mbv_display_projection_id, "epsg%d", projectionid);
			}
			
		/* else if grid geographic and more northerly than 84 deg N then use 
			North Univeral Polar Stereographic Projection */
		else if (mbv_primary_ymin > 84.0)
			{
			mbv_display_projection_mode = MBV_PROJECTION_PROJECTED;
			projectionid = 32661;
			sprintf(mbv_display_projection_id, "epsg%d", projectionid);
			}

		/* else if grid geographic and more southerly than 80 deg S then use 
			South Univeral Polar Stereographic Projection */
		else if (mbv_primary_ymax < 80.0)
			{
			mbv_display_projection_mode = MBV_PROJECTION_PROJECTED;
			projectionid = 32761;
			sprintf(mbv_display_projection_id, "epsg%d", projectionid);
			}

		/* else just use geographic */
		else
			{
			mbv_display_projection_mode = MBV_PROJECTION_GEOGRAPHIC;
			sprintf(mbv_display_projection_id, "epsg%d", GCS_WGS_84);
			}

		/* set basic mbview view controls */
		if (status == MB_SUCCESS)
		status = mbview_setviewcontrols(verbose, instance,
					mbv_display_mode,
					mbv_mouse_mode,
					mbv_grid_mode,
					mbv_primary_shade_mode,
					mbv_slope_shade_mode,
					mbv_secondary_shade_mode,
					mbv_grid_contour_mode,
					mbv_site_view_mode,
					mbv_route_view_mode,
					mbv_nav_view_mode,
					mbv_navdrape_view_mode,
					mbv_exageration,
					mbv_modelelevation3d,
					mbv_modelazimuth3d,
					mbv_viewelevation3d,
					mbv_viewazimuth3d,
					mbv_illuminate_magnitude,
					mbv_illuminate_elevation,
					mbv_illuminate_azimuth,
					mbv_slope_magnitude,
					mbv_overlay_shade_magnitude,
					mbv_overlay_shade_center,
					mbv_overlay_shade_mode,
					mbv_contour_interval,
					mbv_display_projection_mode,
					mbv_display_projection_id,
					&error);
		
		/* set primary grid data */
		if (status == MB_SUCCESS)
		status = mbview_setprimarygrid(verbose, instance,
					mbv_primary_grid_projection_mode,
					mbv_primary_grid_projection_id,
					mbv_primary_nodatavalue,
					mbv_primary_nx,
					mbv_primary_ny,
					mbv_primary_min,
					mbv_primary_max,
					mbv_primary_xmin,
					mbv_primary_xmax,
					mbv_primary_ymin,
					mbv_primary_ymax,
					mbv_primary_dx,
					mbv_primary_dy,
					mbv_primary_data,
					&error);
		
		/* set more mbview control values */
		if (status == MB_SUCCESS)
		status = mbview_setprimarycolortable(verbose, instance,
					mbv_primary_colortable,
					mbv_primary_colortable_mode,
					mbv_primary_colortable_min,
					mbv_primary_colortable_max,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_setslopecolortable(verbose, instance,
					mbv_slope_colortable,
					mbv_slope_colortable_mode,
					mbv_slope_colortable_min,
					mbv_slope_colortable_max,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_enableeditsites(verbose, instance,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_enableeditroutes(verbose, instance,
					&error);

		/* open up mbview window */
		if (status == MB_SUCCESS)
			{
			status = mbview_open(verbose, instance, &error);
			if (status == MB_SUCCESS)
				mbview_id[instance] = MB_YES;
			else
				mbview_id[instance] = MB_NO;

			/* add action button */
			if (status == MB_SUCCESS)
				{
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_openoverlay,
					"Open Overlay Grid", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_opensite,
					"Open Site File", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_openroute,
					"Open Route File", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_opennav,
					"Open Navigation", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_openswath,
					"Open Swath Data", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_savesite,
					"Save Site File", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_saveroute,
					"Save Route File", 
					MBV_PICKMASK_NONE, &error);

				mbview_addaction(verbose, instance,
					do_mbgrdviz_open_region,
					"Open Region as New View", 
					MBV_PICKMASK_REGION + MBV_PICKMASK_NEWINSTANCE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_make_survey,
					"Generate Survey Route from Area", 
					MBV_PICKMASK_AREA, &error);
				}
			}
		}
	    
	/* set sensitivity of widgets that require an mbview instance to be active */
	do_mbgrdviz_sensitivity( );
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_openoverlay(int instance, char *input_file_ptr)
{
	char function_name[] = "do_mbgrdviz_openoverlay";
	int	status = MB_SUCCESS;
	char    *button_name_ptr;
	double	xx, yy;
	int	i, j, k;
        Cardinal ac = 0;
        Arg      args[256];
        Cardinal cdc = 0;
        Boolean  argok = False;
        XmString    tmp0;
	char	*testname = "Internal Test Grid";
	
	/* mbview parameters */
	int	mbv_secondary_colortable;
	int	mbv_secondary_colortable_mode;
	double	mbv_secondary_colortable_min;
	double	mbv_secondary_colortable_max;
	int	mbv_secondary_grid_projection_mode;
	char	mbv_secondary_grid_projection_id[MB_PATH_MAXLINE];
	float	mbv_secondary_nodatavalue;
	int	mbv_secondary_nxy;
	int	mbv_secondary_nx;
	int	mbv_secondary_ny;
	double	mbv_secondary_min;
	double	mbv_secondary_max;
	double	mbv_secondary_xmin;
	double	mbv_secondary_xmax;
	double	mbv_secondary_ymin;
	double	mbv_secondary_ymax;
	double	mbv_secondary_dx;
	double	mbv_secondary_dy;
	float	*mbv_secondary_data;
	double	mbv_overlay_shade_magnitude;
	double	mbv_overlay_shade_center;
	int	mbv_overlay_shade_mode;

	/* read data for valid instance */
	if (instance >= 0)
		{
		
		/* read in the grd file */
		if (status == MB_SUCCESS
			&& input_file_ptr != NULL)
		status = do_mbgrdviz_readgrd(instance, input_file_ptr,
			&mbv_secondary_grid_projection_mode,
			mbv_secondary_grid_projection_id,
			&mbv_secondary_nodatavalue,
			&mbv_secondary_nxy,
			&mbv_secondary_nx,
			&mbv_secondary_ny,
			&mbv_secondary_min,
			&mbv_secondary_max,
			&mbv_secondary_xmin,
			&mbv_secondary_xmax,
			&mbv_secondary_ymin,
			&mbv_secondary_ymax,
			&mbv_secondary_dx,
			&mbv_secondary_dy,
			&mbv_secondary_data);
			
		else if (status == MB_SUCCESS)
		status = do_mbgrdviz_opentest(instance, 
			1000.0, 6.0, 1.5, 
			&mbv_secondary_grid_projection_mode,
			mbv_secondary_grid_projection_id,
			&mbv_secondary_nodatavalue,
			&mbv_secondary_nxy,
			&mbv_secondary_nx,
			&mbv_secondary_ny,
			&mbv_secondary_min,
			&mbv_secondary_max,
			&mbv_secondary_xmin,
			&mbv_secondary_xmax,
			&mbv_secondary_ymin,
			&mbv_secondary_ymax,
			&mbv_secondary_dx,
			&mbv_secondary_dy,
			&mbv_secondary_data);

		/* set parameters */
		mbv_secondary_colortable = MBV_COLORTABLE_HAXBY;
		mbv_secondary_colortable_mode = MBV_COLORTABLE_NORMAL;
		mbv_secondary_colortable_min = mbv_secondary_min;
		mbv_secondary_colortable_max = mbv_secondary_max;
		mbv_overlay_shade_magnitude = 1.0;
		mbv_overlay_shade_center = 0.5 * (mbv_secondary_max + mbv_secondary_min);
		mbv_overlay_shade_mode = MBV_COLORTABLE_NORMAL;

		/* set more mbview control values */
		if (status == MB_SUCCESS)
		status = mbview_setsecondarygrid(verbose, instance,
					mbv_secondary_grid_projection_mode,
					mbv_secondary_grid_projection_id,
					mbv_secondary_nodatavalue,
					mbv_secondary_nx,
					mbv_secondary_ny,
					mbv_secondary_min,
					mbv_secondary_max,
					mbv_secondary_xmin,
					mbv_secondary_xmax,
					mbv_secondary_ymin,
					mbv_secondary_ymax,
					mbv_secondary_dx,
					mbv_secondary_dy,
					mbv_secondary_data,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_setsecondarycolortable(verbose, instance,
					mbv_secondary_colortable,
					mbv_secondary_colortable_mode,
					mbv_secondary_colortable_min,
					mbv_secondary_colortable_max,
					mbv_overlay_shade_magnitude,
					mbv_overlay_shade_center,
					mbv_overlay_shade_mode,
					&error);
					
		/* update widgets */
		if (status == MB_SUCCESS)
		status = mbview_update(verbose, instance, &error);

		}
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_opensite(int instance, char *input_file_ptr)
{
	char function_name[] = "do_mbgrdviz_opensite";
	int	status = MB_SUCCESS;
	FILE	*sfp;
	char	buffer[MB_PATH_MAXLINE];
	int	nsite;
	double	*sitelon;
	double	*sitelat;
	double	*sitetopo;
	int	*sitecolor;
	int	*sitesize;
	mb_path	*sitename;
	char	*result;
	char	*name;
	int	nget;
	int	site_ok;
	int	i;

	/* read data for valid instance */
	if (instance >= 0)
	    {

	    /* count the sites in the input file */
	    nsite = 0;
	    if ((sfp = fopen(input_file_ptr, "r")) == NULL) 
		    {
		    error = MB_ERROR_OPEN_FAIL;
		    fprintf(stderr,"\nUnable to Open Site File <%s> for reading\n",input_file_ptr);
		    XBell((Display *) XtDisplay(mainWindow),100);
		    return(MB_FAILURE);
		    }
	    while ((result = fgets(buffer,MB_PATH_MAXLINE,sfp)) == buffer)
		    {
		    if (buffer[0] != '#')
		    	nsite++;
		    }
	    fclose(sfp);
	    
	    /* allocate arrays for sites */
	    if (nsite > 0)
		{
		/* allocate the arrays */
		sitelon = NULL;
		sitelat = NULL;
		sitetopo = NULL;
		sitecolor = NULL;
		sitesize = NULL;
		sitename = NULL;
		status = mbview_allocsitearrays(verbose, 
			nsite, &sitelon, &sitelat, &sitetopo,
			&sitecolor, &sitesize, &sitename, &error);

		/* if error initializing memory then cancel dealing with sites */
		if (status == MB_FAILURE)
			{
			nsite = 0;		    
			fprintf(stderr,"\nUnable to allocate arrays for %d sites\n",nsite);
			XBell((Display *) XtDisplay(mainWindow),100);
			return(status);
			}
		}
		
	    /* read the sites from the input file */
	    if (nsite > 0)
	    	{
		nsite = 0;
		if ((sfp = fopen(input_file_ptr, "r")) == NULL) 
			{
			error = MB_ERROR_OPEN_FAIL;
			status = MB_FAILURE;
			fprintf(stderr,"\nUnable to open site file <%s> for reading\n",input_file_ptr);
			XBell((Display *) XtDisplay(mainWindow),100);
			return(status);
			}
		while ((result = fgets(buffer,MB_PATH_MAXLINE,sfp)) == buffer)
		    {
		    site_ok = MB_NO;

		    /* deal with site in form: lon lat topo color size name */
		    if (buffer[0] != '#')
		    	{
			nget = sscanf(buffer,"%lf %lf %lf %d %d %[^\n]",
			    &sitelon[nsite], &sitelat[nsite], &sitetopo[nsite], 
			    &sitecolor[nsite], &sitesize[nsite],
			    &sitename[nsite]);
		    	if (nget >= 2)
			    site_ok = MB_YES;
			}
		    if (site_ok == MB_YES)
			{
		    	if (nget < 6)
		    	    {
			    name = (char *) sitename[nsite];
			    name[0] = '\0';
			    }
		    	if (nget < 5)
			    sitesize[nsite] = 0;
		    	if (nget < 4)
			    sitecolor[nsite] = 0;
		    	if (nget < 3)
			    sitetopo[nsite] = MBV_DEFAULT_NODATA;
			}

		    /* output some debug values */
		    if (verbose > 0 && site_ok == MB_YES)
			    {
			    fprintf(stderr,"\ndbg5  Site point read in program <%s>\n",program_name);
			    fprintf(stderr,"dbg5       site[%d]: %f %f %f  %d %d  %s\n",
				    nsite,sitelon[nsite],sitelat[nsite],sitetopo[nsite],
				    sitecolor[nsite],sitesize[nsite],
				    sitename[nsite]);
			    }
		    else if (verbose > 0 && site_ok == MB_NO)
			    {
			    fprintf(stderr,"\ndbg5  Unintelligible line read from site file in program <%s>\n",program_name);
			    fprintf(stderr,"dbg5       buffer:  %s\n",
				   buffer);
			    }

		    strncpy(buffer,"\0",sizeof(buffer));
		    if (site_ok == MB_YES)
		    	nsite++;
		    }
		fclose(sfp);
		}
	    
	    /* add the sites */
	    if (nsite > 0)
	    	{
	    	status = mbview_addsites(verbose, instance,
			nsite, sitelon, sitelat, sitetopo, 
			sitecolor, sitesize, sitename,
			&error);

	    	/* update widgets */
	    	if (status == MB_SUCCESS)
	    	status = mbview_update(verbose, instance, &error);
		}
	    
	    /* deallocate memory */
	    if (nsite > 0)
	    	{
		status = mbview_freesitearrays(verbose, 
			&sitelon, &sitelat, &sitetopo,
			&sitecolor, &sitesize, &sitename, &error);
		}

	    }
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_savesite(int instance, char *output_file_ptr)
{
	char function_name[] = "do_mbgrdviz_savesite";
	int	status = MB_SUCCESS;
	FILE	*sfp;
	char	buffer[MB_PATH_MAXLINE];
	int	nsite;
	double	*sitelon;
	double	*sitelat;
	double	*sitetopo;
	int	*sitecolor;
	int	*sitesize;
	mb_path	*sitename;
	char	*result;
	char	*name;
	int	nget;
	int	site_ok;
	int	i;

	/* time, user, host variables */
	time_t	right_now;
	char	date[25], *user_ptr, host[MB_PATH_MAXLINE];
	char	*unknown = "Unknown";

	/* read data for valid instance */
	if (instance >= 0)
	    {

	    /* get the number of sites to be written to the outpuf file */
	    status = mbview_getsitecount(verbose, instance, &nsite, &error);
	    if (status == MB_SUCCESS && nsite <= 0)
	    	{
		fprintf(stderr,"Unable to write site file...\nCurrently %d sites defined for instance %d!\n",
			nsite, instance);
		XBell((Display *) XtDisplay(mainWindow),100);
		status = MB_FAILURE;
		}
	    
	    /* allocate arrays for sites */
	    if (status == MB_SUCCESS && nsite > 0)
		{
		/* allocate the arrays */
		sitelon = NULL;
		sitelat = NULL;
		sitetopo = NULL;
		sitecolor = NULL;
		sitesize = NULL;
		sitename = NULL;
		status = mbview_allocsitearrays(verbose, 
			nsite, &sitelon, &sitelat, &sitetopo,
			&sitecolor, &sitesize, &sitename, &error);

		/* if error initializing memory then cancel dealing with sites */
		if (status == MB_FAILURE)
	    		{
			nsite = 0;		    
			fprintf(stderr,"Unable to write site file...\nArray allocation for %d sites failed for instance %d!\n",
				nsite, instance);
			XBell((Display *) XtDisplay(mainWindow),100);
			}
		}
	    
	    /* get the sites */
	    if (status == MB_SUCCESS)
	    	{
	    	status = mbview_getsites(verbose, instance,
			&nsite, sitelon, sitelat, sitetopo, 
			sitecolor, sitesize, sitename,
			&error);
		}
		
	    /* write the sites to the output file */
	    if (status == MB_SUCCESS)
	    	{
		/* open the output file */
		if ((sfp = fopen(output_file_ptr, "w")) != NULL) 
			{
			/* write the site file header */
			fprintf(sfp, "## Site File Version %s\n", MBGRDVIZ_SITE_VERSION);
			fprintf(sfp, "## Output by Program %s\n",program_name); 
			fprintf(sfp, "## Program Version %s\n",rcs_id);
			fprintf(sfp, "## MB-System Version %s\n",MB_VERSION);
			strncpy(date,"\0",25);
			right_now = time((time_t *)0);
			strncpy(date,ctime(&right_now),24);
			if ((user_ptr = getenv("USER")) == NULL)
				if ((user_ptr = getenv("LOGNAME")) == NULL)
					user_ptr = unknown;
			gethostname(host,MB_PATH_MAXLINE);
			fprintf(sfp, "## Run by user <%s> on cpu <%s> at <%s>\n",
				user_ptr,host,date);
			fprintf(sfp, "## Number of sites: %d\n",nsite); 
			
			/* loop over the sites */
			for (i=0;i<nsite;i++)
				{
				fprintf(sfp,"%12.7f %12.7f %10.3f %2d %2d %s\n",
			 	   	sitelon[i], sitelat[i], sitetopo[i], 
			    		sitecolor[i], sitesize[i],
			    		sitename[i]);
				
				}

			/* close the output file */
			fclose(sfp);
			}
			
		/* output error message */
		else
			{
			error = MB_ERROR_OPEN_FAIL;
			fprintf(stderr,"\nUnable to Open Site File <%s> for writing\n",output_file_ptr);
			XBell((Display *) XtDisplay(mainWindow),100);
			status = MB_FAILURE;
			}
		}
	    
	    /* deallocate arrays for sites */
	    if (nsite > 0)
	    	{
		status = mbview_freesitearrays(verbose, 
			&sitelon, &sitelat, &sitetopo,
			&sitecolor, &sitesize, &sitename, &error);
		}

	    }
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_openroute(int instance, char *input_file_ptr)
{
	char function_name[] = "do_mbgrdviz_openroute";
	int	status = MB_SUCCESS;
	FILE	*sfp;
	char	buffer[MB_PATH_MAXLINE];
	int	npoint = 0;
	int	npointalloc = 0;
	double	*routelon = NULL;
	double	*routelat = NULL;
	double	lon, lat, topo;
	int	*routewaypoint = NULL;
	int	routecolor;
	int	routesize;
	mb_path	routename;
	int	iroute;
	int	waypoint;
	int	rawroutefile = MB_YES;
	char	*result;
	char	*name;
	int	nget;
	int	point_ok;
	int	i;

	/* read data for valid instance */
	if (instance >= 0)
	    {
	    /* initialize route values */
	    routecolor = MBV_COLOR_BLUE;
	    routesize = 1;
	    routename[0] = '\0';
	    rawroutefile = MB_YES;
	    npoint = 0;
	    npointalloc = 0;
	    
	    /* open the input file */
	    if ((sfp = fopen(input_file_ptr, "r")) == NULL) 
		    {
		    error = MB_ERROR_OPEN_FAIL;
		    status == MB_FAILURE;
		    fprintf(stderr,"\nUnable to open route file <%s> for reading\n",input_file_ptr);
		    XBell((Display *) XtDisplay(mainWindow),100);
		    }

	    /* loop over reading */
	    if (status == MB_SUCCESS)
	    	{
		while ((result = fgets(buffer,MB_PATH_MAXLINE,sfp)) == buffer)
		    {
		    /* deal with comments */
		    if (buffer[0] == '#')
		    	{
			if (rawroutefile == MB_YES
				&& strncmp(buffer,"## Route File Version", 21) == 0)
				rawroutefile = MB_NO;
			else if (strncmp(buffer,"## ROUTENAME", 12) == 0)
				sscanf(buffer,"## ROUTENAME %[^\n]", routename);
			else if (strncmp(buffer,"## ROUTECOLOR", 12) == 0)
				sscanf(buffer,"## ROUTENAME %d", &routecolor);
			else if (strncmp(buffer,"## ROUTESIZE", 12) == 0)
				sscanf(buffer,"## ROUTENAME %d", &routesize);
			}
		
		    /* deal with route segment marker */
		    else if (buffer[0] == '>')
		    	{
			/* if data accumulated call mbview_addroute() */
			if (npoint > 0)
			    {
			    status = mbview_addroute(verbose, instance,
			    				npoint, routelon, routelat, routewaypoint,
							routecolor, routesize, routename,
							&iroute, &error);
			    npoint = 0;
			    }
			}
			
		    /* deal with data */
		    else
		        {
			/* read the data from the buffer */
			nget = sscanf(buffer,"%lf %lf %lf %d",
			    &lon, &lat, &topo, &waypoint);
		    	if ((rawroutefile == MB_YES && nget >= 2)
				|| (rawroutefile == MB_NO && nget >= 3 && waypoint > MBV_ROUTE_WAYPOINT_NONE))
			    point_ok = MB_YES;
			else
			    point_ok = MB_NO;
			    
			/* if good data check for need to allocate more space */
			if (point_ok == MB_YES
				&& npoint + 1 > npointalloc)
			    {
			    npointalloc += MBV_ALLOC_NUM;
			    status = mbview_allocroutearrays(verbose, 
						    npointalloc,
						    &routelon,
						    &routelat,
						    &routewaypoint,
						    NULL,
						    NULL,
						    NULL,
						    NULL,
						    NULL,
						    &error);
			    if (status != MB_SUCCESS)
				    {
				    npointalloc = 0;
				    }
			    }
			    
			/* add good point to route */
			if (point_ok == MB_YES && npointalloc > npoint + 1)
			    {
			    routelon[npoint] = lon;
			    routelat[npoint] = lat;
			    routewaypoint[npoint] = waypoint;
			    npoint++;
			    }
			}
		    }
		    
		/* add last route if not already handled */
		if (npoint > 0)
		    {
		    status = mbview_addroute(verbose, instance,
			    			npoint, routelon, routelat, routewaypoint,
						routecolor, routesize, routename,
						&iroute, &error);
		    npoint = 0;
		    }
		    
		/* free the memory */
		if (npointalloc > 0)
		status = mbview_freeroutearrays(verbose, 
						    &routelon,
						    &routelat,
						    &routewaypoint,
						    NULL,
						    NULL,
						    NULL,
						    NULL,
						    NULL,
						    &error);

		/* close the input file */
		fclose(sfp);
		}

	    /* update widgets */
	    if (status == MB_SUCCESS)
	    status = mbview_update(verbose, instance, &error);
	    }
			
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_saveroute(int instance, char *output_file_ptr)
{
	char function_name[] = "do_mbgrdviz_saveroute";
	int	status = MB_SUCCESS;
	FILE	*sfp;
	char	buffer[MB_PATH_MAXLINE];
	int	nroute = 0;
	int	npoint = 0;
	int	nintpoint = 0;
	int	npointtotal = 0;
	int	npointalloc = 0;
	double	*routelon = NULL;
	double	*routelat = NULL;
	int	*routewaypoint = NULL;
	double	*routetopo = NULL;
	double	*routebearing = NULL;
	double	*distlateral = NULL;
	double	*distovertopo = NULL;
	double	*slope = NULL;
	int	routecolor;
	int	routesize;
	mb_path	routename;
	int	iroute, j;

	/* time, user, host variables */
	time_t	right_now;
	char	date[25], *user_ptr, host[MB_PATH_MAXLINE];
	char	*unknown = "Unknown";

	/* read data for valid instance */
	if (instance >= 0)
	    {

	    /* get the number of routes to be written to the outpuf file */
	    status = mbview_getroutecount(verbose, instance, &nroute, &error);
	    if (nroute <= 0)
	    	{
		fprintf(stderr,"Unable to write route file...\nCurrently %d routes defined for instance %d!\n",
			nroute, instance);
		XBell((Display *) XtDisplay(mainWindow),100);
		status = MB_FAILURE;
		}
		
	    /* initialize the output file */
	    if (status == MB_SUCCESS && nroute > 0)
	    	{
		/* open the output file */
		if ((sfp = fopen(output_file_ptr, "w")) != NULL) 
			{
			/* write the route file header */
			fprintf(sfp, "## Route File Version %s\n", MBGRDVIZ_ROUTE_VERSION);
			fprintf(sfp, "## Output by Program %s\n",program_name); 
			fprintf(sfp, "## Program Version %s\n",rcs_id);
			fprintf(sfp, "## MB-System Version %s\n",MB_VERSION);
			strncpy(date,"\0",25);
			right_now = time((time_t *)0);
			strncpy(date,ctime(&right_now),24);
			if ((user_ptr = getenv("USER")) == NULL)
				if ((user_ptr = getenv("LOGNAME")) == NULL)
					user_ptr = unknown;
			gethostname(host,MB_PATH_MAXLINE);
			fprintf(sfp, "## Run by user <%s> on cpu <%s> at <%s>\n",
				user_ptr,host,date);
			fprintf(sfp, "## Number of routes: %d\n",nroute); 
			fprintf(sfp, "## Route point format:\n"); 
			fprintf(sfp, "##   <longitude (deg)> <latitude (deg)> <waypoint (boolean)> <topography (m)> <bearing (deg)> <lateral distance (m)> <distance along topography (m)> <slope (m/m)>\n"); 
			}
			
		/* output error message */
		else
			{
			error = MB_ERROR_OPEN_FAIL;
			status = MB_FAILURE;
			fprintf(stderr,"\nUnable to Open route file <%s> for writing\n",output_file_ptr);
			XBell((Display *) XtDisplay(mainWindow),100);
			}
		}
	    
	    /* if all ok proceed to extract and output routes */
	    if (status == MB_SUCCESS)
	    	{
	        /* loop over routes */
		for (iroute=0;iroute<nroute;iroute++)
	    	    {
		    /* get point count for current route */
		    status = mbview_getroutepointcount(verbose, instance,
			    iroute, &npoint, &nintpoint, &error);

		    /* allocate route arrays */
		    npointtotal = npoint + nintpoint;
		    if (status == MB_SUCCESS
			    && npointalloc < npointtotal)
			    {
			    status = mbview_allocroutearrays(verbose, 
						    npointtotal,
						    &routelon,
						    &routelat,
						    &routewaypoint,
						    &routetopo,
						    &routebearing,
						    &distlateral,
						    &distovertopo,
						    &slope,
						    &error);
			    if (status == MB_SUCCESS)
				    {
				    npointalloc = npointtotal;
				    }

			    /* if error initializing memory then cancel dealing with this route */
			    else
	    			    {
				    fprintf(stderr,"Unable to write route...\nArray allocation for %d points failed for instance %d!\n",
					    npointtotal, instance);
				    XBell((Display *) XtDisplay(mainWindow),100);
				    npoint = 0;		    
				    nintpoint = 0;		    
				    npointtotal = 0;		    
				    }
			    }

		    /* extract data for route */
		    status = mbview_getroute(verbose, instance,
					    iroute,
					    &npointtotal,
					    routelon,
					    routelat,
					    routewaypoint,
					    routetopo,
					    routebearing,
					    distlateral,
					    distovertopo,
					    slope,
					    &routecolor,
					    &routesize,
					    routename,
					    &error);

		    /* write the route header */
		    fprintf(sfp,"## ROUTENAME %s\n", routename);
		    fprintf(sfp,"## ROUTESIZE %d\n", routesize);
		    fprintf(sfp,"## ROUTECOLOR %d\n", routecolor);
		    fprintf(sfp,"## ROUTEPOINTS %d\n", npointtotal);
		    fprintf(sfp,"> ## STARTROUTE\n");

		    /* write the route points */
		    for (j=0;j<npointtotal;j++)
			    {
			    fprintf(sfp,"%f %f %f %d %f %f %f %f",
				    routelon[j], routelat[j], 
				    routetopo[j],
				    routewaypoint[j], routebearing[j],
				    distlateral[j], distovertopo[j], slope[j]);
			    if (routewaypoint[j] == MBV_ROUTE_WAYPOINT_SIMPLE)
			    	fprintf(sfp," ## WAYPOINT\n");
			    else if (routewaypoint[j] == MBV_ROUTE_WAYPOINT_TRANSIT)
			    	fprintf(sfp," ## WAYPOINT TRANSIT\n");
			    else if (routewaypoint[j] == MBV_ROUTE_WAYPOINT_STARTLINE)
			    	fprintf(sfp," ## WAYPOINT STARTLINE\n");
			    else if (routewaypoint[j] == MBV_ROUTE_WAYPOINT_ENDLINE)
			    	fprintf(sfp," ## WAYPOINT ENDLINE\n");
			    else
			    	fprintf(sfp,"\n");
			    }

		    /* write the route end */
		    fprintf(sfp,"> ## ENDROUTE\n");
		    }

		/* close the output file */
		fclose(sfp);

		/* deallocate arrays */
		if (npointalloc > 0)
	    	    {
		    status = mbview_freeroutearrays(verbose, 
					    &routelon,
					    &routelat,
					    &routewaypoint,
					    &routetopo,
					    &routebearing,
					    &distlateral,
					    &distovertopo,
					    &slope,
					    &error);
		    }
		}
	    }
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_opennav(int instance, int swathbounds, char *input_file_ptr)
{
	char function_name[] = "do_mbgrdviz_opennav";
	int	status = MB_SUCCESS;
	void	*datalist;
	mb_path	swathfile;
	int	format;
	double	weight;
	int	done;
	mb_path	messagestr;
	char	*lastslash;

	/* read data for valid instance */
	if (instance >= 0)
	    {
	    done = MB_NO;
	    while (done == MB_NO)
		{
		if (status = mb_datalist_open(verbose,&datalist,
						input_file_ptr,
						MB_DATALIST_LOOK_UNSET,&error) == MB_SUCCESS)
			{
			while (done == MB_NO)
				{
				if (status = mb_datalist_read(verbose,datalist,
						swathfile,&format,&weight,&error)
						== MB_SUCCESS
					&& format != MBF_ASCIIXYZ
					&& format != MBF_ASCIIYXZ
					&& format != MBF_ASCIIXYT
					&& format != MBF_ASCIIYXT)
					{
					/* check for available nav file if that is
					   all that is needed */
					if (swathbounds == MB_NO)
						mb_get_fnv(verbose, swathfile, &format, &error);

					/* else check for available fbt file  */
					else
						mb_get_fbt(verbose, swathfile, &format, &error);

					/* read the swath or nav data using mbio calls */

					/* update message */
					if (swathbounds == MB_NO)
						strcpy(messagestr, "Reading navigation: ");
					else
						strcpy(messagestr, "Reading swath data: ");
					lastslash = strrchr(swathfile, '/');
					if ((lastslash = strrchr(swathfile, '/')) != NULL)
						strcat(messagestr,&(lastslash[1]));
					else
						strcat(messagestr,swathfile);
					do_mbview_message_on(messagestr, instance);
fprintf(stderr,"%s\n",messagestr);

					/* read the data */
					do_mbgrdviz_readnav(instance, swathfile, 
								format, weight, &error);
					}
				else
					{
					mb_datalist_close(verbose,&datalist,&error);
					done = MB_YES;
					}
				}
			}
		}

	    /* update widgets */
	    mbview_enableviewnavs(verbose, instance, &error);
	    status = mbview_update(verbose, instance, &error);
	    }
			
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_readnav(int instance, char *swathfile, int format, double weight, int *error)
{
	char function_name[] = "do_mbgrdviz_readnav";
	int	status = MB_SUCCESS;
	char	*error_message;

	/* MBIO control parameters */
	int	pings = 1;
	int	lonflip;
	double	bounds[4];
	int	btime_i[7];
	int	etime_i[7];
	double	btime_d;
	double	etime_d;
	double	speedmin;
	double	timegap;
	int	beams_bath;
	int	beams_amp;
	int	pixels_ss;
	void	*mbio_ptr = NULL;

	/* mbio read and write values */
	void	*store_ptr = NULL;
	int	kind;
	int	time_i[7];
	double	time_d;
	double	lon;
	double	lat;
	double	speed;
	double	heading;
	double	distance;
	double	altitude;
	double	sonardepth;
	double	draft;
	double	roll;
	double	pitch;
	double	heave;
	int	nbath;
	int	namp;
	int	nss;
	char	*beamflag = NULL;
	double	*bath = NULL;
	double	*bathacrosstrack = NULL;
	double	*bathalongtrack = NULL;
	double	*amp = NULL;
	double	*ss = NULL;
	double	*ssacrosstrack = NULL;
	double	*ssalongtrack = NULL;
	char	comment[256];

	int	npoint;
	int	npointalloc;
	double	*navtime_d = NULL;
	double	*navlon = NULL;
	double	*navlat = NULL;
	double	*navz = NULL;
	double	*navheading = NULL;
	double	*navspeed = NULL;
	double	*navportlon = NULL;
	double	*navportlat = NULL;
	double	*navstbdlon = NULL;
	double	*navstbdlat = NULL;
	int	*navcdp = NULL;
	int	*navshot = NULL;
	int	color;
	int	size;
	mb_path	name;
	int	swathbounds;
	int	shot;
	int	cdp;

	struct mbview_struct *data;
	
	double	mtodeglon, mtodeglat;
	double	headingx, headingy;
	double	xd, yd, zd;

	int	form;
	int	icenter, iport, istbd;
	double	centerdistance, portdistance, stbddistance;
	char	*lastslash;
	int	i;
	
	*error = MB_ERROR_NO_ERROR;

	/* initialize nav values */
	color = MBV_COLOR_BLACK;
	size = 2;
	name[0] = '\0'; 
	lastslash = strrchr(swathfile, '/');
	if ((lastslash = strrchr(swathfile, '/')) != NULL)
		strcpy(name,&(lastslash[1]));
	else
		strcpy(name,swathfile);

	swathbounds = MB_NO;
	shot = MB_NO;
	cdp = MB_NO;
	npoint = 0;
	npointalloc = 0;

	/* set mbio default values */
	status = mb_defaults(verbose,&form,&pings,&lonflip,bounds,
		btime_i,etime_i,&speedmin,&timegap);

	/* get data structure of current instance */
	status = mbview_getdataptr(verbose, instance, &data, error);
	if (status == MB_SUCCESS)
		{
		bounds[0] = data->primary_xmin;
		bounds[1] = data->primary_xmax;
		bounds[2] = data->primary_ymin;
		bounds[3] = data->primary_ymax;
		status = mbview_projectforward(instance, MB_YES,
				data->primary_xmin, data->primary_ymin,
				0.5 * (data->primary_min + data->primary_max),
				&bounds[0], &bounds[2],
				&xd, &yd, &zd);
		status = mbview_projectforward(instance, MB_YES,
				data->primary_xmax, data->primary_ymax,
				0.5 * (data->primary_min + data->primary_max),
				&bounds[1], &bounds[3],
				&xd, &yd, &zd);
		}

	/* rationalize bounds and lonflip */
	if (bounds[1] > 180.0)
		{
		lonflip = 1;
		}
	else if (bounds[0] < -180.0)
		{
		lonflip = -1;
		}
	else
		{
		lonflip = 0;
		}
	
	/* initialize reading the swath file */
	if ((status = mb_read_init(
		verbose,swathfile,format,pings,lonflip,bounds,
		btime_i,etime_i,speedmin,timegap,
		&mbio_ptr,&btime_d,&etime_d,
		&beams_bath,&beams_amp,&pixels_ss,error)) != MB_SUCCESS)
		{
		mb_error(verbose,*error,&error_message);
		fprintf(stderr,"\nMBIO Error returned from function <mb_read_init>:\n%s\n",error_message);
		fprintf(stderr,"\nSwath sonar File <%s> not initialized for reading\n",swathfile);
		}

	/* allocate memory for data arrays */
	if (status == MB_SUCCESS)
		{
		status = mb_malloc(verbose,beams_bath*sizeof(char),
					&beamflag,error);
		if (status == MB_SUCCESS)
			status = mb_malloc(verbose,beams_bath*sizeof(double),
						&bath,error);
		if (status == MB_SUCCESS)
			status = mb_malloc(verbose,beams_bath*sizeof(double),
						&bathacrosstrack,error);
		if (status == MB_SUCCESS)
			status = mb_malloc(verbose,beams_bath*sizeof(double),
						&bathalongtrack,error);
		if (status == MB_SUCCESS)
			status = mb_malloc(verbose,beams_amp*sizeof(double),
						&amp,error);
		if (status == MB_SUCCESS)
			status = mb_malloc(verbose,pixels_ss*sizeof(double),
						&ss,error);
		if (status == MB_SUCCESS)
			status = mb_malloc(verbose,pixels_ss*sizeof(double),
						&ssacrosstrack,error);
		if (status == MB_SUCCESS)
			status = mb_malloc(verbose,pixels_ss*sizeof(double),
						&ssalongtrack,error);

		/* if error initializing memory then don't read the file */
		if (*error != MB_ERROR_NO_ERROR)
			{
			mb_error(verbose,*error,&error_message);
			fprintf(stderr,"\nMBIO Error allocating data arrays:\n%s\n",
				error_message);
			}
 		}


	/* read data */
	if (status == MB_SUCCESS)
		{
		/* set swathbounds true if nore than one beam is expected */
		if (beams_bath > 1)
			swathbounds = MB_YES;
		
		/* loop over successful reads and nonfatal errors 
		   until a fatal error is encountered */
		while (*error <= MB_ERROR_NO_ERROR)
			{
			/* read a ping of data */
			status = mb_get_all(verbose,mbio_ptr,&store_ptr,&kind,
				time_i,&time_d,&lon,&lat,&speed,
				&heading,&distance,&altitude,&sonardepth,
				&beams_bath,&beams_amp,&pixels_ss,
				beamflag,bath,amp,bathacrosstrack,bathalongtrack,
				ss,ssacrosstrack,ssalongtrack,
				comment,error);
				
			/* ignore minor errors */
			if (kind == MB_DATA_DATA
				&& (*error == MB_ERROR_TIME_GAP
					|| *error == MB_ERROR_OUT_TIME
					|| *error == MB_ERROR_SPEED_TOO_SMALL))
				{
				status = MB_SUCCESS;
				*error = MB_ERROR_NO_ERROR;
				}
				
			if (kind == MB_DATA_DATA 
				&& *error == MB_ERROR_NO_ERROR)
				{
/*fprintf(stderr,"Ping %d: %4d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d.%.6.6d %f %f\n",
npoint,time_i[0],time_i[1],time_i[2],time_i[3],time_i[4],time_i[5],time_i[6],lon,lat);*/

				/* allocate memory if required */
				if (npoint >= npointalloc)
					{
					npointalloc += MBV_ALLOC_NUM;
					status = mb_realloc(verbose,npointalloc*sizeof(double),
								&navtime_d,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navlon,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navlat,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navz,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navheading,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navspeed,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navportlon,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navportlat,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navstbdlon,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(double),
									&navstbdlat,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(int),
									&navcdp,error);
					if (status == MB_SUCCESS)
						status = mb_realloc(verbose,npointalloc*sizeof(int),
									&navshot,error);

					/* if error initializing memory then don't read the file */
					if (*error != MB_ERROR_NO_ERROR)
						{
						npointalloc = 0;
						mb_error(verbose,*error,&error_message);
						fprintf(stderr,"\nMBIO Error allocating navigation data arrays:\n%s\n",
							error_message);
						}
					}
					
				/* find centermost beam */
				icenter = -1;
				iport = -1;
				istbd = -1;
				centerdistance = 0.0;
				portdistance = 0.0;
				stbddistance = 0.0;
				for (i=0;i<beams_bath;i++)
					{
					if (mb_beam_ok(beamflag[i]))
						{
						if (icenter == -1
							|| fabs(bathacrosstrack[i]) < centerdistance)
							{
							icenter = i;
							centerdistance = bathacrosstrack[i];
							}
						if (iport == -1
							|| bathacrosstrack[i] < portdistance)
							{
							iport = i;
							portdistance = bathacrosstrack[i];
							}
						if (istbd == -1
							|| bathacrosstrack[i] > stbddistance)
							{
							istbd = i;
							stbddistance = bathacrosstrack[i];
							}
						}
					}
					
				/* store the navigation values */
				navtime_d[npoint] = time_d;
				navlon[npoint] = lon;
				navlat[npoint] = lat;
				navz[npoint] = -sonardepth;
				navheading[npoint] = heading;
				navspeed[npoint] = speed;

				mb_coor_scale(verbose,lat,&mtodeglon,&mtodeglat);
				headingx = sin(heading * DTR);
				headingy = cos(heading * DTR);
				if (icenter >= 0)
					{
					navportlon[npoint] = lon 
						+ headingy * mtodeglon * bathacrosstrack[iport]
						+ headingx * mtodeglon * bathalongtrack[iport];
					navportlat[npoint] = lat 
						- headingx * mtodeglat * bathacrosstrack[iport]
						+ headingy * mtodeglat * bathalongtrack[iport];
					navstbdlon[npoint] = lon 
						+ headingy * mtodeglon * bathacrosstrack[istbd]
						+ headingx * mtodeglon * bathalongtrack[istbd];
					navstbdlat[npoint] = lat 
						- headingx * mtodeglat * bathacrosstrack[istbd]
						+ headingy * mtodeglat * bathalongtrack[istbd];
					}
				else
					{
					navportlon[npoint] = lon;
					navportlat[npoint] = lat;
					navstbdlon[npoint] = lon;
					navstbdlat[npoint] = lat;
					}
				
				
				navcdp[npoint] = 0;
				navshot[npoint] = 0;
				
				/* increment npoint */
				npoint++;
				}
			}
	
		/* close the swath file */
		status = mb_close(verbose,&mbio_ptr,error);
		
		/* insert nav data to mbview */
		if (npoint > 0)
		status = mbview_addnav(verbose, instance,
				npoint,
				navtime_d,
				navlon,
				navlat,
				navz,
				navheading,
				navspeed,
				navportlon,
				navportlat,
				navstbdlon,
				navstbdlat,
				navcdp,
				navshot,
				color,
				size,
				name,
				swathbounds,
				shot,
				cdp,
				error);

		/* deallocate memory used for data arrays */
		mb_free(verbose,&beamflag,error);
		mb_free(verbose,&bath,error);
		mb_free(verbose,&bathacrosstrack,error);
		mb_free(verbose,&bathalongtrack,error);
		mb_free(verbose,&amp,error);
		mb_free(verbose,&ss,error);
		mb_free(verbose,&ssacrosstrack,error);
		mb_free(verbose,&ssalongtrack,error);

		mb_free(verbose,&navtime_d,error);
		mb_free(verbose,&navlon,error);
		mb_free(verbose,&navlat,error);
		mb_free(verbose,&navz,error);
		mb_free(verbose,&navheading,error);
		mb_free(verbose,&navspeed,error);
		mb_free(verbose,&navportlon,error);
		mb_free(verbose,&navportlat,error);
		mb_free(verbose,&navstbdlon,error);
		mb_free(verbose,&navstbdlat,error);
		mb_free(verbose,&navcdp,error);
		mb_free(verbose,&navshot,error);
		}
			
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_readgrd(int instance, char *grdfile,
			int	*grid_projection_mode,
			char	*grid_projection_id,
			float	*nodatavalue,
			int	*nxy,
			int	*nx,
			int	*ny,
			double	*min,
			double	*max,
			double	*xmin,
			double	*xmax,
			double	*ymin,
			double	*ymax,
			double	*dx,
			double	*dy,
			float	**data)
{
	char function_name[] = "do_mbgrdviz_readgrd";
	int	status = MB_SUCCESS;
	struct GRD_HEADER header;
	int	modeltype;
	int	projectionid;
        char    projectionname[MB_PATH_MAXLINE];
	int	off;
	int	pad[4];
	int	nscan;
	int	utmzone;
        float   NaN;
	char	NorS;
	char	*projection = "-Jx1.0";
	float	*rawdata;
	float	*usedata;
	int	i,j,k,kk;
	
	GMT_begin (pargc, pargv);
	GMT_put_history(pargc, pargv);
	GMT_get_common_args (projection, xmin, xmax, ymin, ymax);
	GMT_grd_init (&header, pargc, pargv, FALSE);
	GMT_make_fnan (GMT_f_NaN);
	GMT_make_dnan (GMT_d_NaN);
	
	/* read input grd file header */
	if (GMT_read_grd_info (grdfile, &header)) 
	    {
	    error = MB_ERROR_OPEN_FAIL;
	    fprintf(stderr,"\nUnable to open grd file: %s\n",
		    grdfile);
	    fprintf(stderr,"\nProgram <%s> Terminated\n",
	    		program_name);
	    exit(error);
	    }

	/* set up internal arrays */
    	*nodatavalue = MIN(MBV_DEFAULT_NODATA, header.z_min - 10 * (header.z_max - header.z_min));
    	*nxy = header.nx * header.ny;
    	*nx = header.nx;
    	*ny = header.ny;
    	*xmin = header.x_min; 
    	*xmax = header.x_max; 
    	*ymin = header.y_min; 
    	*ymax = header.y_max; 
    	*dx = header.x_inc;
    	*dy = header.y_inc;
    	*min = header.z_min; 
    	*max = header.z_max; 

    	status = mb_malloc(verbose, sizeof(float) * (*nxy), 
    				&rawdata,
				&error);
    	if (status == MB_SUCCESS)
	status = mb_malloc(verbose, sizeof(float) * (*nxy), 
    				&usedata,
				&error);
	*data = usedata;
	if (status != MB_SUCCESS)
	    {
	    fprintf(stderr,"\nUnable to allocate memory to store data from grd file: %s\n",
		    grdfile);
	    fprintf(stderr,"\nProgram <%s> Terminated\n",
		    program_name);
	    exit(error);
	    }

	/* Determine the wesn to be used to read the grdfile */
	off = (header.node_offset) ? 0 : 1;
	GMT_map_setup (*xmin, *xmax, *ymin, *ymax);
	GMT_grd_setregion (&header, xmin,  xmax, ymin, ymax);

	/* read the grid */
	pad[0] = 0;
	pad[1] = 0;
	pad[2] = 0;
	pad[3] = 0;
	if (GMT_read_grd (grdfile, &header, rawdata, 
			    *xmin, *xmax, *ymin, *ymax, 
			    pad, FALSE))
	    {
	    error = MB_ERROR_OPEN_FAIL;
	    fprintf(stderr,"\nUnable to read grd file: %s\n",
		    grdfile);
	    fprintf(stderr,"\nProgram <%s> Terminated\n",
		    program_name);
	    exit(error);
	    }
	    
	/* reorder grid to internal convention */
	for (i=0;i<*nx;i++)
	for (j=0;j<*ny;j++)
		{
		k = i * *ny + j;
		kk = (*ny - 1 - j) * *nx + i;
		if (check_fnan(rawdata[kk]))
			usedata[k] = *nodatavalue;
		else
			usedata[k] = rawdata[kk];
		}
	mb_free(verbose, &rawdata, &error);
	    
	/* try to get projection from the grd file remark */
	if (strncmp(&(header.remark[2]), "Projection: ", 12) == 0)
		{
		if ((nscan = sscanf(&(header.remark[2]), "Projection: UTM%d%c", &utmzone, &NorS)) == 2)
			{
			if (NorS == 'N')
				{
				projectionid = 32600 + utmzone;
				}
			else if (NorS == 'S')
				{
				projectionid = 32700 + utmzone;
				}
				modeltype = ModelTypeProjected;
			sprintf(projectionname, "UTM%2.2d%c", utmzone, NorS);
			*grid_projection_mode = MBV_PROJECTION_PROJECTED;
			sprintf(grid_projection_id, "epsg%d", projectionid);
			}
		else if ((nscan = sscanf(&(header.remark[2]), "Projection: epsg%d", &projectionid)) == 1)
			{
			sprintf(projectionname, "epsg%d", projectionid);
			modeltype = ModelTypeProjected;
			*grid_projection_mode = MBV_PROJECTION_PROJECTED;
			sprintf(grid_projection_id, "epsg%d", projectionid);
			}
		else
			{
			strcpy(projectionname, "Geographic WGS84");
			modeltype = ModelTypeGeographic;
			projectionid = GCS_WGS_84;
			*grid_projection_mode = MBV_PROJECTION_GEOGRAPHIC;
			sprintf(grid_projection_id, "epsg%d", projectionid);
			}
		}
	else
		{
		strcpy(projectionname, "Geographic WGS84");
		modeltype = ModelTypeGeographic;
		projectionid = GCS_WGS_84;
		*grid_projection_mode = MBV_PROJECTION_GEOGRAPHIC;
		sprintf(grid_projection_id, "epsg%d", projectionid);
		}	

	/* print debug info */
	if (verbose > 0)
	    {
	    fprintf(stderr,"Grid read:\n");
	    fprintf(stderr,"  Dimensions: %d %d\n", header.nx, header.ny);
	    if (modeltype == ModelTypeProjected)
	    	{
		fprintf(stderr,"  Projected Coordinate System Name: %s\n", projectionname);
		fprintf(stderr,"  Projected Coordinate System ID:   %d\n", projectionid);
	    	fprintf(stderr,"  Easting:    %f %f  %f\n",
		  	header.x_min, header.x_max, header.x_inc);
	    	fprintf(stderr,"  Northing:   %f %f  %f\n",
		  	header.y_min, header.y_max, header.y_inc);
		}
	    else
		{
		fprintf(stderr,"  Geographic Coordinate System Name: %s\n", projectionname);
		fprintf(stderr,"  Geographic Coordinate System ID:   %d\n", projectionid);
	    	fprintf(stderr,"  Longitude:  %f %f  %f\n",
		  	header.x_min, header.x_max, header.x_inc);
	    	fprintf(stderr,"  Latitude:   %f %f  %f\n",
		  	header.y_min, header.y_max, header.y_inc);
		}
	    fprintf(stderr,"  Internal Grid Projection Mode:         %d\n", 
	    			*grid_projection_mode);
	    fprintf(stderr,"  Internal Grid Projection ID:           %s\n", 
	    			grid_projection_id);

	    fprintf(stderr,"Data Read:\n");
	    fprintf(stderr,"  grid_projection_mode:     %d\n", *grid_projection_mode);
	    fprintf(stderr,"  grid_projection_id:       %s\n", grid_projection_id);
	    fprintf(stderr,"  nodatavalue:              %f\n", *nodatavalue);
	    fprintf(stderr,"  nx:                       %d\n", *nx);
	    fprintf(stderr,"  ny:                       %d\n", *ny);
	    fprintf(stderr,"  min:                      %f\n", *min);
	    fprintf(stderr,"  max:                      %f\n", *max);
	    fprintf(stderr,"  xmin:                     %f\n", *xmin);
	    fprintf(stderr,"  xmax:                     %f\n", *xmax);
	    fprintf(stderr,"  ymin:                     %f\n", *ymin);
	    fprintf(stderr,"  ymax:                     %f\n", *ymax);
	    fprintf(stderr,"  dx:                       %f\n", *dx);
	    fprintf(stderr,"  dy:                       %f\n", *dy);
	    fprintf(stderr,"  data:                     %d\n", *data);
	    }

	return(status);
}
/*---------------------------------------------------------------------------------------*/

int do_mbgrdviz_opentest(int instance, 
			double	factor1, 
			double	factor2, 
			double	factor3, 
			int	*grid_projection_mode,
			char	*grid_projection_id,
			float	*nodatavalue,
			int	*nxy,
			int	*nx,
			int	*ny,
			double	*min,
			double	*max,
			double	*xmin,
			double	*xmax,
			double	*ymin,
			double	*ymax,
			double	*dx,
			double	*dy,
			float	**data)
{
	char function_name[] = "do_mbgrdviz_opentest";
	int	status = MB_SUCCESS;
	double	xx, yy;
	float	*usedata;
	int	i, j, k;

	*grid_projection_mode = MBV_PROJECTION_GEOGRAPHIC;
	sprintf(grid_projection_id, "epsg%d", GCS_WGS_84);
    	*nodatavalue = MBV_DEFAULT_NODATA;
    	*nx = 501;
    	*ny = 501;
    	*nxy = *nx * *ny;
    	*xmin = -1.0;
    	*xmax = 1.0;
    	*ymin = -1.0;
    	*ymax = 1.0;
    	*dx = (*xmax - *xmin) / (*nx -1);
    	*dy = (*ymax - *ymin) / (*ny -1);
    	*min = 0.0;
    	*max = 1000.0;
    	*min = 0.0;
    	*max = 0.0;

    	if (status == MB_SUCCESS)
    	status = mb_malloc(verbose, sizeof(float) * *nxy, 
    				data,
				&error);
	usedata = *data;
	if (status != MB_SUCCESS)
	    {
	    fprintf(stderr,"\nUnable to allocate memory to store test data...\n");
	    fprintf(stderr,"\nProgram <%s> Terminated\n",
		    program_name);
	    exit(error);
	    }

	for (i=0;i<*nx;i++)
		for (j=0;j<*ny;j++)
			{
			k = i * *ny + j;
			xx = *xmin + i * *dx;
			yy = *ymin + j * *dy;
			usedata[k] = factor1 * sin(factor2 * M_PI * xx) 
							* sin(factor2 * M_PI * yy)
							* exp(-factor3 * xx * yy);
    			*min = MIN(*min, usedata[k]);
    			*max = MAX(*max, usedata[k]);
			}
	
	return(status);
}
/*---------------------------------------------------------------------------------------*/

void do_mbgrdviz_open_region( Widget w, XtPointer client_data, XtPointer call_data)
{
	char function_name[] = "do_mbgrdviz_open_region";
	int	status = MB_SUCCESS;
	int	projectionid, utmzone;
	double	reference_lon;
        Cardinal ac = 0;
        Arg      args[256];
        Cardinal cdc = 0;
        Boolean  argok = False;
        XmString    tmp0;
	int	actionid;
	double	xx, yy;
	int	ixmin, ixmax, jymin, jymax;
	int	i, j, k, ksource;
	
	/* existing mbview instance */
	int	instance_source;
	struct mbview_struct *data_source;
	char	button_name_source[MB_PATH_MAXLINE];
	
	/* new mbview instance */
	int	instance;
	char	button_name[MB_PATH_MAXLINE];
	
	/* mbview parameters */
	int 	(*mbview_dismiss_notify)(int id);
	char	mbv_title[MB_PATH_MAXLINE];
	int	mbv_xo;
	int	mbv_yo;
	int	mbv_width;
	int	mbv_height;
	int	mbv_lorez_dimension;
	int	mbv_hirez_dimension;
	int	mbv_lorez_navdecimate;
	int	mbv_hirez_navdecimate;
	int	mbv_primary_nxy;
	int	mbv_primary_nx;
	int	mbv_primary_ny;
	double	mbv_primary_min;
	double	mbv_primary_max;
	double	mbv_primary_xmin;
	double	mbv_primary_xmax;
	double	mbv_primary_ymin;
	double	mbv_primary_ymax;
	double	mbv_primary_dx;
	double	mbv_primary_dy;
	float	*mbv_primary_data;
   
    	/* get source mbview instance */
	instance_source = (int) client_data;
fprintf(stderr,"Called do_mbgrdviz_open_region instance:%d\n", instance_source);

	/* get new instance number */
	if (instance_source >= 0 && instance_source < MBV_MAX_WINDOWS)
		{
		status = mbview_init(verbose, &instance, &error);
		if (instance < 0)
			{
			fprintf(stderr, "Unable to create mbview - %d mbview windows already created\n", 
			MBV_MAX_WINDOWS);
			status = MB_FAILURE;
			}
		}
	else
		{
		status = MB_FAILURE;
		}
	    
    	/* check data source for region to extract */
	if (status == MB_SUCCESS)
		{
		/* get source data */
		mbview_getdataptr(verbose, instance_source, &data_source, &error);
					
		/* extract the grid from the source */
		if (data_source->region_type != MBV_REGION_QUAD)
			status = MB_FAILURE;
		}
	    
    	/* extract data from source and create new mbview instance */
	if (status == MB_SUCCESS)
		{
		/* get source data */
		mbview_getdataptr(verbose, instance_source, &data_source, &error);

		/* get button name */
		sscanf(data_source->title,"MBgrdviz: %s", button_name_source);
		sprintf(button_name,"Region from %s", button_name_source);

		/* set parameters */
		sprintf(mbv_title, "MBgrdviz: %s\n", button_name);
		mbv_xo = 200;
		mbv_yo = 200;
		mbv_width = 560;
		mbv_height = 500;
		mbv_lorez_dimension = data_source->lorez_dimension;
		mbv_hirez_dimension = data_source->hirez_dimension;
		mbv_lorez_navdecimate = data_source->lorez_navdecimate;
		mbv_hirez_navdecimate = data_source->hirez_navdecimate;

		/* set basic mbview window parameters */
		status = mbview_setwindowparms(verbose, instance,
					&do_mbgrdviz_dismiss_notify,
					mbv_title,
					mbv_xo,
					mbv_yo,
					mbv_width,
					mbv_height,
					mbv_lorez_dimension,
					mbv_hirez_dimension,
					mbv_lorez_navdecimate,
					mbv_hirez_navdecimate,
					&error);
					
		/* extract the grid from the source */
		mbv_primary_dx = data_source->primary_dx;
		mbv_primary_dy = data_source->primary_dy;
		mbv_primary_xmin = MIN(data_source->region.cornerpoints[0].xgrid,
					data_source->region.cornerpoints[3].xgrid);
		mbv_primary_xmax = MAX(data_source->region.cornerpoints[0].xgrid,
					data_source->region.cornerpoints[3].xgrid);
		mbv_primary_ymin = MIN(data_source->region.cornerpoints[0].ygrid,
					data_source->region.cornerpoints[3].ygrid);
		mbv_primary_ymax = MAX(data_source->region.cornerpoints[0].ygrid,
					data_source->region.cornerpoints[3].ygrid);
		ixmin = (mbv_primary_xmin
				- data_source->primary_xmin) 
				/ mbv_primary_dx;
		ixmax = ((mbv_primary_xmax
				- data_source->primary_xmin) 
				/ mbv_primary_dx) + 1;
		jymin = (mbv_primary_ymin
				- data_source->primary_ymin) 
				/ mbv_primary_dy;
		jymax = ((mbv_primary_ymax
				- data_source->primary_ymin) 
				/ mbv_primary_dy) + 1;
		ixmin = MAX(ixmin, 0);
		ixmax = MIN(ixmax, data_source->primary_nx - 1);
		jymin = MAX(jymin, 0);
		jymax = MIN(jymax, data_source->primary_ny - 1);
		mbv_primary_xmin = data_source->primary_xmin + mbv_primary_dx * ixmin;
		mbv_primary_xmax = data_source->primary_xmin + mbv_primary_dx * ixmax;
		mbv_primary_ymin = data_source->primary_ymin + mbv_primary_dy * jymin;
		mbv_primary_ymax = data_source->primary_ymin + mbv_primary_dy * jymax;
		mbv_primary_nx = ixmax - ixmin + 1;
		mbv_primary_ny = jymax - jymin + 1;
		mbv_primary_nxy = mbv_primary_nx * mbv_primary_ny;
		status = mb_malloc(verbose, sizeof(float) * mbv_primary_nxy, 
    				&mbv_primary_data,
				&error);
		mbv_primary_min = data_source->primary_nodatavalue;
		mbv_primary_max = data_source->primary_nodatavalue;
		for (i=0;i<mbv_primary_nx;i++)
			{
			for (j=0;j<mbv_primary_ny;j++)
				{
				k = i * mbv_primary_ny + j;
				ksource = (i + ixmin) * data_source->primary_ny + (j + jymin);
				mbv_primary_data[k] = data_source->primary_data[ksource];
				if (mbv_primary_data[k] != data_source->primary_nodatavalue)
					{
					if (mbv_primary_min == data_source->primary_nodatavalue
						|| mbv_primary_data[k] < mbv_primary_min)
						{
						mbv_primary_min = mbv_primary_data[k];
						}
					if (mbv_primary_max == data_source->primary_nodatavalue
						|| mbv_primary_data[k] > mbv_primary_max)
						{
						mbv_primary_max = mbv_primary_data[k];
						}
					}
				}
			}

		/* set basic mbview view controls */
		if (status == MB_SUCCESS)
		status = mbview_setviewcontrols(verbose, instance,
					data_source->display_mode,
					data_source->mouse_mode,
					data_source->grid_mode,
					data_source->primary_shade_mode,
					data_source->slope_shade_mode,
					data_source->secondary_shade_mode,
					data_source->grid_contour_mode,
					data_source->site_view_mode,
					data_source->route_view_mode,
					data_source->nav_view_mode,
					data_source->navdrape_view_mode,
					data_source->exageration,
					data_source->modelelevation3d,
					data_source->modelazimuth3d,
					data_source->viewelevation3d,
					data_source->viewazimuth3d,
					data_source->illuminate_magnitude,
					data_source->illuminate_elevation,
					data_source->illuminate_azimuth,
					data_source->slope_magnitude,
					data_source->overlay_shade_magnitude,
					data_source->overlay_shade_center,
					data_source->overlay_shade_mode,
					data_source->contour_interval,
					data_source->display_projection_mode,
					data_source->display_projection_id,
					&error);

		/* set more mbview control values */
		if (status == MB_SUCCESS)
		status = mbview_setprimarygrid(verbose, instance,
					data_source->primary_grid_projection_mode,
					data_source->primary_grid_projection_id,
					data_source->primary_nodatavalue,
					mbv_primary_nx,
					mbv_primary_ny,
					mbv_primary_min,
					mbv_primary_max,
					mbv_primary_xmin,
					mbv_primary_xmax,
					mbv_primary_ymin,
					mbv_primary_ymax,
					mbv_primary_dx,
					mbv_primary_dy,
					mbv_primary_data,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_setprimarycolortable(verbose, instance,
					data_source->primary_colortable,
					data_source->primary_colortable_mode,
					data_source->primary_colortable_min,
					data_source->primary_colortable_max,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_setslopecolortable(verbose, instance,
					data_source->slope_colortable,
					data_source->slope_colortable_mode,
					data_source->slope_colortable_min,
					data_source->slope_colortable_max,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_enableeditsites(verbose, instance,
					&error);
		if (status == MB_SUCCESS)
		status = mbview_enableeditroutes(verbose, instance,
					&error);

		/* open up mbview window */
		if (status == MB_SUCCESS)
			{
fprintf(stderr,"about to open mbview instance:%d\n",instance);
			status = mbview_open(verbose, instance, &error);
			if (status == MB_SUCCESS)
				mbview_id[instance] = MB_YES;
			else
				mbview_id[instance] = MB_NO;
fprintf(stderr,"done opening mbview instance:%d\n",instance);

			/* add action button */
			if (status == MB_SUCCESS)
				{
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_openoverlay,
					"Open Overlay Grid", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_opensite,
					"Open Site File", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_openroute,
					"Open Route File", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_opennav,
					"Open Navigation", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_openswath,
					"Open Swath Data", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_savesite,
					"Save Site File", 
					MBV_PICKMASK_NONE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_fileSelectionBox_saveroute,
					"Save Route File", 
					MBV_PICKMASK_NONE, &error);

				mbview_addaction(verbose, instance,
					do_mbgrdviz_open_region,
					"Open Region as New View", 
					MBV_PICKMASK_REGION + MBV_PICKMASK_NEWINSTANCE, &error);
				mbview_addaction(verbose, instance,
					do_mbgrdviz_make_survey,
					"Generate Survey Route from Area", 
					MBV_PICKMASK_AREA, &error);
				}
			}

		}
	    
	/* set sensitivity of widgets that require an mbview instance to be active */
	do_mbgrdviz_sensitivity( );
}
/*---------------------------------------------------------------------------------------*/

void do_mbgrdviz_make_survey( Widget w, XtPointer client_data, XtPointer call_data)
{
	char function_name[] = "do_mbgrdviz_make_survey";
	int	status = MB_SUCCESS;
	
	/* mbview instance */
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	struct mbview_world_struct *view;
	struct mbview_struct *data;

    	/* get source mbview instance */
	instance = (int) client_data;
fprintf(stderr,"Called do_mbgrdviz_make_survey instance:%d\n", instance);
	    
    	/* check data source for area to bounding desired survey */
	status = mbview_getdataptr(verbose, instance, &data, &error);
					
	/* check if area is currently defined */
	if (status == MB_SUCCESS)
		{
		if (data->area_type != MBV_AREA_QUAD)
			status = MB_FAILURE;
		}
	    
    	/* set parameters and display the survey generation dialog */
	if (status == MB_SUCCESS)
		{
	
		/* set title to open primary grid */
		ac = 0;
		XtSetArg(args[ac], XmNtitle, "Generate Survey Lines from Area"); ac++;
		XtSetValues(bulletinBoard_arearoute, args, ac);
	
		/* set instance into XmNuserData resources */
		ac = 0;
		XtSetArg(args[ac], XmNuserData, (XtPointer)instance); ac++;
		XtSetValues(bulletinBoard_arearoute, args, ac);
		XtSetValues(textField_arearoute_name, args, ac);
		XtSetValues(spinBox_arearoute_color, args, ac);
		XtSetValues(spinText_arearoute_color, args, ac);
		XtSetValues(spinBox_arearoute_crosslines, args, ac);
		XtSetValues(spinText_arearoute_crosslines, args, ac);
		XtSetValues(spinBox_arearoute_altitude, args, ac);
		XtSetValues(spinText_arearoute_altitude, args, ac);
		XtSetValues(spinBox_arearoute_depth, args, ac);
		XtSetValues(spinText_arearoute_depth, args, ac);
		XtSetValues(spinBox_arearoute_direction, args, ac);
		XtSetValues(spinText_arearoute_direction, args, ac);
		XtSetValues(spinBox_arearoute_swathwidth, args, ac);
		XtSetValues(spinText_arearoute_swathwidth, args, ac);
		XtSetValues(spinBox_arearoute_platform, args, ac);
		XtSetValues(spinText_arearoute_platform, args, ac);
		XtSetValues(spinBox_arearoute_linespacing, args, ac);
		XtSetValues(spinText_arearoute_linespacing, args, ac);
		XtSetValues(spinBox_arearoute_interleaving, args, ac);
		XtSetValues(spinText_arearoute_interleaving, args, ac);
		XtSetValues(label_arearoute_info, args, ac);
		XtSetValues(spinBox_arearoute_linecontrol, args, ac);
		XtSetValues(spinText_arearoute_linecontrol, args, ac);
		XtSetValues(pushButton_arearoute_ok, args, ac);
	
		/* setting instance into XmNuserData resources
			doesn't seem to work, so set survey_instance as well */
		survey_instance = instance;
		
		}
	    
    	/* set widgets */
	if (status == MB_SUCCESS)
		{
		ac = 0;
		XtSetArg(args[ac], XmNposition, survey_mode); ac++; 
		XtSetValues(spinText_arearoute_linecontrol, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, survey_direction); ac++;
		XtSetValues(spinText_arearoute_direction, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, survey_crosslines); ac++;
		XtSetValues(spinText_arearoute_crosslines, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, survey_interleaving); ac++;
		XtSetValues(spinText_arearoute_interleaving, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, survey_color); ac++;
		XtSetValues(spinText_arearoute_color, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, survey_linespacing); ac++;
		XtSetValues(spinText_arearoute_linespacing, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, survey_platform); ac++;
		XtSetValues(spinText_arearoute_platform, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, survey_swathwidth); ac++;
		XtSetValues(spinText_arearoute_swathwidth, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, survey_altitude); ac++;
		XtSetValues(spinText_arearoute_altitude, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, survey_depth); ac++;
		XtSetValues(spinText_arearoute_depth, args, ac);

		XmTextSetString(textField_arearoute_name, survey_name);

		do_mbgrdviz_arearoute_recalc(instance);

		/* put up the dialog */
		BxManageCB(w, (XtPointer)"bulletinBoard_arearoute", call_data);
		}
}
/*---------------------------------------------------------------------------------------*/

void do_mbgrdviz_generate_survey( Widget w, XtPointer client_data, XtPointer call_data)
{
	char function_name[] = "do_mbgrdviz_generate_survey";
	int	status = MB_SUCCESS;
	
	/* mbview instance */
	int	instance;
	struct mbview_world_struct *view;
	struct mbview_struct *data;
	
	/* survey construction parameters */
	int	color;
	double	line_spacing;
	double	line_spacing_use;
	double	crossline_spacing;
	int	nlines;
	int	nlinegroups, npoints;
	double xgrid, ygrid;
	double xlon, ylat, zdata;
	double xdisplay, ydisplay, zdisplay;
	double	dsign;
	int	waypoint;
	int	first;
	double	dsigna[4] = {1.0, -1.0, 1.0, -1.0};
	int	jendpointa[4] = {0, 0, 1, 1};
	
	char	*error_message;
	double	*xx = NULL;
	double	dx, dy, r, dxuse, dyuse, dxd, dyd, dxextra, dyextra;
	double	rrr[4], xxx, yyy;
	int	iline, jendpoint, ok;
	int	endcorner, jstart, kend;
	int	nlines_alloc = 0;
	int	i, j, k;

    	/* get source mbview instance */
	instance = (int) client_data;
	
	/* getting instance from client_data doesn't seem
		to work so use survey_instance instead */
	instance = survey_instance;
fprintf(stderr,"Called do_mbgrdviz_generate_survey instance:%d\n", instance);
	    
    	/* check data source for area to bounding desired survey */
	status = mbview_getdataptr(verbose, instance, &data, &error);
					
	/* check if area is currently defined */
	if (status == MB_SUCCESS)
		{
		if (data->area_type != MBV_AREA_QUAD)
			status = MB_FAILURE;
		}
	    
    	/* generate survey lines from area and add as new route */
	if (status == MB_SUCCESS)
		{
		/* delete current working route if defined */
		if (working_route > -1)
			{
			mbview_deleteroute(verbose, instance, working_route, &error);
			working_route = -1;
			}
			
		/* get unit vector for survey area boundaries */
		dx = data->area.cornerpoints[1].xdisplay 
			- data->area.cornerpoints[0].xdisplay;
		dy = data->area.cornerpoints[1].ydisplay 
			- data->area.cornerpoints[0].ydisplay;
		r = sqrt(dx * dx + dy * dy);
		dx = dx / r;
		dy = dy / r;

		/* get parameters */
		if (data->area.bearing >= 315.0 || data->area.bearing < 45.0)
			{
			if (survey_direction == MBGRDVIZ_SURVEY_DIRECTION_SW)
				k = 0;
			else if (survey_direction == MBGRDVIZ_SURVEY_DIRECTION_SE)
				k = 1;
			else if (survey_direction == MBGRDVIZ_SURVEY_DIRECTION_NW)
				k = 2;
			else if (survey_direction == MBGRDVIZ_SURVEY_DIRECTION_NE)
				k = 3;
			}
		else if (data->area.bearing >= 45.0 && data->area.bearing < 135.0)
			{
			if (survey_direction == MBGRDVIZ_SURVEY_DIRECTION_SW)
				k = 1;
			else if (survey_direction == MBGRDVIZ_SURVEY_DIRECTION_SE)
				k = 3;
			else if (survey_direction == MBGRDVIZ_SURVEY_DIRECTION_NW)
				k = 0;
			else if (survey_direction == MBGRDVIZ_SURVEY_DIRECTION_NE)
				k = 2;
			}
		else if (data->area.bearing >= 135.0 && data->area.bearing < 225.0)
			{
			if (survey_direction == MBGRDVIZ_SURVEY_DIRECTION_SW)
				k = 3;
			else if (survey_direction == MBGRDVIZ_SURVEY_DIRECTION_SE)
				k = 2;
			else if (survey_direction == MBGRDVIZ_SURVEY_DIRECTION_NW)
				k = 1;
			else if (survey_direction == MBGRDVIZ_SURVEY_DIRECTION_NE)
				k = 0;
			}
		else if (data->area.bearing >= 225.0 && data->area.bearing < 315.0)
			{
			if (survey_direction == MBGRDVIZ_SURVEY_DIRECTION_SW)
				k = 2;
			else if (survey_direction == MBGRDVIZ_SURVEY_DIRECTION_SE)
				k = 0;
			else if (survey_direction == MBGRDVIZ_SURVEY_DIRECTION_NW)
				k = 3;
			else if (survey_direction == MBGRDVIZ_SURVEY_DIRECTION_NE)
				k = 1;
			}
		dsign = dsigna[k];
		jendpoint = jendpointa[k];
		if (survey_color == 0)
			color = MBV_COLOR_BLACK;
		else if (survey_color == 1)
			color = MBV_COLOR_YELLOW;
		else if (survey_color == 2)
			color = MBV_COLOR_GREEN;
		else if (survey_color == 3)
			color = MBV_COLOR_BLUEGREEN;
		else if (survey_color == 4)
			color = MBV_COLOR_BLUE;
		else if (survey_color == 5)
			color = MBV_COLOR_PURPLE;

		/* do uniform line spacing */
		if (survey_mode == MBGRDVIZ_SURVEY_MODE_UNIFORM)
			{
			/* get number of lines */
			first = MB_YES;
			line_spacing = (double) survey_linespacing;
			line_spacing_use = line_spacing * r / data->area.width;
			nlines = (data->area.width / line_spacing) + 1;
			
			/* allocate space for line position array */
			status = mb_malloc(verbose, nlines * sizeof(double), &xx, &error);
			if (status != MB_SUCCESS)
				{
				nlines_alloc = 0;
				mb_error(verbose,error,&error_message);
				fprintf(stderr,"\nMBIO Error allocating data arrays:\n%s\n",
					error_message);
				}
			else
				nlines_alloc = nlines;
			
			/* calculate line positions */
			if (status == MB_SUCCESS)
			for (i=0;i<nlines;i++)
				{
				/* get line position in survey area */
				xx[i] = dsign * line_spacing_use * (((double)i) 
								- 0.5 * (nlines - 1.0));
				}
			}

		/* do variable line spacing with constant altitude */
		else if (survey_mode == MBGRDVIZ_SURVEY_MODE_VARIABLE
			&& survey_platform == MBGRDVIZ_SURVEY_PLATFORM_SUBMERGED_ALTITUDE)
			{
			/* get number of lines */
			first = MB_YES;
			line_spacing = (double) survey_altitude * 2.0 * tan(0.5 * survey_swathwidth);
			line_spacing_use = line_spacing * r / data->area.width;
			nlines = (data->area.width / line_spacing) + 1;
			
			/* allocate space for line position array */
			status = mb_malloc(verbose, nlines * sizeof(double), &xx, &error);
			if (status != MB_SUCCESS)
				{
				nlines_alloc = 0;
				mb_error(verbose,error,&error_message);
				fprintf(stderr,"\nMBIO Error allocating data arrays:\n%s\n",
					error_message);
				}
			else
				nlines_alloc = nlines;
			
			/* calculate line positions */
			if (status == MB_SUCCESS)
			for (i=0;i<nlines;i++)
				{
				/* get line position in survey area */
				xx[i] = dsign * line_spacing_use * (((double)i) 
								- 0.5 * (nlines - 1.0));
				}
			}

		/* do variable line spacing with variable altitude */
		else if (survey_mode == MBGRDVIZ_SURVEY_MODE_VARIABLE)
			{
			/* find range of altitude along each line and calculate the swath width
				from the smallest altitude */
				
			/* start in the center of the survey */
				 
			/* get number of lines */
			first = MB_YES;
			line_spacing = (double) survey_altitude * 2.0 * tan(0.5 * survey_swathwidth);
			line_spacing_use = line_spacing * r / data->area.width;
			nlines = (data->area.width / line_spacing) + 1;
			
			/* allocate space for line position array */
			nlines_alloc += 100;
			status = mb_realloc(verbose, nlines_alloc * sizeof(double), &xx, &error);
			if (status != MB_SUCCESS)
				{
				nlines_alloc = 0;
				mb_error(verbose,error,&error_message);
				fprintf(stderr,"\nMBIO Error allocating data arrays:\n%s\n",
					error_message);
				}
			else
				nlines_alloc = nlines;
			
			/* calculate line positions */
			if (status == MB_SUCCESS)
				{
				for (i=0;i<nlines;i++)
					{
					/* get line position in survey area */
					xx[i] = dsign * line_spacing_use * (((double)i) 
									- 0.5 * (nlines - 1.0));
					}
				}
			}

		/* generate the lines */
		if (nlines > 0 && status == MB_SUCCESS)
			{			
			/* generate points */
			/* work in display coordinates */
			npoints = 0;
			nlinegroups = nlines / survey_interleaving + 1;
			for (j=0;j<survey_interleaving;j++)
			for (i=0;i<nlinegroups;i++)
				{
				/* get line number */
				iline = i * survey_interleaving + j;

				if (iline < nlines)
					{
					/* get line position in survey area */
					dxuse = dx * xx[iline];
					dyuse = dy * xx[iline];
					
					/* add a bit of transit before later interleaved lines */
					if (jendpoint == 1)
						{
						dxextra = -dy * j * 0.25 * line_spacing_use;
						dyextra = dx * j * 0.25 * line_spacing_use;
						}
					else
						{
						dxextra = dy * j * 0.25 * line_spacing_use;
						dyextra = -dx * j * 0.25 * line_spacing_use;
						}

					/* get first point */
					waypoint = MBV_ROUTE_WAYPOINT_STARTLINE;
					xdisplay = data->area.endpoints[jendpoint].xdisplay
						+ dxuse + dxextra;
					ydisplay = data->area.endpoints[jendpoint].ydisplay
						+ dyuse + dyextra;
					zdisplay = data->area.endpoints[jendpoint].zdisplay;
					mbview_projectinverse(instance, MB_YES,
							xdisplay, ydisplay, zdisplay, 
							&xlon, &ylat,
							&xgrid, &ygrid);
					mbview_getzdata(instance, 
							xgrid, ygrid, 
							&ok, &zdata);
					if (ok == MB_NO)
						zdata = data->area.endpoints[jendpoint].zdata;
					mbview_projectll2display(instance,
						xlon, ylat, zdata, 
						&xdisplay, &ydisplay, &zdisplay);
fprintf(stderr,"\nSurvey Line:%d Point:%d  Position: %f %f %f  %f %f   %f %f %f\n",
iline, jendpoint, xlon, ylat, zdata, xgrid, ygrid, xdisplay, ydisplay, zdisplay);

					/* add new route for first point, just add single point
						after that */
					if (first == MB_YES)
						{
						mbview_addroute(verbose, instance,
								1, &xlon, &ylat, &waypoint,
								color, 2,
								survey_name, 
								&working_route, &error);
						first = MB_NO;
						}
					else
						{
						mbview_route_add(instance, working_route, npoints, waypoint,
								xgrid, ygrid,
								xlon, ylat, zdata,
								xdisplay, ydisplay, zdisplay);
						}
					npoints++;

					/* switch endpoint */
					jendpoint = ++jendpoint % 2;
					
					/* add a bit of transit before interleaved lines */
					if (jendpoint == 1)
						{
						dxextra = -dy * j * 0.25 * line_spacing_use;
						dyextra = dx * j * 0.25 * line_spacing_use;
						}
					else
						{
						dxextra = dy * j * 0.25 * line_spacing_use;
						dyextra = -dx * j * 0.25 * line_spacing_use;
						}

					/* get second point */
					waypoint = MBV_ROUTE_WAYPOINT_ENDLINE;
					xdisplay = data->area.endpoints[jendpoint].xdisplay
						+ dxuse + dxextra;
					ydisplay = data->area.endpoints[jendpoint].ydisplay
						+ dyuse + dyextra;
					zdisplay = data->area.endpoints[jendpoint].zdisplay;			
					mbview_projectinverse(instance, MB_YES,
							xdisplay, ydisplay, zdisplay, 
							&xlon, &ylat,
							&xgrid, &ygrid);
					mbview_getzdata(instance, 
							xgrid, ygrid, 
							&ok, &zdata);
					if (ok == MB_NO)
						zdata = data->area.endpoints[jendpoint].zdata;
					mbview_projectll2display(instance,
						xlon, ylat, zdata, 
						&xdisplay, &ydisplay, &zdisplay);
fprintf(stderr,"Survey Line:%d Point:%d  Position: %f %f %f  %f %f   %f %f %f\n",
iline, jendpoint, xlon, ylat, zdata, xgrid, ygrid, xdisplay, ydisplay, zdisplay);

					/* add single point */
					mbview_route_add(instance, working_route, npoints, waypoint,
							xgrid, ygrid,
							xlon, ylat, zdata,
							xdisplay, ydisplay, zdisplay);
					npoints++;
					}
				}
				
			/* deallocate line position array */
			mb_free(verbose, &xx, &error);
			}
			
		/* do crosslines if requested */
		if (survey_crosslines > 0 && status == MB_SUCCESS)
			{
			/* figure out which corner the mail lines ended at */
			for (i=0;i<4;i++)
				{
				xxx = xdisplay - data->area.cornerpoints[i].xdisplay;
				yyy = ydisplay - data->area.cornerpoints[i].ydisplay;
				rrr[i] = sqrt(xxx * xxx + yyy * yyy);
				}
			endcorner = 0;
			for (i=1;i<4;i++)
				{
				if (rrr[i] < rrr[endcorner])
					endcorner = i;
				}
					
			/* get crossline vector */
			if (endcorner == 0 || endcorner == 3)
				{
				dx = data->area.cornerpoints[1].xdisplay 
					- data->area.cornerpoints[0].xdisplay;
				dy = data->area.cornerpoints[1].ydisplay 
					- data->area.cornerpoints[0].ydisplay;
				}
			else
				{
				dx = data->area.cornerpoints[0].xdisplay 
					- data->area.cornerpoints[1].xdisplay;
				dy = data->area.cornerpoints[0].ydisplay 
					- data->area.cornerpoints[1].ydisplay;
				}
			r = sqrt(dx * dx + dy * dy);
			dxd = dx / r;
			dyd = dy / r;

			/* get crossline spacing */
			crossline_spacing = (data->area.length / (crossline_spacing + 1)) * (r / data->area.width);
			
			/* generate cross lines */
			jstart = endcorner;
			if (endcorner == 0 || endcorner == 2)
				kend = jstart + 1;
			else
				kend = jstart - 1;
			dx = (data->area.endpoints[1].xdisplay 
				- data->area.endpoints[0].xdisplay) / (survey_crosslines + 1);
			dy = (data->area.endpoints[1].ydisplay 
				- data->area.endpoints[0].ydisplay) / (survey_crosslines + 1);
			if (endcorner >= 2)
				{
				dx = -dx;
				dy = -dy;
				}
			j = jstart;
			for (i=0;i<survey_crosslines;i++)
				{
				/* get offset from corners */
				dxuse = (i + 1) * dx;
				dyuse = (i + 1) * dy;
				if (j == jstart)
					{
					dxextra = -dxd * line_spacing_use;
					dyextra = -dyd * line_spacing_use;
					}
				else
					{
					dxextra = dxd * line_spacing_use;
					dyextra = dyd * line_spacing_use;
					}
				
				/* get first point */
				waypoint = MBV_ROUTE_WAYPOINT_STARTLINE;
				xdisplay = data->area.cornerpoints[j].xdisplay
					+ dxuse + dxextra;
				ydisplay = data->area.cornerpoints[j].ydisplay
					+ dyuse + dyextra;
				zdisplay = data->area.cornerpoints[j].zdisplay;
				mbview_projectinverse(instance, MB_YES,
						xdisplay, ydisplay, zdisplay, 
						&xlon, &ylat,
						&xgrid, &ygrid);
				mbview_getzdata(instance, 
						xgrid, ygrid, 
						&ok, &zdata);
				if (ok == MB_NO)
					zdata = data->area.cornerpoints[jendpoint].zdata;
				mbview_projectll2display(instance,
					xlon, ylat, zdata, 
					&xdisplay, &ydisplay, &zdisplay);
				mbview_route_add(instance, working_route, npoints, waypoint,
						xgrid, ygrid,
						xlon, ylat, zdata,
						xdisplay, ydisplay, zdisplay);
				npoints++;
				
				/* get second point */
				if (j == jstart)
					j = kend;
				else
					j = jstart;
				if (j == jstart)
					{
					dxextra = -dxd * line_spacing_use;
					dyextra = -dyd * line_spacing_use;
					}
				else
					{
					dxextra = dxd * line_spacing_use;
					dyextra = dyd * line_spacing_use;
					}
				
				/* get second point */
				waypoint = MBV_ROUTE_WAYPOINT_ENDLINE;
				xdisplay = data->area.cornerpoints[j].xdisplay
					+ dxuse + dxextra;
				ydisplay = data->area.cornerpoints[j].ydisplay
					+ dyuse + dyextra;
				zdisplay = data->area.cornerpoints[j].zdisplay;
				mbview_projectinverse(instance, MB_YES,
						xdisplay, ydisplay, zdisplay, 
						&xlon, &ylat,
						&xgrid, &ygrid);
				mbview_getzdata(instance, 
						xgrid, ygrid, 
						&ok, &zdata);
				if (ok == MB_NO)
					zdata = data->area.cornerpoints[jendpoint].zdata;
				mbview_projectll2display(instance,
					xlon, ylat, zdata, 
					&xdisplay, &ydisplay, &zdisplay);
				mbview_route_add(instance, working_route, npoints, waypoint,
						xgrid, ygrid,
						xlon, ylat, zdata,
						xdisplay, ydisplay, zdisplay);
				npoints++;
				}
			
			}

		/* update widgets */
		do_mbgrdviz_arearoute_info(instance);
		mbview_enableviewnavs(verbose, instance, &error);
		status = mbview_update(verbose, instance, &error);
		}
}
/*---------------------------------------------------------------------------------------*/


void
do_mbgrdviz_arearoute_dismiss( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
    
    
	/* reset current working route so the last one generated is saved */
	working_route = -1;
}
/*---------------------------------------------------------------------------------------*/

void
do_mbgrdviz_arearoute_parameterchange( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
	char function_name[] = "do_mbgrdviz_arearoute_parameterchange";
	int	status = MB_SUCCESS;
	
	/* mbview instance */
        Cardinal ac = 0;
        Arg      args[256];
	int	instance;
	struct mbview_world_struct *view;
	struct mbview_struct *data;
	char	*tmp;

    	/* get source mbview instance */
	instance = (int) client_data;
fprintf(stderr,"Called do_mbgrdviz_arearoute_parameterchange instance:%d\n", instance);
	    
    	/* check data source for area to bounding desired survey */
	status = mbview_getdataptr(verbose, instance, &data, &error);
					
	/* check if area is currently defined */
	if (status == MB_SUCCESS)
		{
		if (data->area_type != MBV_AREA_QUAD)
			status = MB_FAILURE;
		}
	    
    	/* get parameters */
	if (status == MB_SUCCESS)
		{
		/* get values */

		ac = 0;
		XtSetArg(args[ac], XmNposition, (XtPointer) &survey_mode); ac++; 
		XtGetValues(spinText_arearoute_linecontrol, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, (XtPointer) &survey_direction); ac++;
		XtGetValues(spinText_arearoute_direction, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, (XtPointer) &survey_crosslines); ac++;
		XtGetValues(spinText_arearoute_crosslines, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, (XtPointer) &survey_interleaving); ac++;
		XtGetValues(spinText_arearoute_interleaving, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, (XtPointer) &survey_color); ac++;
		XtGetValues(spinText_arearoute_color, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, (XtPointer) &survey_linespacing); ac++;
		XtGetValues(spinText_arearoute_linespacing, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, (XtPointer) &survey_platform); ac++;
		XtGetValues(spinText_arearoute_platform, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, (XtPointer) &survey_swathwidth); ac++;
		XtGetValues(spinText_arearoute_swathwidth, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, (XtPointer) &survey_altitude); ac++;
		XtGetValues(spinText_arearoute_altitude, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNposition, (XtPointer) &survey_depth); ac++;
		XtGetValues(spinText_arearoute_depth, args, ac);

		tmp = XmTextGetString(textField_arearoute_name);
		if (tmp != NULL && strlen(tmp) > 0)
			strcpy(survey_name,tmp);
		else
			{
			if (strlen(survey_name) <= 0)
				sprintf(survey_name, "Survey");
			XmTextSetString(textField_arearoute_name, survey_name);
			}
		if (tmp != NULL)
			XtFree(tmp);
		
fprintf(stderr,"\nIn do_mbgrdviz_arearoute_parameterchange:\n");
fprintf(stderr,"  survey_mode:        %d\n",survey_mode);
fprintf(stderr,"  survey_platform:    %d\n",survey_platform);
fprintf(stderr,"  survey_interleaving:%d\n",survey_interleaving);
fprintf(stderr,"  survey_direction:   %d\n",survey_direction);
fprintf(stderr,"  survey_crosslines:  %d\n",survey_crosslines);
fprintf(stderr,"  survey_linespacing: %d\n",survey_linespacing);
fprintf(stderr,"  survey_swathwidth:  %d\n",survey_swathwidth);
fprintf(stderr,"  survey_depth:       %d\n",survey_depth);
fprintf(stderr,"  survey_altitude:    %d\n",survey_altitude);
fprintf(stderr,"  survey_color:       %d\n",survey_color);
fprintf(stderr,"  survey_name:        %s\n",survey_name);

		/* reset widgets accordingly (sensitivity and info) */
		do_mbgrdviz_arearoute_recalc(instance);
	
		}
}
/*---------------------------------------------------------------------------------------*/

void
do_mbgrdviz_arearoute_recalc(int instance)
{
	char function_name[] = "do_mbgrdviz_arearoute_recalc";
	int	status = MB_SUCCESS;
	
	/* mbview instance */
        Cardinal ac = 0;
        Arg      args[256];
	struct mbview_world_struct *view;
	struct mbview_struct *data;
	char	info_text[MB_PATH_MAXLINE];

fprintf(stderr,"Called do_mbgrdviz_arearoute_recalc instance:%d\n", instance);
	    
    	/* check data source for area to bounding desired survey */
	status = mbview_getdataptr(verbose, instance, &data, &error);
					
	/* check if area is currently defined */
	if (status == MB_SUCCESS)
		{
		if (data->area_type != MBV_AREA_QUAD)
			status = MB_FAILURE;
		}
	    
    	/* set widgets */
	if (status == MB_SUCCESS)
		{
		ac = 0;
		XtSetArg(args[ac], XmNsensitive, True); ac++; 
		XtSetValues(spinText_arearoute_linecontrol, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNsensitive, True); ac++; 
		XtSetValues(spinText_arearoute_direction, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNsensitive, True); ac++; 
		XtSetValues(spinText_arearoute_crosslines, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNsensitive, True); ac++; 
		XtSetValues(spinText_arearoute_interleaving, args, ac);

		ac = 0;
		XtSetArg(args[ac], XmNsensitive, True); ac++; 
		XtSetValues(spinText_arearoute_color, args, ac);

		ac = 0;
		if (survey_mode == MBGRDVIZ_SURVEY_MODE_UNIFORM)
			{
			XtSetArg(args[ac], XmNsensitive, True); ac++; 
			}
		else
			{
			XtSetArg(args[ac], XmNsensitive, False); ac++; 
			}
		XtSetValues(spinText_arearoute_linespacing, args, ac);

		ac = 0;
		if (survey_mode == MBGRDVIZ_SURVEY_MODE_VARIABLE)
			{
			XtSetArg(args[ac], XmNsensitive, True); ac++; 
			}
		else
			{
			XtSetArg(args[ac], XmNsensitive, False); ac++; 
			}
		XtSetValues(spinText_arearoute_platform, args, ac);

		ac = 0;
		if (survey_mode == MBGRDVIZ_SURVEY_MODE_VARIABLE)
			{
			XtSetArg(args[ac], XmNsensitive, True); ac++; 
			}
		else
			{
			XtSetArg(args[ac], XmNsensitive, False); ac++; 
			}
		XtSetValues(spinText_arearoute_swathwidth, args, ac);

		ac = 0;
		if (survey_mode == MBGRDVIZ_SURVEY_MODE_VARIABLE
			&& survey_platform == MBGRDVIZ_SURVEY_PLATFORM_SUBMERGED_DEPTH)
			{
			XtSetArg(args[ac], XmNsensitive, True); ac++; 
			}
		else
			{
			XtSetArg(args[ac], XmNsensitive, False); ac++; 
			}
		XtSetValues(spinText_arearoute_altitude, args, ac);

		ac = 0;
		if (survey_mode == MBGRDVIZ_SURVEY_MODE_VARIABLE
			&& survey_platform == MBGRDVIZ_SURVEY_PLATFORM_SUBMERGED_ALTITUDE)
			{
			XtSetArg(args[ac], XmNsensitive, True); ac++; 
			}
		else
			{
			XtSetArg(args[ac], XmNsensitive, False); ac++; 
			}
		XtSetValues(spinText_arearoute_depth, args, ac);

		do_mbgrdviz_arearoute_info(instance);
	
		}
}
/*---------------------------------------------------------------------------------------*/

void
do_mbgrdviz_arearoute_info(int instance)
{
	char function_name[] = "do_mbgrdviz_arearoute_info";
	int	status = MB_SUCCESS;
	
	/* mbview instance */
        Cardinal ac = 0;
        Arg      args[256];
	struct mbview_world_struct *view;
	struct mbview_struct *data;
	int	nroutewaypoint;
	int	nroutpoint;
	char	routename[MB_PATH_MAXLINE];
	int	routecolor;
	int	routesize;
	double	routedistancelateral;
	double	routedistancetopo;
	char	info_text[MB_PATH_MAXLINE];

fprintf(stderr,"Called do_mbgrdviz_arearoute_info instance:%d\n", instance);
	    
    	/* check data source for area to bounding desired survey */
	status = mbview_getdataptr(verbose, instance, &data, &error);
					
	/* check if area is currently defined */
	if (status == MB_SUCCESS)
		{
		if (data->area_type != MBV_AREA_QUAD)
			status = MB_FAILURE;
		sprintf(info_text, ":::t\"No Current Area:\"");
		}
	    
    	/* set widgets */
	if (status == MB_SUCCESS)
		{
		if (working_route >= 0)
			{
			/* get info for working route */
			status = mbview_getrouteinfo(verbose, instance,
			    		working_route, &nroutewaypoint, &nroutpoint, 
					routename, &routecolor, &routesize, 
					&routedistancelateral, &routedistancetopo, 
					&error);

			sprintf(info_text,
			":::t\"Current Area:\":t\" Length: %.1f m  Width: %.1f m  Bearing: %.1f deg\":t\"New Route: %d  Name: %s\":t\" Waypoints: %d  Total Points:%d\":t\" Distance: %.1f m (lateral) %.1f m (over bottom)\"", 
				data->area.length,
				data->area.width,
				data->area.bearing,
				working_route,
				routename,
				nroutewaypoint,
				nroutpoint,
				routedistancelateral,
				routedistancetopo);
			}		
		else
			{
			sprintf(info_text,
			":::t\"Current Area:\":t\" Length: %.3f m\":t\" Width: %.3f m\":t\" Bearing: %.1f deg\"", 
				data->area.length,
				data->area.width,
				data->area.bearing);
			}
		set_mbview_label_multiline_string(label_arearoute_info, info_text);
		}
}
/*---------------------------------------------------------------------------------------*/

void
do_mbgrdviz_arearoute_linespacing_increment( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
	char function_name[] = "do_mbgrdviz_arearoute_linespacing_increment";
	int	status = MB_SUCCESS;
        Cardinal ac = 0;
        Arg      args[256];
	int	linespacing;
	int	increment;

	/* reset line spacing spinbox increment as value changes */
  	ac = 0;
	XtSetArg(args[ac], XmNposition, (XtPointer) &linespacing); ac++;
	XtGetValues(spinText_arearoute_linespacing, args, ac);
	if (linespacing < 25)
		increment = 1;
	else if (linespacing < 100)
		increment = 5;
	else if (linespacing < 250)
		increment = 10;
	else if (linespacing < 1000)
		increment = 25;
	else if (linespacing < 2000)
		increment = 50;
	else
		increment = 100;
 	ac = 0;
	XtSetArg(args[ac], XmNincrementValue, increment); ac++;
	XtSetValues(spinText_arearoute_linespacing, args, ac);
 }
/*---------------------------------------------------------------------------------------*/

void
do_mbgrdviz_arearoute_altitude_increment( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
	char function_name[] = "do_mbgrdviz_arearoute_altitude_increment";
	int	status = MB_SUCCESS;
        Cardinal ac = 0;
        Arg      args[256];
	int	altitude;
	int	increment;

	/* reset line spacing spinbox increment as value changes */
  	ac = 0;
	XtSetArg(args[ac], XmNposition, (XtPointer) &altitude); ac++;
	XtGetValues(spinText_arearoute_altitude, args, ac);
	if (altitude < 25)
		increment = 1;
	else if (altitude < 100)
		increment = 5;
	else if (altitude < 250)
		increment = 10;
	else if (altitude < 1000)
		increment = 25;
	else if (altitude < 2000)
		increment = 50;
	else
		increment = 100;
 	ac = 0;
	XtSetArg(args[ac], XmNincrementValue, increment); ac++;
	XtSetValues(spinText_arearoute_altitude, args, ac);
}
/*---------------------------------------------------------------------------------------*/


void
do_mbgrdviz_arearoute_depth_increment( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
	char function_name[] = "do_mbgrdviz_arearoute_depth_increment";
	int	status = MB_SUCCESS;
        Cardinal ac = 0;
        Arg      args[256];
	int	depth;
	int	increment;

	/* reset line spacing spinbox increment as value changes */
  	ac = 0;
	XtSetArg(args[ac], XmNposition, (XtPointer) &depth); ac++;
	XtGetValues(spinText_arearoute_depth, args, ac);
	if (depth < 25)
		increment = 1;
	else if (depth < 100)
		increment = 5;
	else if (depth < 250)
		increment = 10;
	else if (depth < 1000)
		increment = 25;
	else if (depth < 2000)
		increment = 50;
	else
		increment = 100;
 	ac = 0;
	XtSetArg(args[ac], XmNincrementValue, increment); ac++;
	XtSetValues(spinText_arearoute_depth, args, ac);
}
/*---------------------------------------------------------------------------------------*/

void
do_mbgrdviz_realtime_start( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
}

void
do_mbgrdviz_realtimesetup_path_reset( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
}

void
do_mbgrdviz_realtime_pause( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
}

void
do_mbgrdviz_realtime_stop( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
}

void
do_mbgrdviz_realtime_resume( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
}

void
do_mbgrdviz_realtimesetup_path_apply( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
}
/*      Function Name:	BxPopdownCB
 *
 *      Description:   	This function accepts a string of the form:
 *			"(WL)[widgetName, widgetName, ...]"
 *			It attempts to convert the widget names to Widget IDs
 *			and then popdown the widgets WITHOUT any grab.
 *
 *      Arguments:      Widget		w:	the activating widget.
 *			XtPointer	client:	the string of widget names to
 *						popup.
 *			XtPointer	call:	the call data (unused).
 *
 *      Notes:        * This function expects that there is an application
 *                      shell from which all other widgets are descended.
 *		      * BxPopdownCB can only work on Shell widgets.  It will
 *			not work on other object types.  This is because
 *			popping down can only be done to a shell.  A check
 *			is made using XtIsShell() and an appropriate error
 *			is output if the passed object is not a Shell.
 */

/* ARGSUSED */
void
BxPopdownCB ARGLIST((w, client, call))
ARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
    WidgetList		widgets;
    int			i;

    /*
     * This function returns a NULL terminated WidgetList.  The memory for
     * the list needs to be freed when it is no longer needed.
     */
    widgets = BxWidgetIdsFromNames(w, "BxPopdownCB", (String)client);
    
    i = 0;
    while ( widgets && widgets[i] != NULL )
    {
	if ( XtIsShell(widgets[i]) )
	{
	    XtPopdown(widgets[i]);
	}
	else
	{
	    printf("Callback Error (BxPopdownCB):\n\t\
Object %s is not a Shell\n", XtName(widgets[i]));
	}
	i++;
    }
    XtFree((char *)widgets);
}

/*      Function Name:	BxPopupCB
 *
 *      Description:   	This function accepts a string of the form:
 *			"(WL)[widgetName, widgetName, ...]"
 *			It attempts to convert the widget names to Widget IDs
 *			and then popup the widgets WITHOUT any grab.
 *
 *      Arguments:      Widget		w:	the activating widget.
 *			XtPointer	client:	the string of widget names to
 *						popup.
 *			XtPointer	call:	the call data (unused).
 *
 *      Notes:        * This function expects that there is an application
 *                      shell from which all other widgets are descended.
 *		      * BxPopupCB can only work on Shell widgets.  It will not
 *			work on other object types.  This is because popping up
 *			can only be done to a shell.  A check is made using
 *			XtIsShell() and an appropriate error is output if the
 *			passed object is not a Shell.
 */

/* ARGSUSED */
void
BxPopupCB ARGLIST((w, client, call))
ARG( Widget, w)
ARG( XtPointer, client)
GRAU( XtPointer, call)
{
    WidgetList		widgets;
    int			i;

    /*
     * This function returns a NULL terminated WidgetList.  The memory for
     * the list needs to be freed when it is no longer needed.
     */
    widgets = BxWidgetIdsFromNames(w, "BxPopupCB", (String)client);

    i = 0;
    while( widgets && widgets[i] != NULL )
    {
	if ( XtIsShell(widgets[i]) )
	{
	    XtPopup(widgets[i], XtGrabNone);
	}
	else
	{
	    printf("Callback Error (BxPopupCB):\n\t\
Object %s is not a Shell\n", XtName(widgets[i]));
	}
	i++;
    }
    XtFree((char *)widgets);
}


void
do_mbgrdviz_realtimesetup_icon( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
}

void
do_mbgrdviz_realtimesetup_path_browse( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;

	do_mbgrdviz_fileSelectionBox_realtime( w, client_data, call_data);

}

void
do_mbgrdviz_realtimesetup_updaterate( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
}

void
do_mbgrdviz_realtimesetup_path_test( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
}

void
do_mbgrdviz_realtimesetup_pathmode( Widget w, XtPointer client_data, XtPointer call_data)
{
    XmAnyCallbackStruct *acs = (XmAnyCallbackStruct*)call_data;
}
