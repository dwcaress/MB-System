/*--------------------------------------------------------------------
 *    The MB-system:	mbvelocitytool_stubs.c	6/6/93
 *    $Id: mbvelocitytool_stubs.c,v 4.3 1994-04-12 14:32:21 caress Exp $
 *
 *    Copyright (c) 1993, 1994 by 
 *    D. W. Caress (caress@lamont.ldgo.columbia.edu)
 *    and D. N. Chayes (dale@lamont.ldgo.columbia.edu)
 *    Lamont-Doherty Earth Observatory
 *    Palisades, NY  10964
 *
 *    See README file for copying and redistribution conditions.
 *--------------------------------------------------------------------*/
/*
 * MBVELOCITYTOOL is an interactive water velocity profile editor
 * used to examine multiple water velocity profiles and to create
 * new water velocity profiles which can be used for the processing
 * of multibeam sonar data.  In general, this tool is used to examine
 * water velocity profiles obtained from XBTs, CTDs, or databases,
 * and to construct new profiles consistent with these various
 * sources of information.
 *
 * Author:	D. W. Caress
 * Date:	June 6, 1993
 *
 * $Log: not supported by cvs2svn $
 * Revision 4.2  1994/04/12  01:13:24  caress
 * First cut at translation from hsvelocitytool. The new program
 * mbvelocitytool will deal with all supported multibeam data
 * including travel time observations.
 *
 * Revision 4.0  1994/03/05  23:51:19  caress
 * First cut at version 4.0
 *
 * Revision 4.1  1994/03/03  03:53:26  caress
 * Fixed copyright message.
 *
 * Revision 4.0  1994/02/27  00:17:23  caress
 * First cut at new version.
 *
 * Revision 1.1  1993/08/16  23:28:30  caress
 * Initial revision
 *
 *
 */


/*--------------------------------------------------------------------*/
/*
 * mbvelocitytool_stubs.c - Notify and event callback function stubs.
 * This file was generated by `gxv' from `mbvelocitytool.G'.
 */

/* standard include files */
#include <stdio.h>
#include <sys/param.h>
#include <sys/types.h>
#include <xview/xview.h>
#include <xview/panel.h>
#include <xview/textsw.h>
#include <xview/xv_xrect.h>
#include <xview/cursor.h>
#include <xview/svrimage.h>
#include <xview/cms.h>
#include <sys/dir.h>

/* MBIO include files */
#include "../../include/mb_status.h"

/* XVIEW UI include file for this application */
#include "mbvelocitytool_ui.h"
#include "mbvelocitytool_ui.h"

/*
 * Global object definitions.
 */
mbvelocitytool_window_base_objects	*Mbvelocitytool_window_base;
mbvelocitytool_popup_open_file_objects	*Mbvelocitytool_popup_open_file;
mbvelocitytool_popup_save_file_objects	*Mbvelocitytool_popup_save_file;

/* Global Xwindows graphics parameters */
Display	*dpy;			/* Xwindows display/screen number */
Window	can_xid;		/* Xwindows window id for mbvelocitytool canvas */
Window	frm_xid;		/* Xwindows window id for mbvelocitytool frame */
int	can_xgid;		/* XG graphics id */
int	borders[4];		/* Canvas borders */
int	ncolors;
int	colors[256][3];
char	*fontname = "8x13";
Server_image	svr_image;
Icon	icon;
Xv_singlecolor	black, white;
static Xv_Cursor	cursor;
static short 	crosshair[] = {
#include "cursor.h"
};
static short icon_image[] = {
#include "mbvelocitytool.icon"
};

/* Global mbvelocitytool definitions */
int	edit;
int	ndisplay;
int	maxdepth;
int	velrange;
int	resrange;
int	format;
int	nbuffer;

/* file opening parameters */
int	startup_file = 0;
int	open_files_count = 0;
struct direct **open_files;
int	open_type;
#define	OPEN_NONE		0
#define	OPEN_DISPLAY_PROFILE	1
#define	OPEN_EDIT_PROFILE	2
#define	OPEN_HYDROSWEEP		3

#ifdef MAIN

/*
 * Instance XV_KEY_DATA key.  An instance is a set of related
 * user interface objects.  A pointer to an object's instance
 * is stored under this key in every object.  This must be a
 * global variable.
 */
Attr_attribute	INSTANCE;

main(argc, argv)
	int	argc;
	char	**argv;
{
	static char rcs_id[]="$Id: mbvelocitytool_stubs.c,v 4.3 1994-04-12 14:32:21 caress Exp $";
	int	status;
	int	i;

	/*
	 * Initialize XView.
	 */
	xv_init(XV_INIT_ARGC_PTR_ARGV, &argc, argv, NULL);
	INSTANCE = xv_unique_key();
	
	/*
	 * Initialize user interface components.
	 * Do NOT edit the object initializations by hand.
	 */
	Mbvelocitytool_window_base = mbvelocitytool_window_base_objects_initialize(NULL, NULL);
	Mbvelocitytool_popup_open_file = mbvelocitytool_popup_open_file_objects_initialize(NULL, Mbvelocitytool_window_base->window_base);
	Mbvelocitytool_popup_save_file = mbvelocitytool_popup_save_file_objects_initialize(NULL, Mbvelocitytool_window_base->window_base);
	
	/* set up graphics initialization */
	dpy      = (Display *)xv_get(Mbvelocitytool_window_base->canvas_base, XV_DISPLAY);
	frm_xid  = (Window)xv_get(Mbvelocitytool_window_base->window_base,XV_XID);
	can_xid  = (Window)xv_get(canvas_paint_window(
			Mbvelocitytool_window_base->canvas_base),XV_XID);
	borders[0] = 0;
	borders[1] = (int) xv_get(Mbvelocitytool_window_base->canvas_base,CANVAS_WIDTH)-1;
	borders[2] = 0;
	borders[3] = (int) xv_get(Mbvelocitytool_window_base->canvas_base,CANVAS_HEIGHT)-1;

	/* set cursor */
	svr_image = (Server_image)xv_create(XV_NULL, SERVER_IMAGE,
		XV_WIDTH,           64,
		XV_HEIGHT,          64,
		SERVER_IMAGE_BITS,  crosshair,
		NULL); 
	white.red = white.green = white.blue = 255;
	black.red = black.green = black.blue = 0;
	cursor = (Xv_Cursor)xv_create(XV_NULL, CURSOR,
		CURSOR_IMAGE,               svr_image,
		CURSOR_FOREGROUND_COLOR,    &black,
		CURSOR_BACKGROUND_COLOR,    &white,
		CURSOR_XHOT,                32,
		CURSOR_YHOT,                32,
		NULL);
	xv_set(canvas_paint_window(Mbvelocitytool_window_base->canvas_base),
		WIN_CURSOR,         cursor,
		NULL);

	/* set up program icon */
	svr_image = (Server_image)xv_create(NULL, SERVER_IMAGE,
		XV_WIDTH,		64,
		XV_HEIGHT,		64,
		SERVER_IMAGE_BITS,	icon_image,
		NULL);
	icon = (Icon)xv_create(Mbvelocitytool_window_base->window_base, ICON,
		ICON_IMAGE,		svr_image,
		NULL);
	xv_set(Mbvelocitytool_window_base->window_base, FRAME_ICON, icon, NULL);

	/* set up colormap */
	colors[0][0] = 255;
	colors[0][1] = 255;
	colors[0][2] = 255;
	colors[1][0] = 0;
	colors[1][1] = 0;
	colors[1][2] = 0;
	colors[2][0] = 255;
	colors[2][1] = 0;
	colors[2][2] = 0;
	colors[3][0] = 0;
	colors[3][1] = 255;
	colors[3][2] = 0;
	colors[4][0] = 0;
	colors[4][1] = 0;
	colors[4][2] = 255;
	ncolors = 5;

	/* initialize mbvelocitytool proper */
	status = mbvt_init(argc,argv);

	/* initialize graphics */
	can_xgid = xg_init(dpy, can_xid, borders, colors, ncolors, fontname);
	(void) xg_setwincolormap(can_xgid, frm_xid);
	status = mbvt_set_graphics(can_xgid, borders);

	/* replot everything */
	mbvelocity_set_controls();
	mbvt_plot();
	
	/*
	 * Turn control over to XView.
	 */
	xv_main_loop(Mbvelocitytool_window_base->window_base);
	exit(0);
}

#endif

/*
 * Function to get control values from mbvelocitytool proper
 * and to set the appropriate graphics control values.
 */
int
mbvelocity_set_controls()
{
	char	message[128];

	/* get some default values from mbvelocitytool */
	mbvt_get_defaults(&edit,&ndisplay,&maxdepth,
		&velrange,&resrange,&format,&nbuffer);

	/* set appropriate graphical control values */
	sprintf(message,"%d display water velocity profiles loaded",
		ndisplay);
	xv_set(Mbvelocitytool_window_base->message_status_display,
		PANEL_LABEL_STRING, message,
		XV_SHOW, TRUE,
		NULL);
	if (edit == MB_YES)
		sprintf(message,"Editable water velocity profile loaded");
	else
		sprintf(message,"Editable water velocity profile not loaded");
	xv_set(Mbvelocitytool_window_base->message_status_edit,
		PANEL_LABEL_STRING, message,
		XV_SHOW, TRUE,
		NULL);
	xv_set(Mbvelocitytool_window_base->slider_maxdepth,
		PANEL_VALUE, maxdepth,
		NULL);
	xv_set(Mbvelocitytool_window_base->slider_velrange,
		PANEL_VALUE, velrange,
		NULL);
	xv_set(Mbvelocitytool_window_base->slider_velrange,
		PANEL_VALUE, velrange,
		NULL);
	xv_set(Mbvelocitytool_window_base->slider_residual_range,
		PANEL_VALUE, resrange,
		NULL);
	xv_set(Mbvelocitytool_popup_open_file->textfield_mbformat,
		PANEL_VALUE, format,
		NULL);
	sprintf(message,"%d Multibeam records loaded",nbuffer);
	xv_set(Mbvelocitytool_window_base->message_status_hydrosweep,
		PANEL_LABEL_STRING, message,
		XV_SHOW, TRUE,
		NULL);

	return(0);
}

/*
 * File selector routine called by scandir().
 * Return TRUE if filename is not "." or "..".
 */
int
open_files_select(entry)
	struct direct	*entry;
{
	char		*ptr;

	if ((strcmp(entry->d_name, ".") == 0) ||
	    (strcmp(entry->d_name, "..") == 0))
		return (FALSE);
	else
		return(TRUE);
}

/*
 * Menu handler for `menu_file (Open display profile)'.
 */
Menu_item
mbvelocitytool_menu_file_item0_callback(item, op)
	Menu_item	item;
	Menu_generate	op;
{
	/* local variables */
	int	alphasort();
	int	i;

	mbvelocitytool_window_base_objects * ip = (mbvelocitytool_window_base_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:

		/* delete old scrolling list */
		if (open_files_count > 0)
			{
			xv_set(Mbvelocitytool_popup_open_file->list_open_file,
				PANEL_LIST_DELETE_ROWS, 0, open_files_count,
				NULL);
			open_files_count = 0;
			}

		/* load filenames into scrolling list */
		open_files_count = scandir(".",&open_files,
			open_files_select, alphasort);
		for (i=0;i<open_files_count;i++)
			{
			xv_set(Mbvelocitytool_popup_open_file->list_open_file,
				PANEL_LIST_INSERT, i,
				PANEL_LIST_STRING, i, open_files[i]->d_name,
				NULL);
			}

		/* rename popup title */
		xv_set(Mbvelocitytool_popup_open_file->popup_open_file,
				XV_LABEL, "Open Display Velocity Profile",
				NULL);

		/* set file type flag */
		open_type = OPEN_DISPLAY_PROFILE;
		
		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		xv_set(Mbvelocitytool_popup_open_file->popup_open_file, XV_SHOW, TRUE, NULL);
		
		xv_set(Mbvelocitytool_popup_open_file->textfield_mbformat, XV_SHOW, FALSE, NULL);
		
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `menu_file (Open editable profile)'.
 */
Menu_item
mbvelocitytool_menu_file_item1_callback(item, op)
	Menu_item	item;
	Menu_generate	op;
{
	/* local variables */
	int	alphasort();
	int	i;

	mbvelocitytool_window_base_objects * ip = (mbvelocitytool_window_base_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:

		/* delete old scrolling list */
		if (open_files_count > 0)
			{
			xv_set(Mbvelocitytool_popup_open_file->list_open_file,
				PANEL_LIST_DELETE_ROWS, 0, open_files_count,
				NULL);
			open_files_count = 0;
			}

		/* load filenames into scrolling list */
		open_files_count = scandir(".",&open_files,
			open_files_select, alphasort);
		for (i=0;i<open_files_count;i++)
			{
			xv_set(Mbvelocitytool_popup_open_file->list_open_file,
				PANEL_LIST_INSERT, i,
				PANEL_LIST_STRING, i, open_files[i]->d_name,
				NULL);
			}

		/* rename popup title */
		xv_set(Mbvelocitytool_popup_open_file->popup_open_file,
				XV_LABEL, "Open Editable Velocity Profile",
				NULL);

		/* set file type flag */
		open_type = OPEN_EDIT_PROFILE;
		
		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		xv_set(Mbvelocitytool_popup_open_file->popup_open_file, XV_SHOW, TRUE, NULL);
		
		xv_set(Mbvelocitytool_popup_open_file->textfield_mbformat, XV_SHOW, FALSE, NULL);
		
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `menu_file (New editable profile)'.
 */
Menu_item
action_new_profile(item, op)
	Menu_item	item;
	Menu_generate	op;
{
	mbvelocitytool_window_base_objects * ip = (mbvelocitytool_window_base_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		/* get new edit velocity profile */
		mbvt_new_edit_profile();

		/* replot everything */
		mbvelocity_set_controls();
		mbvt_plot();
		
		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `menu_file (Save editable profile)'.
 */
Menu_item
mbvelocitytool_menu_file_item3_callback(item, op)
	Menu_item	item;
	Menu_generate	op;
{
	mbvelocitytool_window_base_objects * ip = (mbvelocitytool_window_base_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		
		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		xv_set(Mbvelocitytool_popup_save_file->popup_save_file, XV_SHOW, TRUE, NULL);
		
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Notify callback function for `button_quit'.
 */
void
action_quit(item, event)
	Panel_item	item;
	Event		*event;
{
	mbvelocitytool_window_base_objects *ip = (mbvelocitytool_window_base_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	mbvt_quit();

	fprintf(stderr,"\nBye bye!\n");

	if (xv_destroy_safe(Mbvelocitytool_window_base->window_base) == XV_OK)
		exit(0);
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

}

/*
 * Notify callback function for `button_open_file_ok'.
 */
void
mbvelocitytool_popup_open_file_button_open_file_ok_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	/* local definitions */
	int	selected;
	int	status;

	mbvelocitytool_popup_open_file_objects *ip = (mbvelocitytool_popup_open_file_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	/* get selected filename id and file format id */
	selected = (int) xv_get(Mbvelocitytool_popup_open_file->list_open_file,
				PANEL_LIST_FIRST_SELECTED);

	/* deal with it */
	if (selected > -1)
		{
		if (open_type == OPEN_DISPLAY_PROFILE)
			{
			status = mbvt_open_display_profile(
				open_files[selected]->d_name);
			mbvelocitytool_set_menu();
			}
		else if (open_type == OPEN_EDIT_PROFILE)
			status = mbvt_open_edit_profile(open_files[selected]->d_name);
		else if (open_type = OPEN_HYDROSWEEP)
			{
			format = (int) xv_get(
				Mbvelocitytool_popup_open_file->textfield_mbformat,
				PANEL_VALUE);
			status = mbvt_open_hydrosweep_file(
				open_files[selected]->d_name,format);
			mbvelocitytool_set_menu();
			}

		if (status != MB_SUCCESS)
			XBell(dpy,100);
		}
	else
		fprintf(stderr,"\nNo input file selected...\n");

	/* replot everything */
	mbvelocity_set_controls();
	mbvt_plot();
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	xv_set(Mbvelocitytool_popup_open_file->popup_open_file, XV_SHOW, FALSE, NULL);
	
	/* gxv_end_connections */

}

/*
 * Function to set display profile filenames menu.
 */
int
mbvelocitytool_set_menu()
{
	char	*files[10];
	char	*strl;
	Menu	menu_file;
	Menu	menu_display;
	Menu_item	menu_item_close;
	Menu_item	menu_item;
	int	i;

	/* get list of names */
	mbvt_get_display_names(&ndisplay,files);

	/* get handle to menu */
	menu_file = (Menu) xv_get(Mbvelocitytool_window_base->button_file, 
			PANEL_ITEM_MENU);
	menu_item_close = (Menu_item) xv_find(menu_file, MENUITEM,
			MENU_STRING, "Close display profile",
			NULL);
	menu_display = (Menu) xv_get(menu_item_close,MENU_PULLRIGHT);

	/* destroy old menu items */
	for (i=(int)xv_get(menu_display, MENU_NITEMS);i>1;i--)
		{
		xv_set(menu_display, MENU_REMOVE, i, NULL);
		xv_destroy(xv_get(menu_display, MENU_NTH_ITEM, i));
		}

	/* create new menu items */
	for (i=0;i<ndisplay;i++)
		{
		strl = malloc(strlen(files[i])+1);
		strcpy(strl,files[i]);
		menu_item = (Menu_item) 
		xv_create(NULL, MENUITEM,
			MENU_STRING, strl,
			MENU_RELEASE_IMAGE,
			MENU_RELEASE,
			NULL);
		xv_set(menu_display,
			MENU_APPEND_ITEM, menu_item,
			NULL);
		}

}

/*
 * Notify callback function for `button_open_file_cancel'.
 */
void
mbvelocitytool_popup_open_file_button_open_file_cancel_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	mbvelocitytool_popup_open_file_objects *ip = (mbvelocitytool_popup_open_file_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	xv_set(Mbvelocitytool_popup_open_file->popup_open_file, XV_SHOW, FALSE, NULL);
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `button_save_file_ok'.
 */
void
mbvelocitytool_popup_save_file_button_save_file_ok_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	/* local definitions */
	char	*save_file;

	mbvelocitytool_popup_save_file_objects *ip = (mbvelocitytool_popup_save_file_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);

	save_file = (char *) xv_get(Mbvelocitytool_popup_save_file->textfield_save_file,
			PANEL_VALUE);
	mbvt_save_edit_profile(save_file);
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	xv_set(Mbvelocitytool_popup_save_file->popup_save_file, XV_SHOW, FALSE, NULL);
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `button_save_file_cancel'.
 */
void
mbvelocitytool_popup_save_file_button_save_file_cancel_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	mbvelocitytool_popup_save_file_objects *ip = (mbvelocitytool_popup_save_file_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	xv_set(Mbvelocitytool_popup_save_file->popup_save_file, XV_SHOW, FALSE, NULL);
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `slider_maxdepth'.
 */
void
action_maxdepth(item, value, event)
	Panel_item	item;
	int		value;
	Event		*event;
{
	mbvelocitytool_window_base_objects *ip = (mbvelocitytool_window_base_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	maxdepth = value;
	mbvt_set_values(edit,ndisplay,maxdepth,velrange,resrange);

	/* replot everything */
	mbvelocity_set_controls();
	mbvt_plot();
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

}

/*
 * Menu handler for `menu_close_profile'.
 */
Menu
action_menu_close_profile(menu, op)
	Menu		menu;
	Menu_generate	op;
{
	int	nitems;
	int	selected;
	int	status;
	int	i;

	Xv_opaque ip = (Xv_opaque) xv_get(menu, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:

		/* get selected item */
		selected = 0;
		nitems = (int)xv_get(menu,MENU_NITEMS);
		for (i=nitems; i>1; i--)
			{
			if (xv_get(xv_get(menu, MENU_NTH_ITEM, i), 
				MENU_SELECTED))
				selected = i;
			}

		/* delete the profile */
		status = mbvt_delete_display_profile(selected);
		if (status == MB_FAILURE)
			XBell(dpy,100);			

		/* reset menu */
		mbvelocitytool_set_menu();

		/* replot everything */
		mbvelocity_set_controls();
		mbvt_plot();

		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return menu;
}

/*
 * Notify callback function for `slider_velrange'.
 */
void
action_velrange(item, value, event)
	Panel_item	item;
	int		value;
	Event		*event;
{
	mbvelocitytool_window_base_objects *ip = (mbvelocitytool_window_base_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	velrange = value;
	mbvt_set_values(edit,ndisplay,maxdepth,velrange,resrange);

	/* replot everything */
	mbvelocity_set_controls();
	mbvt_plot();
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

}

/*
 * Event callback function for `canvas_base'.
 */
Notify_value
action_canvas_event(win, event, arg, type)
	Xv_window	win;
	Event		*event;
	Notify_arg	arg;
	Notify_event_type type;
{
	int	status;

	mbvelocitytool_window_base_objects *ip = (mbvelocitytool_window_base_objects *) xv_get(xv_get(win, CANVAS_PAINT_CANVAS_WINDOW), XV_KEY_DATA, INSTANCE);
	
	/* process events */
	switch (event_action(event))
		{
		case KBD_USE:
			break;
		case KBD_DONE:
			break;
		case LOC_MOVE:
			break;
		case LOC_DRAG:
			status = mbvt_action_mouse_drag(
				event_x(event),event_y(event));
			if (status == 0) XBell(dpy,100);
			break;
		case LOC_WINENTER:
			break;
		case LOC_WINEXIT:
			break;
		case ACTION_SELECT:
		case MS_LEFT:
		case ACTION_ADJUST:
		case MS_MIDDLE:
		case ACTION_MENU:
		case MS_RIGHT:
			if (event_is_down(event))
				status = mbvt_action_mouse_down(
					event_x(event),event_y(event));
			else if (event_is_up(event))
				status = mbvt_action_mouse_up(
					event_x(event),event_y(event));
			if (status == 0) XBell(dpy,100);
			break;
		default:
			break;
		}

	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

	return notify_next_event_func(win, (Notify_event) event, arg, type);
}

/*
 * Menu handler for `menu_file (Open Multibeam data)'.
 */
Menu_item
mbvelocitytool_menu_file_item6_callback(item, op)
	Menu_item	item;
	Menu_generate	op;
{
	int	i;

	mbvelocitytool_window_base_objects * ip = (mbvelocitytool_window_base_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:

		/* set file type flag */
		open_type = OPEN_HYDROSWEEP;

		/* delete old scrolling list */
		if (open_files_count > 0)
			{
			xv_set(Mbvelocitytool_popup_open_file->list_open_file,
				PANEL_LIST_DELETE_ROWS, 0, open_files_count,
				NULL);
			open_files_count = 0;
			}

		/* load filenames into scrolling list */
		open_files_count = scandir(".",&open_files,
			open_files_select, alphasort);
		for (i=0;i<open_files_count;i++)
			{
			xv_set(Mbvelocitytool_popup_open_file->list_open_file,
				PANEL_LIST_INSERT, i,
				PANEL_LIST_STRING, i, open_files[i]->d_name,
				NULL);
			}

		/* rename popup title */
		xv_set(Mbvelocitytool_popup_open_file->popup_open_file,
				XV_LABEL, "Open Multibeam Data File",
				NULL);
		
		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		xv_set(Mbvelocitytool_popup_open_file->popup_open_file, XV_SHOW, TRUE, NULL);
		
		xv_set(Mbvelocitytool_popup_open_file->textfield_mbformat, XV_SHOW, TRUE, NULL);
		
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Notify callback function for `slider_residual_range'.
 */
void
action_residual_range(item, value, event)
	Panel_item	item;
	int		value;
	Event		*event;
{
	mbvelocitytool_window_base_objects *ip = (mbvelocitytool_window_base_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	resrange = value;
	mbvt_set_values(edit,ndisplay,maxdepth,velrange,resrange);

	/* replot everything */
	mbvelocity_set_controls();
	mbvt_plot();
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

}

/*
 * Notify callback function for `button_process_hydrosweep'.
 */
void
action_process_hydrsoweep(item, event)
	Panel_item	item;
	Event		*event;
{
	int	status;

	mbvelocitytool_window_base_objects *ip = (mbvelocitytool_window_base_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);

	/* process Multibeam data */
	status = mbvt_setup_raytracing();
	if (status == MB_SUCCESS)
		status = mbvt_process_hydrosweep();
	if (status != MB_SUCCESS)
		XBell(dpy,100);

	/* replot everything */
	mbvelocity_set_controls();
	mbvt_plot();
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

}
